<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/f.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/f.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/f.png"><link rel="mask-icon" href="/images/f.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"feiybox.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="小浊微清的博客"><meta property="og:type" content="website"><meta property="og:title" content="feiybox"><meta property="og:url" content="https://feiybox.com/page/7/index.html"><meta property="og:site_name" content="feiybox"><meta property="og:description" content="小浊微清的博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="feiybox"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://feiybox.com/page/7/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>feiybox</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?f51cc75dfef0ebc64f14af202ba27866"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">feiybox</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">DO MORE DO BETTER</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-projects"><a href="/projects/" rel="section"><i class="fa fa-sitemap fa-fw"></i>项目</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">72</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="feiybox" src="/images/head.png"><p class="site-author-name" itemprop="name">feiybox</p><div class="site-description" itemprop="description">小浊微清的博客</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2018/01/08/%E8%A7%A3%E5%86%B3Java-API-since-%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2018/01/08/%E8%A7%A3%E5%86%B3Java-API-since-%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决Java API @since 版本错误问题</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-01-08 23:01" itemprop="dateCreated datePublished" datetime="2018-01-08T23:01:00+08:00">2018-01-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 11:10" itemprop="dateModified" datetime="2019-03-16T11:10:03+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2018/01/08/解决Java-API-since-版本错误问题/cause.png" alt></p><p>在我们的项目开发过程中，常常出现Java版本过低，以导致语法中出现错误的情况，这种情况中我们通常都是比较明了的知道需要提到Java的版本。</p><h3 id="安装的Java版本过低"><a href="#安装的Java版本过低" class="headerlink" title="安装的Java版本过低"></a>安装的Java版本过低</h3><p>这种情况下需要我们重新安装最新版本的Java即可。<br><img src="/2018/01/08/解决Java-API-since-版本错误问题/JavaVersion.png" alt></p><h3 id="IDE中设置的Java版本过低"><a href="#IDE中设置的Java版本过低" class="headerlink" title="IDE中设置的Java版本过低"></a>IDE中设置的Java版本过低</h3><p>比如在IDEA中，通过command + ; 快捷键进入项目结构中可以看到如下图项目结构中的一些信息。（注：快捷键需要是英文键）</p><p><img src="/2018/01/08/解决Java-API-since-版本错误问题/1.png" alt></p><p>在红色框位置可以选择支持的Java版本。</p><p><img src="/2018/01/08/解决Java-API-since-版本错误问题/2.png" alt></p><p>当然，在Modules里面也可以选择支持的Java语言版本。</p><h3 id="IDEA自动重置LanguageLevel和JavaCompiler版本"><a href="#IDEA自动重置LanguageLevel和JavaCompiler版本" class="headerlink" title="IDEA自动重置LanguageLevel和JavaCompiler版本"></a>IDEA自动重置LanguageLevel和JavaCompiler版本</h3><p>如下图发生错误相同，每次都会引入项目，或者开启项目时，都会使得Java版本过低的情况。并且package后也是支持低版本的Java，会引发较大的语法问题。</p><p><img src="/2018/01/08/解决Java-API-since-版本错误问题/3.png" alt></p><p>这个问题虽然可以每次在开发过程中手动调节版本，使得开发过程没有错误。但是不支持所有环境，即打包做出支持库等会出现语法问题，因此需要解决。</p><p>解决方法是，在Maven中引入maven-compiler-plugin，并指定版本。示例如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/12/30/17%E6%9B%B2%E7%BB%88%EF%BC%8C18%E4%BC%8A%E5%A7%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/12/30/17%E6%9B%B2%E7%BB%88%EF%BC%8C18%E4%BC%8A%E5%A7%8B/" class="post-title-link" itemprop="url">17曲终，18伊始</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-12-30 11:16" itemprop="dateCreated datePublished" datetime="2017-12-30T11:16:00+08:00">2017-12-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-02-24 00:37" itemprop="dateModified" datetime="2019-02-24T00:37:59+08:00">2019-02-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>回顾整个17年，我个人成长了不少，我似乎开始从一个入世未深的懵懂少年成为了开始入世的大叔。我思维开始有了自己革命性的改变，我可以开始笑对我自己所面对的所有遭遇，好的，坏的，我都可笑着接受。</p><p>17年，我开始表现整个自我，我开始在简书矫情，写下感动自我的文字。</p><p>17年初，我正当大三下学期里的初章，我决定了我准备毕业后就工作，我去了喜马拉雅实习。那时候，我邂逅简书，我开始在简书上写下我的所遇所感，以及自我的技术总结。</p><p>简书，终究还是我选择自我陶醉或者自我表达的地方。从相遇到现在，我在简书写了三万四千多文字，写了有四十篇随笔或技术。我没有那种文学上的表达能力，只是专注的写下自己的想法。没有感动别人，但终究还是感动了自我。</p><p>17年里，我开始找工作，我最终找到一份比较满意的工作，选择去一个优秀的环境里变得优秀起来，最终自我选择了北漂，开启了北漂一族的生活。我未曾出过远门，而现在却独自北上，从校园到社会，对我来说，“我有什么不能够承受，或者不管什么，都得承受着。”，这是我17年后的最好的总结。</p><p>我来了北京，我开始发现，是因为一个人，所以恋上一座城。而我对于每一座城都不再去追求。倘若我能够在北京好着，而没有我留恋的地方所去，则留下来。对我来说哪儿都是一座城，都是在生活里摸滚打爬。</p><p><img src="/2017/12/30/17曲终，18伊始/17年的北京.jpg" alt="17年的北京"></p><p>17年，也是我从16年的迷茫里里走出来的一年，这一年里，我决定了我毕业后工作的道路，我开始认真学习，我基本保持着至少一个月一本技术书籍的进度学习，认真总结学习。我开始准备构建自己的个人网站，开始学会自己安排进度。</p><p>回顾这17年，我留下的一切，我开始看开感情，随风般任其跟随我心去做，“尽人事而听天命”，虽未尽人事，但也听天由命。我追求哲学里不同的认识，我开始注重经历，感受经历里的每一个风景。</p><p>18年是我毕业的一年，这一年我或者是真正走上社会。这一年里，我有许多想做。</p><p>每个月一本技术书籍，是我想一直坚持下去的学习。既然在技术的道路上来了，那至少让自己会些技术。</p><p>17年末，我开始利用上班途中的时间学习英语。18年里，继续学习吧，方便的话也可以尝试着去考一下雅思托福。既不追求固定未来待着的地方，那么或许以后我也会选择出国深造。也相当于没有一个明确的打算，只是想看看这个世界。</p><p>18年毕业之前，我会争取着让我的个人网站上线。毕业的时候，我也会穿上那个毕业的学士服，或许我也会将学士帽高高抛起。</p><p>18年，我会走下一些北京有趣的地方，留下自己的足迹，带走埋藏的记忆。</p><p>17年终将远去，我做过一些事。18年，我又会做哪些？</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/11/09/%E5%85%B3%E4%BA%8EHLS%E7%9B%B4%E6%92%AD%E6%B5%81HTML%E9%A1%B5%E9%9D%A2%E6%92%AD%E6%94%BE%E8%A7%A3%E5%86%B3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/11/09/%E5%85%B3%E4%BA%8EHLS%E7%9B%B4%E6%92%AD%E6%B5%81HTML%E9%A1%B5%E9%9D%A2%E6%92%AD%E6%94%BE%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">关于HLS直播流HTML页面播放解决</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-11-09 20:47" itemprop="dateCreated datePublished" datetime="2017-11-09T20:47:00+08:00">2017-11-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 11:10" itemprop="dateModified" datetime="2019-03-16T11:10:03+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在最近的项目开发中，涉及了HLS直播音频流的播放，关于网上的资料较多，各种混杂，因此对此在问题解决尝试以及结果进行总结。</p><p><strong>最终解决方案使用百度播放器，通过API，自己写想要的播放器组件。</strong></p><h3 id="什么是HLS"><a href="#什么是HLS" class="headerlink" title="什么是HLS"></a>什么是HLS</h3><p>首先，什么是HLS？</p><blockquote><p><strong>HTTP Live Streaming</strong>（缩写是<strong>HLS</strong>）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8)playlist文件，用于寻找可用的媒体流。</p><p>HLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p><p>—— <a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="noopener">摘自维基百科</a></p></blockquote><p>由于是HLS技术是苹果公司提出的，虽然在该协议的推广上也是作出了许多贡献，但是也是有很多浏览器依然不支持或者不完全支持该协议。</p><h3 id="如何实现页面的直播流播放呢？"><a href="#如何实现页面的直播流播放呢？" class="headerlink" title="如何实现页面的直播流播放呢？"></a>如何实现页面的直播流播放呢？</h3><p>对于直播流方案，我做了几种解决尝试</p><h4 id="方案一：使用video标签"><a href="#方案一：使用video标签" class="headerlink" title="方案一：使用video标签"></a>方案一：使用video标签</h4><p>首先，video标签是HTML 5中的新标签，用于嵌入视频元素。而目前，video标签只支持MP4、WebM、Ogg等格式。</p><p>或许，很疑惑，为什么要用视频元素标签来嵌入音频？对于我们这儿直播流的情况下，一般音频标签目前不能够解决。而使用视频元素标签来嵌入直播音频流。</p><p>既然这儿video标签不支持m3u8的HLS直播流格式，那是不是我这儿说错了？肯定不是。接下来需要借助一些其他开源项目来解决。</p><p>我们在这儿的解决都是基于video.js的一些衍生开源项目解决。</p><p>首先是第一种直接使用<a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">video.js</a>测试。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Player<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/video.js/dist/video-js.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">class</span>=<span class="string">"video-js vjs-default-skin"</span> <span class="attr">controls</span> <span class="attr">preload</span>=<span class="string">"none"</span> <span class="attr">data-setup</span>=<span class="string">'&#123;&#125;'</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"living.url"</span> <span class="attr">type</span>=<span class="string">"application/x-mpegURL"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/video.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">			var player = videojs('video');</span></span><br><span class="line"><span class="undefined">			player.ready(function() &#123;</span></span><br><span class="line"><span class="undefined">				var myPlayer = this;</span></span><br><span class="line"><span class="undefined">				myPlayer.src(url);</span></span><br><span class="line"><span class="undefined">				myPlayer.load(url);</span></span><br><span class="line"><span class="undefined">				myPlayer.play();</span></span><br><span class="line"><span class="undefined">			&#125;);</span></span><br><span class="line"><span class="undefined">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Safari浏览器测试如下</p><p><img src="/2017/11/09/关于HLS直播流HTML页面播放解决/Safari支持使用video.js播放HLS直播流.png" alt="Safari支持使用video.js播放HLS直播流"></p><p>然后，也可以使用<a href="https://github.com/videojs/videojs-contrib-hls" target="_blank" rel="noopener">videojs-contrib-hls</a>项目解决，测试代码示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Player<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/video.js/dist/video-js.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">class</span>=<span class="string">"video-js vjs-default-skin"</span> <span class="attr">controls</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"320"</span> <span class="attr">data-setup</span>=<span class="string">'&#123;&#125;'</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"living.url"</span> <span class="attr">type</span>=<span class="string">"application/x-mpegURL"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/video.js/dist/video.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.12.1/videojs-contrib-hls.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>️注意：在这儿使用的js等资源皆是在线的一些支持。若需要在项目中使用，最好下载到本地使用。</p><p>这儿的测试结果，是对于mac上所有浏览器的一般m3u8视频流（即非直播）都支持，都能够播放。直播流仅持safari、edge、android，其他浏览器会出现错误。</p><p><img src="/2017/11/09/关于HLS直播流HTML页面播放解决/Chrome测试HLS直播流.png" alt="Chrome测试HLS直播流"></p><h4 id="方案二：基于clappr"><a href="#方案二：基于clappr" class="headerlink" title="方案二：基于clappr"></a>方案二：基于clappr</h4><p>由于第一种方案，只能够部分解决HLS流播放的问题，且未解决直播流播放的浏览器兼容问题。因此需要继续寻找新的解决方案。</p><p>这个方案是基于github上<a href="https://github.com/clappr/clappr" target="_blank" rel="noopener">clappr</a>的开源项目解决。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/clappr@latest/dist/clappr.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"player-wrapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">			var playerElement = document.getElementById("player-wrapper");</span></span><br><span class="line"><span class="undefined">			var player = new Clappr.Player(&#123;</span></span><br><span class="line"><span class="undefined">				source: 'm3u8.url',</span></span><br><span class="line"><span class="undefined">				mute: true,</span></span><br><span class="line"><span class="undefined">				height: 360,</span></span><br><span class="line"><span class="undefined">				width: 640</span></span><br><span class="line"><span class="undefined">			&#125;);</span></span><br><span class="line"><span class="undefined">			player.attachTo(playerElement);</span></span><br><span class="line"><span class="undefined">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过测试，发现该方案对于m3u8的视频格式支持播放，但是对于直播流却不支持。</p><h4 id="方案三：基于ChPlayer"><a href="#方案三：基于ChPlayer" class="headerlink" title="方案三：基于ChPlayer"></a>方案三：基于ChPlayer</h4><p>在查询资料中发现，<a href="https://github.com/niandeng-ckplayer/chplayer" target="_blank" rel="noopener">chplayer</a>是网页视频播放器，支持mp4,flv,f4v以及m3u8格式，支持rtmp。支持点播和直播。因此决定使用这个尝试。</p><p>首先将项目下载到本地，然后使用页面测试。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"chplayer/chplayer.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dev</span> <span class="attr">id</span>=<span class="string">'video'</span>&gt;</span><span class="tag">&lt;/<span class="name">dev</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">			var videoObject = &#123;</span></span><br><span class="line"><span class="undefined">				container: '#video', //“#”代表容器的ID，“.”或“”代表容器的class</span></span><br><span class="line"><span class="undefined">				variable: 'player', //该属性必需设置，值等于下面的new chplayer()的对象</span></span><br><span class="line"><span class="undefined">				video: 'living.url' //视频地址</span></span><br><span class="line"><span class="undefined">			&#125;;</span></span><br><span class="line"><span class="undefined">			var player = new chplayer(videoObject);</span></span><br><span class="line"><span class="undefined">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这种方式测试，结果是能够解决直播流问题，并且主流浏览器都是兼容的。因此在我们的项目中决定使用这种方式解决问题。</p><h4 id="方案四：使用hls-js"><a href="#方案四：使用hls-js" class="headerlink" title="方案四：使用hls.js"></a>方案四：使用hls.js</h4><p>目前官方给出兼容情况如下：</p><p><img src="/2017/11/09/关于HLS直播流HTML页面播放解决/hlsjs兼容性.png" alt></p><h4 id="方案五：使用cyberPlayer"><a href="#方案五：使用cyberPlayer" class="headerlink" title="方案五：使用cyberPlayer"></a>方案五：使用cyberPlayer</h4><p>该方式目前基本兼容常用浏览器，我测试的使用基本兼容。在该方式下，通过自己编写播放器按钮等组件可以基本解决该播放问题。但是在这个情况下，需要考虑当播放器出错时，如何屏蔽掉页面中展示的错误信息。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>虽然使用chplayer已经能够解决这个问题，但是在后面的查询资料中发现<a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>，可以解决支持直播音频的播放以及所有解码等，虽然不仅限于该领域。后面可以借助其源码学习并解决音频领域的问题。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/09/01/%E6%88%91%E6%89%80%E9%81%87%EF%BC%8C%E7%9A%86%E4%B8%BA%E6%88%91%E4%B8%80%E7%94%9F/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/09/01/%E6%88%91%E6%89%80%E9%81%87%EF%BC%8C%E7%9A%86%E4%B8%BA%E6%88%91%E4%B8%80%E7%94%9F/" class="post-title-link" itemprop="url">我所遇，皆为我一生</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-09-01 21:51" itemprop="dateCreated datePublished" datetime="2017-09-01T21:51:00+08:00">2017-09-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 17:37" itemprop="dateModified" datetime="2019-03-16T17:37:06+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2017/09/01/我所遇，皆为我一生/公交一路，夜景不变如此.jpg" alt="公交一路，夜景不变如此"></p><p>我所遇，皆为我一生。</p><p>世间沉浮，人生百态，苦乐欢甜，所遇所感，所见所想，皆为我一生财富。</p><p>我说过，我或许除了时间，一无所有；其实并不是，我还有我自己，我的一生。</p><p>我想要一个完美的大学，想要一个完美的结束。第一次参加迎新志愿者，第一次想去看看，刚进校园的我会是什么情况。</p><p>我遇到许多学弟学妹。有的健谈，说不定内心藏匿着一个内向的自己；有的沉默，说不定是一个开朗的人。有的很好相处，有的有点内向。</p><p>而当初的我究竟是怎么样的呢？</p><p>我看不透一生，因为我没有一生的积累。我看不透浮沉，因为我没有物质的基础。人生是怎样？未来的我是怎样？</p><p>大学里，第一年里，我勤奋刻苦，我那时候十分努力，那时候，我努力是为了什么？其实我不懂。我可能只是持续着好友说的，“到一个新的环境里，我也想要名列前茅，不求第一，但求上榜”。</p><p>大二里，我搬了校区，开始颓废的我开始迷惘，我究竟是要读研还是找工作呢？迷惘的我在迷惘的迷离的路灯下前行，是不是前行，我也不清楚。或许只是原地踏步吧，或许还有些后退吧，浪费了时光。</p><p>大三下里，我开始实习，我也开始学习，这半年里，我知道我在努力，我知道我是幸福的，那种努力的幸福。</p><p>穷尽一生，我的一生究竟有多长，我不知道，或许挺短，或许也很长。我会后悔吗？那是肯定会啊。我只想我以后不后悔曾今后悔过。</p><p>当初我踏进校园，与走出高中，心情是不同的吧。这学校这么大，或许有些激动吧，也有些无赖，我最想来的并不是这儿。或许这种错过是上天给我的最好的选择，让我进入代码的世界，唱着“Hello world”，拥抱世界。也或许是上天给我的选择，是殊途同归，还是道不同。</p><p>刚进校园的我，没有迷惘，没有一丝犹豫。我心中总是默默告诉自己，要好好学习。我没做到吧。</p><p>大学里，我遇到不同的人，学弟学妹，学长学姐，各式各样，各有各的人生，我羡慕的是别人人生里那种自信；羡慕别人时间里可以有多一年或者两年的选择，羡慕别人比我年轻。总是叹息着，要是我现在才大三该多好啊。可惜，我大四了。</p><p>大四的字眼里总是有着不同的含义一样，对于所有，大四总是特殊的。那种百感交集，会在大四的日子里一一体现出来。</p><p>这三年里，我或许什么都基本经历过吧，为了考试，我可以在考前一周学完一学期的内容，而且学得更好，我可以熬夜到一点多，就为了看完复习资料，而第二天早起考试。</p><p>我可以白天上班，晚上上课，直到回寝室的路上竟然叫不出同班同学的名字。我可以坐一个多小时破破烂烂的公交，为了和你相聚。我可以为了考过科三，见过凌晨三点一闪而过的流星。我可以为了看尽我的大学，在大四开始的最忙时间里参加迎新。</p><p>别人总说，穷尽一生的运气遇到你。我不同意，遇到你是我一生的经历。</p><p>别人总说，自己运气太差。我不同意，遇到的一切皆为我的一生。</p><p>大学里，我有过拼搏，有过忙碌，有过社团，有过图书馆义工，有过迎新，有过一段伤情的恋爱，有过颓废，有过和室友一起游戏，有过逃课……</p><p>大学里，我还差一场说走就走的旅行，还差一个挂科记录。</p><p>世间所遇，都有不同的规律吗？缘在于上天吗？我不同意，规律是由自己决定的，缘是由自己创造的。我所遇，皆为我的选择，都是我选择的结果。</p><p>每一滴泪，每一颗汗，每一次哈哈大笑，每一回沉默不语，都是我的一生。我的感情变化，我的思想变化，都是我的财富。</p><p>大学里，我学会了短时间学会，我拓宽了视野，我开始为一生做安排。我开始喜欢哲学，我开始经常问自己，我想要做什么，我该做什么。</p><p>我一生里后续怎样谱写？</p><p>我所遇，皆为我幸，为我一生。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/07/21/Mac%E4%B8%8AVPN-%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/07/21/Mac%E4%B8%8AVPN-%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">Mac上VPN 连接不上常用解决方案</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-07-21 17:52" itemprop="dateCreated datePublished" datetime="2017-07-21T17:52:00+08:00">2017-07-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 10:20" itemprop="dateModified" datetime="2019-03-16T10:20:52+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在工作中常常使用VPN，但是也常常出现VPN连接不上的情况，对于这种情况我们常常是深恶痛绝，花掉半天的时间也没解决，因此在这儿给出我自己的常用解决方案，一般按照着方案1、2、3的顺序执行，通常情况下都是解决的了。</p><p><img src="/2017/07/21/Mac上VPN-连接不上常用解决方案/VPN连接不上.png" alt="VPN连接不上"></p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>尝试着删除掉我们所配置的VPN，然后重新配置，尝试连接。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>这是大家常见的方案，在 /etc/ppp下的options文件中写入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugin L2TP.ppp</span><br><span class="line">l2tpnoipsec</span><br></pre></td></tr></table></figure><p>然后重新连接。</p><p>具体的操作步骤如下：</p><ul><li>在终端中输入 <code>sudo vim /etc/ppp/options</code>，可能需要密码；</li><li>在文件中输入i进入insert方式，然后输入上诉代码，然后按esc，输入<code>:wq</code>，回车保存；</li><li>尝试着重新连接或删除掉旧配置重新连接；</li></ul><p><img src="/2017/07/21/Mac上VPN-连接不上常用解决方案/options文件.png" alt="options文件"></p><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p>如果上述方案都不能够奏效，那么尝试第三种方案。<em>此方案只能在方案2不奏效的情况下使用</em></p><ul><li>删除<code>/etc/ppp/options</code>文件，即在终端执行<code>sudo rm -rf /etc/ppp/options</code>；</li><li>删除VPN的配置重新配置，连接。<strong><em>这儿一定要删除配置重新配置</em></strong>（至于为什么，我也不清楚，反正不重新配置一般是不能成功的）</li></ul><p>一般情况下，按照这三种方案的顺序执行后都是能够成功访问了。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>若本文中未总结的相关解决方案，欢迎补充。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/06/09/MyBatis%E5%88%9D%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/06/09/MyBatis%E5%88%9D%E8%A7%A3/" class="post-title-link" itemprop="url">MyBatis初解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-06-09 14:56" itemprop="dateCreated datePublished" datetime="2017-06-09T14:56:00+08:00">2017-06-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 10:20" itemprop="dateModified" datetime="2019-03-16T10:20:52+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>MyBatis是一种半自动映射的框架。是目前较为流行的Java ORM框架。（ORM模型是指数据库的表与Java的POJO的映射关系模型，解决之间的相互映射。）本文主要是我在学习了《深入浅出MyBatis技术原理与实战》后的自我总结。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局映射器启用缓存 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局延时加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 不对带有延时加载属性的对象完全加载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对单一SQL允许返回多结果集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许使用列标签代替列名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 允许使用自定义的主键值(比如由程序生成的UUID 32位编码作为键值)，数据表的PK生成策略将被覆盖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动映射任意复杂的结果集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"FULL"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 简单执行器  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库超过25000秒仍未响应则超时 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置使用log4j记录日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"log4j"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动转换驼峰命名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是简单Mybatis的设置。依然还有许多属性我们没有提到。在我们的设置中，<code>autoMappingBehavior</code>是有三种设置：NONE（取消自动映射）、PARTIAL（只会映射没有定义嵌套结果集映射的结果集，在缺省配置的情况下默认）、FULL；而<code>defaultExecutorType</code>表示执行器executor类型，分为三种：SIMPLE（普通执行器，默认情况下是SIMPLE）、REUSE（执行器会重用预处理语句prepared statements）、BATCH（执行器会重用语句并执行批量更新）。</p><p>在configuration中还会涉及其他属性，常用的有typeAliases（类型命名）、typeHandler（类型处理器）、plugins（插件）等。而对于typeHandler的配置里，又有javaType与jdbcType，typeHandler就是解决其转换的问题。</p><h4 id="MyBatis-Spring"><a href="#MyBatis-Spring" class="headerlink" title="MyBatis-Spring"></a>MyBatis-Spring</h4><p>一般情况下，我们大多数情况下是在Spring中使用MyBatis，即需要配置MyBatis-Spring。分为五步进行配置：</p><ul><li>配置数据源</li><li>配置SqlSessionFactory</li><li>配置SqlSessionTemple（使用Mapper接口编程方式，这儿的配置就隐藏了）</li><li>配置Mapper</li><li>事务处理</li></ul><p>先配置数据源。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.url']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.username']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['jdbc.password']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.minIdle']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.maxActive']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.initialSize']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.maxWait']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.timeBetweenEvictionRunsMillis']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"#&#123;jdbc['ds.minEvictableIdleTimeMillis']&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置监控统计拦截的filters --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span> <span class="attr">value</span>=<span class="string">"stat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这儿我们使用的Druid数据源。接下来配置SqlSessionFactory。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 主配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:/mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动扫描sqlmap目录下的所有SQL映射的xml文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mappers/*.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自动注册javabean别名 默认会使用javabean的首字母小写的非限定类名来作为它的别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"fei.self.model"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring与mybatis整合配置，扫描所有dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描基本包路径下的所有映射器接口类 采用分号或者逗号分隔 可设置多个包路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.ximalaya.ops.fei.self.dao"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--多个数据源 可设置具体的sqlSessionFactoryBean 单个数据源不必配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这儿的mybatis-config.xml就是我们之前的configuration以及setting的那个文件。并且在这儿，我们配置了自动扫描信息，包括扫描所有的DAO以及Mapper文件。接下来只剩下事务处理的配置了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对dataSource 数据源进行事务管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:dataSource-ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 事务管理 通知 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对insert,update,delete 开头的方法进行事务管理,只要有异常就回滚 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Throwable"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Throwable"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Throwable"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"reset*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Throwable"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"getExecution*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"java.lang.Throwable"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- select,count开头的方法,开启只读,提高数据库访问性能 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"select*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"count*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对其他方法 使用默认的事务管理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启用对事务注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这是最基础的MyBatis-Spring的配置。这部分其实挺无趣的，个人觉得MyBatis最有趣的就是接下来的MyBatis的技术原理以及插件等。关于Mapper的一些在这儿不作罗列了。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>所谓动态SQL，指的是一些特殊的MyBatis标签的使用，从而对于SQL的拼装具有动态性的效果。主要是if、choose、trim、foreach以及bind元素这些。这部分其实挺有趣的，可以增加我们对于MyBatis的掌握。这部分的知识在这儿不作罗列，看一些例子都能明白。</p><h3 id="MyBatis原理"><a href="#MyBatis原理" class="headerlink" title="MyBatis原理"></a>MyBatis原理</h3><p>终于到了重点且有趣的地方，这部分知识可以帮助我们理解MyBatis，然后能写一些好用的插件。</p><p><img src="/2017/06/09/MyBatis初解/原理.png" alt></p><p>在学习之前需要掌握动态代理，分为JDK动态代理与CGLIB动态代理。</p><p>首先，需要构建SqlSessionFactory。第一步，先通过XMLConfigBuilder解析配置文件，存入Configuration类中（这个类里基本保存了所有的配置）。第二步，使用Configuration去构建SqlSessionFactory。对于SqlSessionFactory，这是一个接口，在一般MyBatis中用DefaultSqlSessionFactory的实现类，对于接口的方法都做了实现。</p><p>第二个需要掌握的是Mapper映射器。我们提到过，在Configuration中，有所有的配置，当然映射器也在里面。需要了解的是，Mapper映射是通过动态代理的方式实现的。一般映射器里面包含有三部分：MappedStatement：用户保存映射节点；SqlSource：这是MappedStatement的一个属性，一个接口，主要是根据参数和其他规则组装SQL，当然它提供BoundSql；BoundSql：建立SQL和参数的地方。我们一般修改SQL或者参数都是在BoundSql中修改的。对于BoundSql中如何实现多种参数的注入方式，我这儿就不讲解了。</p><p>既然有了SqlSessionFactory，那么我们很容易就得到SqlSession了。从Mapper映射器中，我们通过代理对象会进入到MapperMethod的execute方法。然后就能进入SqlSession的方法里了。我们需要了解的是SqlSession里的增删改查方法是如何实现的。</p><p>首先SqlSession下有四大对象。1、Executor执行器：用来调度StatementHandler、ParameterHandler、ResultHandler；2、StatementHandler：这个是在SqlSession里最重要的部分，它可以使数据库的Statement，即PreparedStatement执行操作（PreparedStatement接口是继承了Statement接口）；3、ParamentHandler：用于SQL的参数处理；4、ResultHandler：用于最后返回数据集的封装。我学到这儿很疑惑这个Satement究竟是什么？Statement 对象用于执行不带参数的简单 SQL 语句；PreparedStatement 对象用于执行带或不带 IN 参数的预编译 SQL 语句；CallableStatement 对象用于执行对数据库已存在的存储过程的调用。我们一般在插件中使用的是PrepareStatement，这三者对应了三种数据库会话器，SimpleStatementHandler、PrepareStatementHandler、CallableStatementHandler。对于着Executor也分为三种SIMPLE、REUSE、BATCH。关于参数处理器以及结果处理器就不提及了。</p><p><img src="/2017/06/09/MyBatis初解/SqlSesion内部运行图.png" alt="SqlSesion内部运行图"></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件部分，我无法总结清晰，所以给出我的分页插件中重点intercept函数实现的基本流程图。</p><p><img src="/2017/06/09/MyBatis初解/intercept函数.png" alt="intercept函数"></p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>本文主要是个人的一些总结，没有完全梳理MyBatis的流程等，也没有完全涉及MyBatis的所有知识。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/05/19/SCC%E7%AE%97%E6%B3%95%E5%88%9D%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/19/SCC%E7%AE%97%E6%B3%95%E5%88%9D%E8%A7%A3/" class="post-title-link" itemprop="url">SCC算法初解</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-19 11:05" itemprop="dateCreated datePublished" datetime="2017-05-19T11:05:00+08:00">2017-05-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 11:10" itemprop="dateModified" datetime="2019-03-16T11:10:03+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在算法学习之路上漂泊，遇见了图，而分无向与有向。在本文中主要讲解关于有向图中的求极大连通分量的算法，主要是Kasaraju算法、Tarjan算法以及Gabow算法。</p><p>三种算法都是基于深度优先搜索算法（DFS）而实现的，实际上后两种算法是对于Kasaraju算法的改进，减少了一次深度优先搜索（DFS），因此在性能上相比较而言要好一些。</p><h3 id="初识强连通分量"><a href="#初识强连通分量" class="headerlink" title="初识强连通分量"></a>初识强连通分量</h3><p>首先，连通分量是无向图G的一个极大连通子图称为G的一个连通分量（或连通分支）。连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量。</p><p>强连通图指每一个顶点皆可以经由该图上的边抵达其他的每一个点的有向图。意即对于此图上每一个点对(Va,Vb)，皆存在路径Va→Vb以及Vb→Va。强连通分量则是指一张有向图G的极大强连通子图G’。如果将每一个强连通分量缩成一个点，则原图G将会变成一张有向无环图。一张图被称为有向无环图当且仅当此图不具有点集合数量大于一的强连通分量，因为有向环即是一个强连通分量，而且任何的强连通分量皆具有至少一个有向环。（摘自维基百科）</p><p>对于无向图，求连通分量的问题就等价于求是否连通的问题，使用深度优先、广度优先搜索的算法的到的树都能求出最大连通分量。</p><h3 id="Kasaraju算法"><a href="#Kasaraju算法" class="headerlink" title="Kasaraju算法"></a>Kasaraju算法</h3><p>Kasaraju算法在我第一次接触时，感觉确实有点难理解，虽然现在也还是有点难理解。本文中不会去证明算法，只是讲解算法的一些实现等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KosarajuSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    List&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    KosarajuSCC(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正向遍历，以后根序压栈，保证根先出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillorder</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited, Stack&lt;Integer&gt; s)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : <span class="keyword">this</span>.adj[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                fillorder(i, visited, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reverse 得到反向图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KosarajuSCC <span class="title">getTranspose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KosarajuSCC gv = <span class="keyword">new</span> KosarajuSCC(<span class="keyword">this</span>.n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer j : <span class="keyword">this</span>.adj[i]) &#123;</span><br><span class="line">                gv.adj[j].add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DFS打印连通分支</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DFSUtil</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="keyword">true</span>;</span><br><span class="line">        System.out.print(v + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : adj[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                DFSUtil(i, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照Kosaraju算法的步骤执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSCCs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逆后序压栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                fillorder(i, visited, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到反向图</span></span><br><span class="line">        KosarajuSCC gr = <span class="keyword">this</span>.getTranspose();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依据反向图算可达性</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = s.pop();</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                gr.DFSUtil(v, visited);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先理解一下Karasaju算法的思路。</p><p><img src="/2017/05/19/SCC算法初解/Kasaraju算法.png" alt="Kasaraju算法"></p><ul><li>对图G求其逆后序，即在深度优先遍历（DFS）中在递归调用之后压入栈中；</li><li>对G进行转置，在代码中即得到反图；</li><li>按照第一步中得到的栈的出栈的顶点顺序，对于G<sup>R</sup>图进行DFS可以得到若干搜索树。每棵搜索树都代表一个强连通分量。</li></ul><p><img src="/2017/05/19/SCC算法初解/示例图G.png" alt="示例图G"></p><p>如上图示例的有向图，先求逆后序排序，得到<code>{7, 8, 6, 9, 11, 10, 12, 0, 5, 4, 2, 3, 1}</code>，然后按照这个图的转置图G<sup>R</sup>进行DFS，最终可以得到极大强连通分量5个：<code>{7, 8}, {6}, {9, 11, 10, 12}, {0, 5, 4, 2, 3}, {1}</code>。</p><p>在Karasaju算法中使用了两次DFS，第一次是得到节点的逆后序排序（有的算法书将逆后序排序合并在拓扑排序里面）；第二次是对于转置图DFS得到最终的强连通分量。我们当然想要对于算法进行优化，减少DFS的次数也是一种极好的优化方式，想想如果一次DFS就可以得出强连通分量岂不是很好。</p><h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><p>Tarjan算法是对于Kasaraju算法的改进。其基本代码实现思维如下：</p><ul><li>遍历一个点，指定唯一时间戳<code>DFN[i]</code>；指定改点向前追溯可追溯到最老时间戳<code>LOW[i]</code>；</li><li>枚举当前点的所有边，若<code>DFN[j]=0</code>表明未被搜索过（这儿0、-1等都是可以的，只要是自我约定好的，正常不使用的就可以，如下面算法中使用的<code>NO_VISIT</code>），递归搜索；</li><li>当<code>DFN[i]</code>不为0，则j被搜索过，这时判断是否在我们存储新建的栈中，且j的时间戳<code>DFN[j]</code>小于当前时间戳<code>DFN[i]</code>，可判定成环，将<code>LOW[i]</code>设定为<code>DFN[j]</code>；</li><li>若这个点<code>LOW[i]</code>和<code>DFN[i]</code>相等，则这个点是目前强连通分量的元素中在栈中的最早的节点；</li><li>出栈，将这个强连通分量全部弹出，保存。</li></ul><p><img src="/2017/05/19/SCC算法初解/Tarjan算法.png" alt="Tarjan算法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TarjanSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfNode;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Integer&gt;&gt; graph;<span class="comment">//二维数组表示图</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Integer&gt;&gt; result;<span class="comment">//保存极大强连通图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] inStack;<span class="comment">//标记节点是否在栈内</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] dfn;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] low;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;<span class="comment">//当前时间戳（实际是一个int的数，标记当前访问的节点）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_VISIT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TarjanSCC</span><span class="params">(List&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> numOfNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graph = graph;</span><br><span class="line">        <span class="keyword">this</span>.numOfNode = numOfNode;</span><br><span class="line">        <span class="keyword">this</span>.inStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numOfNode];</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        dfn = <span class="keyword">new</span> <span class="keyword">int</span>[numOfNode];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[numOfNode];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dfn, NO_VISIT);<span class="comment">//将dfn所有元素都置为0，代表i还有没被访问过。</span></span><br><span class="line">        Arrays.fill(low, NO_VISIT);</span><br><span class="line">        result = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取强连通分量</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ArrayList&lt;Integer&gt;&gt; tarjanResult() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfNode; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[i] == NO_VISIT) &#123;</span><br><span class="line">                tarjan(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//算法核心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">        dfn[current] = low[current] = time++;</span><br><span class="line">        inStack[current] = <span class="keyword">true</span>;</span><br><span class="line">        stack.push(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.get(current).size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = graph.get(current).get(i);</span><br><span class="line">            <span class="keyword">if</span> (dfn[next] == NO_VISIT) &#123;</span><br><span class="line">                tarjan(next);</span><br><span class="line">                low[current] = Math.min(low[current], low[next]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[next]) &#123;</span><br><span class="line">                low[current] = Math.min(low[current], dfn[next]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low[current] == dfn[current]) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (current != j) &#123;</span><br><span class="line">                j = stack.pop();</span><br><span class="line">                inStack[j] = <span class="keyword">false</span>;</span><br><span class="line">                temp.add(j);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是在算法中的时间戳这个标记，并不是代表真正的时间戳，而是对于每个节点不同的一种标记，在本文算法中都是用一个递增数组来表示，即访问每个节点时，将该时间戳变量自增赋值给该节点的时间戳<code>DFN[i]</code>。</p><h3 id="Gabow算法"><a href="#Gabow算法" class="headerlink" title="Gabow算法"></a>Gabow算法</h3><p>Gabow算法在基础上与Tarjan算法相似，都是利用一次DFS算法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GabowSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfNode;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Integer&gt;&gt; graph;<span class="comment">//二维数组表示图</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ArrayList&lt;Integer&gt;&gt; result;<span class="comment">//保存极大强连通图</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] order;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> time;<span class="comment">//当前时间戳（实际是一个int的数，标记当前访问的节点）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NO_VISIT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] part; <span class="comment">// 连通变量的标号；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> partNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GabowSCC</span><span class="params">(List&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> numOfNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graph = graph;</span><br><span class="line">        <span class="keyword">this</span>.numOfNode = numOfNode;</span><br><span class="line">        <span class="keyword">this</span>.path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        order = <span class="keyword">new</span> <span class="keyword">int</span>[numOfNode];</span><br><span class="line">        part = <span class="keyword">new</span> <span class="keyword">int</span>[numOfNode];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(order, NO_VISIT);</span><br><span class="line">        Arrays.fill(part, NO_VISIT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gabowResult() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numOfNode; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order[i] == NO_VISIT) &#123;</span><br><span class="line">                gabow(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> part;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gabow</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        order[v] = ++time;</span><br><span class="line">        path.push(v);</span><br><span class="line">        root.push(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.get(v).size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = graph.get(v).get(i);</span><br><span class="line">            <span class="keyword">if</span> (order[next] == NO_VISIT) &#123;</span><br><span class="line">                gabow(next);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (part[next] == NO_VISIT) &#123;</span><br><span class="line">                <span class="keyword">while</span> (order[root.peek()] &gt; order[next]) &#123;</span><br><span class="line">                    root.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v == root.peek()) &#123;</span><br><span class="line">            root.pop();</span><br><span class="line">            partNum++;</span><br><span class="line">            <span class="keyword">int</span> top;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                top = path.peek();</span><br><span class="line">                part[top] = partNum;</span><br><span class="line">                path.pop();</span><br><span class="line">            &#125; <span class="keyword">while</span> (top != v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其算法基本思路是：</p><p><img src="/2017/05/19/SCC算法初解/Gabow算法.png" alt="Gabow算法"></p><ul><li>在所有顶点中，找一个没有被访问的节点v，如果没有则完成；</li><li>记录v的访问顺序；<br>将v压入堆栈path和root；<br>如果v指向的邻接点，对应每个邻接点next：<br>1、如果没有访问过，则以next为参数，递归到第二步；<br>2、如果访问过，且没有确定它属于哪个强连通分量，弹出root栈中next之后（即之上）的所有顶点；<br>3、如果root栈中的元素等于v，那么在part中记录顶点对应的强连通分量</li><li>递归返回</li></ul><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>本文只涉及算法的实现，没有设计算法的证明等，如有想法，请分享。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/05/13/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/13/%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">基础查找算法分析</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-13 20:43" itemprop="dateCreated datePublished" datetime="2017-05-13T20:43:00+08:00">2017-05-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 11:10" itemprop="dateModified" datetime="2019-03-16T11:10:03+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在之前学习了一些排序算法，得出了<a href="https://feiybox.github.io/2017/04/24/%E5%AF%B9%E4%BA%8E%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">基础排序算法的总结</a>。之后学习了一些查找算法，今天来对于基础的一些查找算法进行总结。</p><p>排序与查找是我们一般开发中最常用的算法。例如在开发中需要找出某个人的个人信息，就需要根据某个关键信息去查找。</p><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找是按照我们思维最通俗易懂的算法，就是依次去对比，得到相等的则查找成功。当然这种算法是十分低效的，但是它对于我们需要查找的数据源，没有任何要求，就如数组中数据是可以乱序的。</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>相似与之前排序算法的分治的思想，但是这种类似于分治的思想确实不同于分治。与分治得到有序结果相对应的是我们在查找的时候需要查找的数据源是有序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halfFind</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = N - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是基于有序数组的二分查找算法简单实现，可以极大的减少比较次数，但是无法改变减少运行所需的时间，因为在查找源是无序的情况，将其排序成有序的情况也是需要一定运行时间的。二分查找的思想在很多查找算法里面都有体现，如插值查找、切波那锲查找、二叉查找数等都体现了这种思想。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树也是使用了二分的思想，只是在数据存储时使用二叉树的存储方式，也是链表的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">halfTreeFind</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二叉查找树中，插入难度和查找是差不多的，运行时间主要取决于树的形状。而删除一个结点，是将其右子树中最小的结点上浮来替代。当然从其运行时间与树的形状相关，因此我们需要想办法使得树的形状基本趋于平衡，而使得效率最高。即平衡查找树。</p><h4 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a>平衡查找树</h4><p>由二叉查找树的缺点而推出平衡查找树，其中包括2-3查找树、红黑树等。</p><p>在一棵完美的2-3查找树中、所有空链接到根结点的距离都是相同的。其有两种结点、具有1个数和2个数的结点、即有2个子分支和3个子分支。在查找与插入的时候都需要分别考虑，虽然情况是有限的几种，但是我还是觉得有点繁琐。</p><p>而红黑树相比较像是对于2-3树的一种升级，用红的连接来替代3结点。但是我还是比较喜欢是结点标红的意思。对于红黑树的定义在之前的文章中体现过。红黑树在于查找、插入和删除上都是十分好的，所以在java1.8的HashMap中，满足某个特定条件时会将链表转化为红黑树。</p><p>对于红黑树，所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别，当然范围查找除外。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>我第一次听说散列表的时候，对于散列的意思有点迷糊，搞不懂其与哈希表的关系。后来才明白散列表就是哈希表。</p><p>哈希表中，首先需要的是一个哈希算法，最常见的就是%，除留余数法。第二点是解决冲突，一般就是拉链法与线性探测法。对于开发地址散列表中，最简单的方法就是线性探测法。</p><p>至于对于散列表，我就不详解了，<a href="https://feiybox.github.io/2017/04/03/HashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">HashMap源码分析</a>看完后都能基本明白。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>在查找算法中，普遍都是基于二分的思想进行优化的。类似于排序算法中基于分治的思想一样。虽然本文总结不够完善，但也基本理清我的思维。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/05/04/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/04/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">洗牌算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-04 09:48" itemprop="dateCreated datePublished" datetime="2017-05-04T09:48:00+08:00">2017-05-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-03-16 11:10" itemprop="dateModified" datetime="2019-03-16T11:10:03+08:00">2019-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>第一次接触洗牌算法是在一次面试上，面试官要求我写出一个算法将一个1～100的有序数组打乱，不考虑性能，那次我想了许久，想到一种基于二叉排序的方式实现了随机洗牌，但是那个性能呢，惨不忍睹。后来详细学习排序算法的时候，发现为了保证快速排序的性能，需要在排序之前对排序的数组进行洗牌操作。</p><h3 id="为什么不基于一般排序算法做洗牌？"><a href="#为什么不基于一般排序算法做洗牌？" class="headerlink" title="为什么不基于一般排序算法做洗牌？"></a>为什么不基于一般排序算法做洗牌？</h3><p>众所周知，一般排序算法在在性能上以快速排序最好吧，时间复杂度基本在N*logN，空间复杂度在logN，当然三切分快速排序更好一些。所有算法中空间复杂度最好时为1，这当然是最好的。详细见<a href="https://feiybox.github.io/2017/04/24/%E5%AF%B9%E4%BA%8E%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">对于基础排序算法的简要总结</a>。但是在排序算法中没有能够达到时间复杂度N的线性的。而在洗牌算法中，我们随便便能实现N的线性的时间复杂度，因此基于排序算法做洗牌不可取。</p><h3 id="洗牌算法第一版"><a href="#洗牌算法第一版" class="headerlink" title="洗牌算法第一版"></a>洗牌算法第一版</h3><p>初次想的是一个排列好的数组，再新建一个长度相等的数组，每次通过随机数，随机一个N以内的数作为下标将其添加到新数组，并将该随机下标与N为下标的数交换，当然N需要自减。在N开始的时候为数组长度减1的值（保证下标最大而不越界）。那么最后会形成一个任意数组在数组内的某一位置的概率都是1/N的随机数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Comparable[] Shuffle1(Comparable[] c) &#123;</span><br><span class="line">    Comparable[] a = <span class="keyword">new</span> Comparable[c.length];</span><br><span class="line">    <span class="keyword">int</span> N = c.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++, N--) &#123;</span><br><span class="line">        <span class="keyword">int</span> ran = intRandom(<span class="number">0</span>, N);</span><br><span class="line">        a[i] = c[ran];</span><br><span class="line">        c[ran] = c[N];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种算法相比较之前打算基于一般排序算法求解的方式，在时间复杂度上有了很大的提升。在时间复杂度上，这种算法保证了N次循环（N为数组长度），N次获取随机值，N次交换（但是有2N次数组元素赋值操作）实现了分部均匀的洗牌算法。但是它的缺点是需要另建数组，使得空间复杂度增加。</p><p>在算法中使用了随机数的intRandom函数如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">intRandom</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min &gt; max) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"min can not bigger than max"</span>);</span><br><span class="line">    <span class="keyword">if</span> (max == min) </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(max - min + <span class="number">1</span>) + min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌算法第二版"><a href="#洗牌算法第二版" class="headerlink" title="洗牌算法第二版"></a>洗牌算法第二版</h3><p>为了减少空间复杂度，使得算法在原地进行洗牌操作，尝试着将算法改进。在本算法中使用随机生成一个下标，使得对应的数与第一个i个数交换（i会从0到N-1自增）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Shuffle2</span><span class="params">(Comparable[] c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = c.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Comparable mid = c[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ran = intRandom(<span class="number">0</span>, N-<span class="number">1</span>);</span><br><span class="line">        c[<span class="number">0</span>] = c[ran];</span><br><span class="line">        c[ran] = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在本算法中，空间复杂度是1，达到最小。而时间复杂度也没有很大升高，依然需要N次循环，N次随机，N次交换（但是有3N次赋值操作）。因为对于数组中的每个数都会进行同样的操作，不因为数组元素顺序等变化，因此对于任意一个数分布在某个位置的概率是相同的。所有这是目前我发现的最好的洗牌算法。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>本文仅讲述一些自我对于洗牌算法的一些了解以及自我的一些思考以及实现，在目前我的了解中，这两种洗牌算法是最好的了，如有更好，请指出，共同学习。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2017/05/03/Maven%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2017/05/03/Maven%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Maven基础总结</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-05-03 11:47" itemprop="dateCreated datePublished" datetime="2017-05-03T11:47:00+08:00">2017-05-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-07 00:43" itemprop="dateModified" datetime="2020-12-07T00:43:40+08:00">2020-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>鉴于最近基本看完《Maven实战》这本书，对于我自己的所看的结果作一下总结，理清自己的思路，并复习书中的知识。当然有时间会继续学习一下Gradle，似乎是一个更好的工具。</p><p>我原来对于Maven的印象就是依赖管理的工具，但是在认真学习之后，认识到Maven可以实现挺多实用功能。</p><ul><li>自动化构建</li><li>依赖管理（提供中央仓库，能够帮我们自动下载构建）</li><li>项目信息管理</li></ul><p>在Maven中最重要的思维莫过于约定优于配置。虽然在Maven中没有确定的文件定义一些要求，但是大家约定的一些写法等，保证了项目的移植性，当然也可以自定义，但是不推荐（因为你写了可能就自己看得懂了，别人都看不懂）。在Maven项目中默认的主代码目录为<code>src/test/java</code>，默认的测试代码目录为<code>src/test/java</code>。</p><h3 id="Pom文件"><a href="#Pom文件" class="headerlink" title="Pom文件"></a>Pom文件</h3><p>在平时开发中，感觉到pom.xml文件是Maven项目中最重要的一环，它提供了项目信息与依赖管理等。</p><p>首先，pom.xml文件中，包含一般XML文件头，指定xml文件版本以及编码方式等；接下来是project元素，包含相关的命名空间以及xsd元素等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fei<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fei.empty.spring.web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jetty.port</span>&gt;</span>8417<span class="tag">&lt;/<span class="name">jetty.port</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.2.0.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j2.version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">log4j2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h4><p>接下来重要的是<code>groupId</code>、<code>artifactId</code>、<code>version</code>元素，分别表示组（当前Maven项目隶属的实际项目）、唯一ID、版本。这个是Maven的坐标元素，基本可以确定一个项目，当然这三项是必须的，不管是在项目信息还是在依赖管理中，还有<code>packaging</code>、<code>classifier</code>分别表示打包方式和帮助定义构建输出的一些附属构建（ <code>classifier</code>是不能直接定义的，附属构建不是项目直接默认生成的，而是由附加的插件帮助生成）。例如在本例中因为是Javaweb项目，所以使用war的打包方式，在项目中如果不做声明，默认的是jar打包方式。这5个元素可以唯一的确定项目。</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>关于版本，分为发布版本和快照版本，在本例中的<code>1.0-SNAPSHOT</code>就是快照版本，快照版本是不稳定的。在Maven中版本号的约定是&lt;主版本&gt;.&lt;次版本&gt;.&lt;增量版本&gt;-&lt;里程碑版本&gt;。关于版本管理的一些本文不会涉及。</p><p>在配置的pom文件中提供了properties标签自定义。利用这个我们将所有的版本号集中在一起，方便更新、引用，以及减少一些版本号重复性。</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>除了在项目信息中使用到了这些元素标签，还在依赖管理中使用，这是很必要的，需要用它们去确定一个Maven项目。在 <code>dependencies</code>里会有许多<code>dependency</code>来确定每个依赖。例如spring项目中一般会包含<code>spring-core</code>、<code>spring-context</code>、<code>spring-context-support</code>等都是Spring Framework实现依赖注入等功能必要的构建，都需要在项目中依赖。</p><p>在依赖的<code>servlet</code>中定义了scop标签，表示定义依赖的范围，那么provided是什么意思呢？在一般情况中，我们有6种依赖范围：1、compile：编译依赖范围，一般在缺省默认情况下也使用这个默认范围；2、test：测试依赖范围；3、provided：已提供依赖范围，表示对于编译和测试classpath有效，但是在运行的时候无效；4、runtime：运行时依赖范围，即测试和运行classpath有效；5、system：系统依赖范围，该依赖范围与三种classpath的关系与provided相同，但是在使用这个依赖范围时，必须通过systemPath元素显式地指定依赖文件的路径，在使用时会造成不可移植性；6、import：导入依赖范围，其实是继承父模版的依赖配置，继承依赖范围。</p><table><thead><tr><th style="text-align:center">依赖范围（scop）</th><th style="text-align:center">对于编译classpath有效</th><th style="text-align:center">对于测试classpath有效</th><th style="text-align:center">对于运行classpath有效</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">compile</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">spring-core</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">JUnit</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">-</td><td style="text-align:center">servlet-api</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center">-</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">JDBC驱动实现</td></tr><tr><td style="text-align:center">system</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">-</td></tr></tbody></table><p>类似于java的属性继承一样，Maven也具有传递性依赖，继承依赖范围关系如下，左一列为直接依赖，横一栏为间接依赖，内容表示最终依赖范围。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">compile</th><th style="text-align:center">test</th><th style="text-align:center">provided</th><th style="text-align:center">runtime</th></tr></thead><tbody><tr><td style="text-align:center">compile</td><td style="text-align:center">compile</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">runtime</td></tr><tr><td style="text-align:center">test</td><td style="text-align:center">test</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">test</td></tr><tr><td style="text-align:center">provided</td><td style="text-align:center">provided</td><td style="text-align:center">-</td><td style="text-align:center">provided</td><td style="text-align:center">provided</td></tr><tr><td style="text-align:center">runtime</td><td style="text-align:center">runtime</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">runtime</td></tr></tbody></table><p>这儿其实有一些规律：在间接依赖为compile时其他两者一致；当间接依赖为test时，不具有传递性；当间接依赖为provided时，只有provided才能传递，且最终依赖为provided；当间接依赖为runtime时，一般情况时直接依赖与最终依赖一致，除了直接依赖为compile时最终依赖为runtime。</p><p>既然有传递性依赖，以及继承等机制（这些会在后续讲到），并没有像Java一样限制只能单继承，那么必会出现像C++一样通过不同路径继承同意文件而产生冲突的情况，那么如何解决？Mave这儿需要依赖调解。第一原则是路径最近者优先；第二原则是第一声明者优先。</p><p>当然在依赖的时候，提供了optional标签来表示可选。可选依赖是不会传递的。也提供exclusions标签来排除继承时的某些依赖，可以解决在继承时快照版本依赖的不稳定性问题。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>在上文中讲到依赖，那么依赖后引入的包相对于其对应仓库中的路径应该是多少呢？在路径与坐标的大致对应关系为<code>groupId/artifactId/version/artifactId-version.packaging</code>。</p><p>对于Maven来说，仓库只分为两种：本地仓库和远程仓库。</p><p><img src="/2017/05/03/Maven基础总结/Maven仓库分类.png" alt="Maven仓库分类"></p><p>一般情况是当我们使用依赖去引入一种构建，当Maven根据坐标寻找构建时，先会去本地查找此构建，如果本地没有这个构建，去远程仓库查找，发现则下载到本地使用（当然本地构建需要查看更新时也是需要去远程仓库查找）。</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>一般在用户中本机中，默认情况下都有一个<code>.m2/repository/</code>的仓库目录。</p><p><img src="/2017/05/03/Maven基础总结/m2-repository.png" alt></p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>远程仓库分为中央仓库以及自己建立的私服等。一般情况下，基本每个公司都是有自己的Maven仓库的，在开发之前的环境配置时会加上一个自己公司的setting.xml文件的配置。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven拥有三套独立的生命周期，分别为clean、default、site。clean生命周期目标是清理项目；default是构建项目；而site生命周期目的是建立项目站点。</p><p>clean生命周期包括pre-clean、clean、post-clean。一般调用clean时会依次执行pre-clean、clean。一般命令都是执行到指定的阶段截止。</p><p>default是所有生命周期中最核心的部分。包括了许多阶段：calidate、initialize、generate-sources、process-sources、generate-resources、process-resources、compile、process-classes、generate-test-sources、process-test-sources、generate-test-resources、process-test-resources、test-compile、process-test-clasess、test、prepare-package、package、pre-integration-test、integration-test、post-integration-test、verify、install、deploy。在这个生命周期中可以看到有许多编译、测试等阶段。</p><p>而site生命周期有pre-site、site、post-site、site-deploy四个阶段。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>个人觉得Maven中插件是非常重要的一环，可以帮助我们完成一些任务，并且与生命周期中的某个阶段绑定。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>$&#123;web.port&#125;<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在这段代码中使用plugin标签加入了maven-compiler-plugin以及tomcat插件，可以使得项目可编译以及不用本地的tomcat服务器。compiler的插件是内置绑定的compile阶段，不用显式申明。当然也可以自定义绑定，在配置中加入executions、execution标签配置 执行一个任务，并用phase绑定生命周期。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>讲到插件，就不能跳过Maven的测试。测试也是使用插件来实现的，如maven-surefire-plugin插件。可以帮助我们单元测试、集成测试等。</p><h3 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h3><p>聚合特性能把项目的各个模块聚合在一起构建，而继承特性能帮助抽取各模块相同的依赖和插件等配置。</p><p>所有模块组成的一个构建结构就是反应堆。单模块项目就是这个模块本身；而多模块项目则包含了各模块之间的继承和依赖关系、计算合理构建顺序。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>本文中对于许多详细知识没有作总结，只是对于常用的一些部分作了浅入的涉及。如测试、聚合与继承、以及Nexus建私服、profile、站点等知识没有解释，需要学习的可以仔细看一下《Maven实战》。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">feiybox</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>