<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/f.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/f.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/f.png"><link rel="mask-icon" href="/images/f.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"feiybox.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="软件质量概述 高质量代码最终会让我们倍感轻松，无需付出更多，但是需要重新分配资源，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。 并非所有质量保证目标都可以同时实现。明确哪些目标是你希望达到的，并就这些目标与团队中的其他人员进行沟通。 没有任何一种缺陷检测技术能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划使用多种不同的技术来检测不同类型的错误。 可以在构建期间应"><meta property="og:type" content="article"><meta property="og:title" content="《代码大全》笔记 —— 模块五：代码改进"><meta property="og:url" content="https://feiybox.com/2024/05/20/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%94%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B/index.html"><meta property="og:site_name" content="feiybox"><meta property="og:description" content="软件质量概述 高质量代码最终会让我们倍感轻松，无需付出更多，但是需要重新分配资源，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。 并非所有质量保证目标都可以同时实现。明确哪些目标是你希望达到的，并就这些目标与团队中的其他人员进行沟通。 没有任何一种缺陷检测技术能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划使用多种不同的技术来检测不同类型的错误。 可以在构建期间应"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-05-20T13:22:00.000Z"><meta property="article:modified_time" content="2024-05-20T13:22:49.703Z"><meta property="article:author" content="feiybox"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://feiybox.com/2024/05/20/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%94%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://feiybox.com/2024/05/20/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%94%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B/","path":"2024/05/20/《代码大全》笔记-——-模块五：代码改进/","title":"《代码大全》笔记 —— 模块五：代码改进"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《代码大全》笔记 —— 模块五：代码改进 | feiybox</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">feiybox</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">DO MORE DO BETTER</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-projects"><a href="/projects/" rel="section"><i class="fa fa-sitemap fa-fw"></i>项目</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">软件质量概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">软件质量的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="nav-number">1.2.</span> <span class="nav-text">改进软件质量的技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E6%8A%80%E6%9C%AF%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%95%88%E8%83%BD"><span class="nav-number">1.3.</span> <span class="nav-text">质量保证技术的相对效能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81"><span class="nav-number">1.4.</span> <span class="nav-text">何时进行质量保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%99%AE%E9%81%8D%E5%8E%9F%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">软件质量的普遍原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E5%90%8C%E6%9E%84%E5%BB%BA"><span class="nav-number">2.</span> <span class="nav-text">协同构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">协同开发实践概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B"><span class="nav-number">2.2.</span> <span class="nav-text">结对编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E5%AE%A1%E6%9F%A5"><span class="nav-number">2.3.</span> <span class="nav-text">正式审查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.4.</span> <span class="nav-text">其他类型的协同开发实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%B5%8B%E8%AF%95"><span class="nav-number">3.</span> <span class="nav-text">开发人员测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%80%85%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">开发者测试对软件质量所起的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%B5%8B%E8%AF%95%E7%9A%84%E6%8E%A8%E8%8D%90%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">开发人员测试的推荐方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%B5%8B%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">3.3.</span> <span class="nav-text">一些测试技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="nav-number">3.4.</span> <span class="nav-text">典型错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%94%AF%E6%8C%81%E5%B7%A5%E5%85%B7"><span class="nav-number">3.5.</span> <span class="nav-text">测试支持工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%B5%8B%E8%AF%95"><span class="nav-number">3.6.</span> <span class="nav-text">改进测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">调试问题概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0%E7%BC%BA%E9%99%B7"><span class="nav-number">4.2.</span> <span class="nav-text">发现缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E7%BC%BA%E9%99%B7"><span class="nav-number">4.3.</span> <span class="nav-text">修复缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E4%B8%AD%E7%9A%84%E5%BF%83%E7%90%86%E5%9B%A0%E7%B4%A0"><span class="nav-number">4.4.</span> <span class="nav-text">调试中的心理因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%BA%9B%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81%E5%92%8C%E4%B8%8D%E5%A4%AA%E6%98%8E%E6%98%BE%E7%9A%84%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="nav-number">4.5.</span> <span class="nav-text">那些显而易见和不太明显的调试工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">重构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%BC%94%E5%8F%98%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">软件演变的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%9A%84%E7%90%86%E7%94%B1"><span class="nav-number">5.2.</span> <span class="nav-text">重构的理由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E7%9A%84%E9%87%8D%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">特定的重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E9%87%8D%E6%9E%84"><span class="nav-number">5.4.</span> <span class="nav-text">安全重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%AD%96%E7%95%A5"><span class="nav-number">5.5.</span> <span class="nav-text">重构策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">代码调优策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.</span> <span class="nav-text">性能概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98%E7%AE%80%E4%BB%8B"><span class="nav-number">6.2.</span> <span class="nav-text">代码调优简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E5%BC%8F%E5%90%84%E6%A0%B7%E7%9A%84%E8%87%83%E8%82%BF%E5%92%8C%E8%9C%9C%E7%B3%96"><span class="nav-number">6.3.</span> <span class="nav-text">各式各样的臃肿和蜜糖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%A6%E9%87%8F"><span class="nav-number">6.4.</span> <span class="nav-text">度量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E4%BC%98%E6%8A%80%E6%9C%AF"><span class="nav-number">7.</span> <span class="nav-text">代码调优技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91"><span class="nav-number">7.1.</span> <span class="nav-text">逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF"><span class="nav-number">7.2.</span> <span class="nav-text">循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%98%E6%8D%A2"><span class="nav-number">7.3.</span> <span class="nav-text">数据变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.4.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.5.</span> <span class="nav-text">子程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80%E9%87%8D%E6%96%B0%E7%BC%96%E7%A0%81"><span class="nav-number">7.6.</span> <span class="nav-text">用低级语言重新编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%BE%97%E8%B6%8A%E5%A4%9A%EF%BC%8C%E8%B6%8A%E4%B8%8D%E4%BC%9A%E6%9C%89%E5%A4%A7%E7%9A%84%E6%94%B9%E8%A7%82"><span class="nav-number">7.7.</span> <span class="nav-text">改得越多，越不会有大的改观</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">feiybox</p><div class="site-description" itemprop="description">青纸's Blog</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">99</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2024/05/20/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%94%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%94%B9%E8%BF%9B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="青纸's Blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《代码大全》笔记 —— 模块五：代码改进</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-05-20 21:22:00" itemprop="dateCreated datePublished" datetime="2024-05-20T21:22:00+08:00">2024-05-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="软件质量概述"><a href="#软件质量概述" class="headerlink" title="软件质量概述"></a>软件质量概述</h2><ul><li>高质量代码最终会让我们倍感轻松，无需付出更多，但是需要重新分配资源，以低廉的成本来防止缺陷出现，从而避免代价高昂的修正工作。</li><li>并非所有质量保证目标都可以同时实现。明确哪些目标是你希望达到的，并就这些目标与团队中的其他人员进行沟通。</li><li>没有任何一种缺陷检测技术能够解决全部问题，测试本身并不是排除错误的最有效方法。成功的质量保证计划使用多种不同的技术来检测不同类型的错误。</li><li>可以在构建期间应用有效的质量保证技术，并且在构建前采用许多同样强大的技术。越早找到缺陷，它与代码的其余部分就会越少纠缠在一起，造成的损害就越小。</li><li>软件领域的质量保证是面向过程的。软件开发与制造业不一样，在这里并不存在影响最终产品的重复阶段，因此最终产品的质量受控于开发软件时所采用的过程。</li></ul><h3 id="软件质量的特性"><a href="#软件质量的特性" class="headerlink" title="软件质量的特性"></a>软件质量的特性</h3><p>外部特性是软件产品的用户能够感知到的特性：正确性、易用性、效率、可靠性、完整性、适应性、精确性、健壮性。</p><p>质量的外部特性是用户惟一关心的软件特性。</p><p>内部质量特性：可维护性、灵活性、可移植性、可重用性、可读性、可测试性、可理解性。</p><p>一个无法从系统内部理解或者维护的软件，其缺陷也是难以修正的，进而影响到正确性和可靠性这两个外部特性。</p><p>要让所有特性都达到极致是不可能的。需要从一组互相竞争的目标中寻找最佳解决方案。</p><h3 id="改进软件质量的技术"><a href="#改进软件质量的技术" class="headerlink" title="改进软件质量的技术"></a>改进软件质量的技术</h3><p>软件质量保证是一项需要预先计划的、系统性的活动，其目标是确保系统具有人们所期望的特性。</p><p>需要设定明确的质量目标。</p><p>组织必须以实际行动向程序员表明 “质量第一” 的重要性。将质量保证工作明确下来，可以清楚地表明质量的优先程度。</p><p>开发人员使用 “质量关卡”，定期测试或评审，来确定产品在一个阶段的质量是否满足了要求。</p><p>度量质量特性本身：正确性、可用性，以及效率等。</p><h3 id="质量保证技术的相对效能"><a href="#质量保证技术的相对效能" class="headerlink" title="质量保证技术的相对效能"></a>质量保证技术的相对效能</h3><p>一个缺陷在系统中存在的时间越长，消除它的代价越高。</p><p>推荐的软件测试方案：</p><ol><li>对所有需求、所有架构以及系统关键部分的设计进行正式审查</li><li>建模或创建原型</li><li>代码阅读或审查</li><li>执行测试</li></ol><h3 id="何时进行质量保证"><a href="#何时进行质量保证" class="headerlink" title="何时进行质量保证"></a>何时进行质量保证</h3><p>任何一步都需保证质量，错误越早越痛苦。</p><h3 id="软件质量的普遍原理"><a href="#软件质量的普遍原理" class="headerlink" title="软件质量的普遍原理"></a>软件质量的普遍原理</h3><p>一次性把事情做对，才是提效的根本要义。</p><p>软件质量的普遍原理就是改进代码质量从而降低开发成本。</p><p>提高生产率和改进质量的最佳方法是减少花费在代码返工上的时间，无论返工是由需求变化、设计变更还是调试引起的。</p><p>缩短开发周期的最显著方法是改进产品质量，由此减少在调试和软件返工上所花费的时间。</p><p>开发前确定更多的细节问题，使开发更有确定性。才能进行提效。规范化也能提效。</p><p>与传统的 “编码 - 测试 - 调试” 周期相比，先进的软件质量计划可能更省钱。（不能陷入 “先开发再说”，越依赖测试越存在问题。）</p><h2 id="协同构建"><a href="#协同构建" class="headerlink" title="协同构建"></a>协同构建</h2><ul><li>相比测试，协同开发实践往往能发现更多的缺陷，并且更高效。</li><li>与测试相比，协同开发实践往往会发现不同类型的错误，这意味着需要同时使用评审和测试来保证软件的质量。</li><li>正式审查使用检查清单、准备工作、明确定义的角色和持续的过程改进，以最大限度地提高错误检测效率。正式审查发现的缺陷往往比走查更多。</li><li>结对编程的成本通常与审查大致相同，并产生类似质量的代码。当需要缩短开发周期时，结对编程尤其有价值。有些开发人员更喜欢结对工作而不是独自工作。</li><li>正式审查还可用于代码之外的很多工作成果上，比如需求、设计和测试用例。</li><li>走查和代码阅读是审查的替代方案。代码阅读在有效利用每个人的时间方面提供了更多的灵活性。</li></ul><p>所有的协同构建技术都试图通过这样或那样的途径，让你能够按照规范化的流程，向其他人展示自己的工作，及时把错误暴露出来。（类似小黄鸭调试法）</p><h3 id="协同开发实践概述"><a href="#协同开发实践概述" class="headerlink" title="协同开发实践概述"></a>协同开发实践概述</h3><p>“协同构建” 包括结对编程、正式审查、非正式技术评审、文档阅读以及其他能够让开发人员为创建代码和其他工作产品共同承担责任的技术。</p><p>协同构建是其他质量保证技术的补充：协同构建的首要目的是提高软件质量。（借助其它人协同来保证质量。）</p><p>自己管理的代码，一定要审查别人在此项目的更改。</p><p>即使高效地完成了测试，作为完备质量计划的一部分，评审或其他类型的协作同样很有必要。</p><p>协同构建能够培育公司文化并加强编程技能。（文化也是其中体现的一环）</p><p>集体所有制适用于所有形式的协同构建。（每个人都要对这部分代码进行负责，逐渐达成交叉覆盖）</p><p>在构建前后都应保持协作。协同构建的大多数见解也适用于评估、计划、需求、构建、测试和维护工作。</p><h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><p>两个人一同协作，完成某个项目，共同思考开发。老人带新人开发某个项目，也是一种结对编程。</p><p>结对编程的好处：</p><ol><li>与单独开发相比，结对能够使人们在压力之下保持更好的状态。结对编程鼓励彼此将代码质量保持在较高水平，即使是在需要快速写代码以至于轻视代码整洁的压力之下。</li><li>它能够提升代码质量。代码的可读性和可理解性往往可以提高到团队中最优秀程序员的水平。</li><li>它能够缩短进度时间表。结对编程的速度更快，错误也更少，这样，项目团队在项目后期花费更少的时间来修正缺陷。</li><li>它还具有协同构建的其他所有常见好处，包括传播企业文化、指导初级程序员和培养集体所有权意识。</li></ol><h3 id="正式审查"><a href="#正式审查" class="headerlink" title="正式审查"></a>正式审查</h3><p>代码与项目串讲审查（核心代码一定要经过审查）：</p><ul><li>检查清单将评审人员的注意力聚焦于过去有问题的地方。</li><li>审查的重点是缺陷检测，而不是修正。</li><li>评审人员提前为审查会议做准备，并将发现的问题列出来带到会议中。</li><li>为所有参与者分配清晰的角色。</li><li>审查会议的主持人不是待审查工作产品的作者。</li><li>审查会议的主持人在主持审查方面接受过具体培训。</li><li>只有在与会者都做好充分准备后，才可以举行审查会议。</li><li>每次审查时都要收集数据，并将这些数据应用于未来的审查会议中，以改进这些会议。</li><li>高层管理人员不参加审查会议，除非是审查项目计划或其他管理材料。但技术负责人可能要出席。</li></ul><p>设计审查和代码审查的结合通常可以消除产品中 70%～85% 或更多的缺陷。</p><p>传统的建议是将审查限制在六个人左右。</p><p>审查会议：</p><ol><li>主持人可能会通过摇铃来引起大家的注意。（不能太发散了，效率不能太低）</li><li>会议期间不要讨论解决方案。小组应集中精力识别缺陷。</li><li>会议一般不宜超过两个小时。</li></ol><p>注意事情（即代码）本身，而不是谁做的。注意审查目的是提高质量。（不是去争论谁对谁错。审查当然也绝不是批评设计或代码的作者。）</p><p>关注人心，同理心，团队文化。</p><p>作者应该认可每一个疑似的缺陷并让审查继续下去。不要试图为正在接受评审的工作辩护。独立思考收到的每一条评论，并判断它们是否在理。（提高会议效率）</p><h3 id="其他类型的协同开发实践"><a href="#其他类型的协同开发实践" class="headerlink" title="其他类型的协同开发实践"></a>其他类型的协同开发实践</h3><p>走查是一种非正式的审查，效果类似，更聚焦于核心一点。</p><p>公开演示的目的是向客户阐明项目进展顺利，这是管理评审而不是技术评审。</p><h2 id="开发人员测试"><a href="#开发人员测试" class="headerlink" title="开发人员测试"></a>开发人员测试</h2><ul><li>开发人员测试是构成项目完整测试策略的关键部分。（独立测试也很重要）</li><li>在写代码之前编写测试用例与在写代码之后编写测试用例所花费的时间和精力是一样的，但是先编写测试用例缩短了 “缺陷 - 检测 - 调试 - 修正” 的周期。</li><li>即使考虑到多种可用的测试方法，测试只是一个优秀的软件质量保证项目的一部分。高质量的开发方法还包括尽可能减少需求和设计中出现的缺陷，这些活动的重要性并不亚于测试。协同开发实践在检测错误方面和测试的效率至少达到同一水平，而且各种实践可以检测出的错误类型也各不相同。</li><li>通过使用基础测试、数据流分析、边界分析、不良数据类别和良好数据类别等多种方法，可以确定生成许多测试用例。还可以通过错误猜测方法来生成更多的测试用例。</li><li>错误往往聚焦在少数容易出错的类和子程序中。找到最容易出错的代码片段，重新设计，并重写这些代码。</li><li>测试数据中包含的错误往往比被测试代码中的错误更密集。查找此类错误往往会浪费很多时间，也不能提升代码质量，所以测试数据的错误常常比编程错误更令人头疼。要想避免这种错误，请务必像开发代码一样谨慎开发测试用例。</li><li>自动化测试通常是非常有用的，并且它对于回归测试也是必不可少的。</li><li>从长远来看，改进测试过程的最好方法是使之规范化，对它进行度量，并利用所学到的知识来对这个过程进行改进。</li></ul><ol><li>单元测试：是指对一名程序员或一个开发团队所编写的一个完整的类、子程序或小程序所执行的测试，是独立于更完整的系统进行测试。</li><li>组件测试：是指对多名程序员或多个开发团队共同编写的一个类、包、小程序或者其他程序元素执行的测试，是独立于更完整的系统进行测试。</li><li>集成测试：是指对多名程序员或多个开发团队共同编写的两个或多个类、包、组件或子系统的执行的组合测试。这种类型的测试通常是在编写完两个类之后就开始测试，并一直持续到整个系统完成开发。</li><li>回归测试：是指重复先前执行的测试用例，软件曾经做过这些测试，目的是用同一组测试在当前软件中查找缺陷。</li><li>系统测试：是指软件在最终配置环境中执行的测试，包括与其他软硬件系统的集成。它会查找安全性、性能、资源消耗、时序问题和其他在较低集成级别上无法进行测试的问题。</li></ol><p>测试通常分为两大类：黑盒测试和白盒测试。“黑盒测试” 是指测试者在无法获知所测试程序的内部工作原理的情况下所执行的测试。“白盒测试” 是指测试者在了解测试程序的内部工作原理情况下所执行的测试。</p><p>测试时检测错误的一种手段。而调试时针对已经检测到的错误的根本原因进行诊断和修正的一种手段。</p><h3 id="开发者测试对软件质量所起的作用"><a href="#开发者测试对软件质量所起的作用" class="headerlink" title="开发者测试对软件质量所起的作用"></a>开发者测试对软件质量所起的作用</h3><p>测试本身并不能直接提高软件质量。测试结果时衡量质量的一个指标，但就其本身而言，这些指标并不能提高软件质量。</p><p>「自测 + 联调 + 测试」总时间为项目总时间的 50%。</p><p>随着项目规则的增加，在总开发时间中，开发人员花在测试的百分比越来越小。</p><p>不管采取哪种集成或系统测试策略，都应该在将每个代码单元与任何其他代码单元合并之前彻底地对它们进行测试。</p><h3 id="开发人员测试的推荐方法"><a href="#开发人员测试的推荐方法" class="headerlink" title="开发人员测试的推荐方法"></a>开发人员测试的推荐方法</h3><p>单靠开发人员测试不足够保证质量。</p><h3 id="一些测试技巧"><a href="#一些测试技巧" class="headerlink" title="一些测试技巧"></a>一些测试技巧</h3><p>从使用角度而言，测试的艺术性就在于挑选最可能发现错误的测试用例。</p><p>结构化基础测试：核心思想是需要对程序中的每条语句至少进行一次测试。开发出最小数量的测试用例集合去保证遍历过程中每条逻辑路径。</p><p>分支覆盖：确保每个为 “真” 的逻辑分支至少有一个测试用例，而每个为 “假” 的分支也至少有一个测试用例进行覆盖。</p><p>兼容性测试：测试与旧数据的兼容性，版本之间的这种连续性是回归测试的基础。</p><h3 id="典型错误"><a href="#典型错误" class="headerlink" title="典型错误"></a>典型错误</h3><p>无论项目规模大小，代码构建缺陷至少占据所有缺陷的 35%。</p><p>业内经验是，平均每 1000 行交付软件的代码中有 1-25 个错误。</p><p><strong>软件质量的通用原则：构建高质量的软件比构建和修复低质量的软件成本更低。</strong></p><p>测试用例与被测试的代码包含错误的机会是均等的。</p><p>在开发软件时也要规划测试用例。</p><h3 id="测试支持工具"><a href="#测试支持工具" class="headerlink" title="测试支持工具"></a>测试支持工具</h3><p>Diff 工具：自动化工具来对比预期输出和实际输出。</p><p>覆盖率监测：对已测试的代码和未测试的代码进行追踪。</p><h3 id="改进测试"><a href="#改进测试" class="headerlink" title="改进测试"></a>改进测试</h3><p>管理回归测试的惟一现实方式是将其自动化。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>调试是软件开发成败的一个重要方面。最好的方法是使用本书中描述的其他技术来避免缺陷。但是，提高调试技能仍然是值得的，因为好的调试技能相比差的调试技能至少有 10 倍的差异。</li><li>找到并纠正错误的系统方法是成功的关键。专注调试，每次测试都能让你向前迈出一步。使用测试的调试方法。</li><li>在修复程序之前先了解根本问题。对错误根源的随机猜测和随机修正，都将使程序处于更糟糕的状态。</li><li>将编译器告警设置为最挑剔的级别，并修复其报告的错误。如果忽略了明显的错误，就很难修复不易察觉的错误。</li><li>调试工具是软件开发的强大辅助工具。找到它们并利用它们，记住，宫廷式要勤于思考。</li></ul><p>调试时识别错误的根本原因以及纠正它的过程。</p><h3 id="调试问题概述"><a href="#调试问题概述" class="headerlink" title="调试问题概述"></a>调试问题概述</h3><p>与测试一样，调试本身并不是提高软件质量的方法，而是一种判断缺陷的方法。</p><p>从代码阅读者的角度理解代码质量：批评性审视代码质量。</p><p>靠猜测来发现缺陷：大胆假设，小心求证。</p><h3 id="发现缺陷"><a href="#发现缺陷" class="headerlink" title="发现缺陷"></a>发现缺陷</h3><p>发现缺陷的第一步类似于科学方法的第一步，它依赖于可重复性。</p><p>错误通常是由各种因素组合而成的，仅用一个测试用例来诊断问题通常无法诊断到根本问题。</p><p>以前有缺陷的类和子程序值得怀疑：以前有缺陷的类可能会继续有缺陷。</p><p>发现问题较难时，先放下问题，休息一下。</p><p>暴力调试：为快而糙的调试设置最大时间。（避免赌徒心理）</p><h3 id="修复缺陷"><a href="#修复缺陷" class="headerlink" title="修复缺陷"></a>修复缺陷</h3><ul><li>在修复前先理解问题：先理解问题，再修复问题。</li><li>理解程序，而不仅仅是问题：理解问题，并理解上下文。</li><li>确认缺陷诊断结论</li><li>放松：不要过于紧张。</li><li>保持原始代码</li><li>修复问题，而不是症状：尽可能减少修复而对代码不改变较大。</li><li>仅在有充分理由的情况下修改代码：改变代码需要谨慎。</li><li>一次只改一次</li><li>检查修复的程序</li><li>添加一个暴露缺陷的单元测试</li><li>寻找类似的缺陷：当发现一个缺陷时，寻找其他类似的缺陷。</li></ul><h3 id="调试中的心理因素"><a href="#调试中的心理因素" class="headerlink" title="调试中的心理因素"></a>调试中的心理因素</h3><p>良好的格式、注释、变量名、子程序名和其他编程风格元素有助于构筑编程环境，从而使可能的缺陷无所遁行。</p><h3 id="那些显而易见和不太明显的调试工具"><a href="#那些显而易见和不太明显的调试工具" class="headerlink" title="那些显而易见和不太明显的调试工具"></a>那些显而易见和不太明显的调试工具</h3><p>注意所有的告警：</p><ul><li>将编译器的告警级别设置为可能的最高、最挑剔的级别并修复它报告的错误</li><li>将告警视为错误</li><li>设置项目范围的编译时选项标准：设置一个标准，要求团队中的每个人使用相同的编译器设置编译代码。</li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li>无论是在最初的开发过程中还是在最初的发布之后，程序的变化都是生命中要接受的现实。</li><li>软件在变化过程中，要么改进，要么退化。软件进化的基本规则是：进化应该提高程序的内部质量。软件进化的基本规则是，内部质量应随着代码的进化而提高。</li><li>成功重构的一个关键是学会注意许多表明需要重构的警告信号（或称 “臭味”）。</li><li>成功重构的另一个关键是掌握多种特定的重构方法。</li><li>最后一个成功的关键是要有一个安全重构策略。有的重构方法比其他方法更好。</li><li>为了在一开始就把事情做好，开发过程中的重构是你改进程序的最佳机会。在开发过程中，要充分利用好这些机会！</li></ul><p>现实不会那么理想。（不要想着一切皆理想）</p><h3 id="软件演变的类型"><a href="#软件演变的类型" class="headerlink" title="软件演变的类型"></a>软件演变的类型</h3><p>更可能优化：无论是刚开始写代码，还是之后进行修改，都要注意方便以后进一步的改动。</p><p>软件演变的基本规则是，内部质量应随代码的演变而提高。（不能再次腐化）</p><h3 id="重构的理由"><a href="#重构的理由" class="headerlink" title="重构的理由"></a>重构的理由</h3><ol><li>代码发生重复</li><li>子程序太长</li><li>循环太长或嵌套太深</li><li>类的内聚力很差</li><li>类的接口不能提供一致的抽象层级</li><li>参数表有太多参数</li><li>在类中进行的修改各自独立</li><li>必须并行修改多个类</li><li>必须并行修改继承层次结构</li><li>必须并行修改 case 语句</li><li>一起使用的相关数据项没有被组织成类</li><li>一个子程序使用了另一个类（而非它自己的类）更多的特性</li><li>无脑使用基本数据类型</li><li>类的最用不大</li><li>子程序链传递流浪数据</li><li>中间对象不做任何事情</li><li>一个类与另一个类过于亲密</li><li>某个子程序的名字太差劲</li><li>公共数据成员</li><li>一个子类只使用了其父类的一小部分子程序：考虑将子类与超类的关系从 is-a 关系转换为 has-a 关系来实现更好的封装。</li><li>用注释解释难以理解的代码</li><li>全局变量的使用</li><li>程序中包含的代码似乎有一天会用得着（避免过度设计）</li></ol><h3 id="特定的重构"><a href="#特定的重构" class="headerlink" title="特定的重构"></a>特定的重构</h3><ul><li>数据级重构</li><li>语句级重构</li><li>子程序级重构</li><li>类实现重构</li><li>类接口重构</li><li>系统级重构</li></ul><h3 id="安全重构"><a href="#安全重构" class="headerlink" title="安全重构"></a>安全重构</h3><p>降低重构的范围：若重构风险较大，则需谨慎行事。一次只进行一个重构。</p><h3 id="重构策略"><a href="#重构策略" class="headerlink" title="重构策略"></a>重构策略</h3><ul><li>添加子程序时重构</li><li>添加类时重构</li><li>修复缺陷时重构</li><li>瞄准容易出错的模块</li><li>瞄准高复杂度的模块</li><li>在维护环境中，改进你所接触的部分</li><li>在干净的代码和丑陋的代码之间定义一个接口，再通过接口移动代码</li></ul><h2 id="代码调优策略"><a href="#代码调优策略" class="headerlink" title="代码调优策略"></a>代码调优策略</h2><ul><li>性能仅仅是软件整体质量的一个方面，通常并不是最重要的。精细的代码调优也仅仅是整体性能的一个方面，通常也不是最紧要的。相对于代码本身的效率，程序的架构设计、详细设计以及数据结构和算法选择对程序的执行速度和规模通常有更大的影响。</li><li>量化评估是实现最大化性能的关键要素。量化评估需要找到能够真正决定程序性能提升的部分，在优化之后，需要通过再次度量来验证该优化是提升了软件的性能而不是降低了其性能。</li><li>绝大多数程序都有一小部分代码耗费了绝大部分的运行时间。在度量之前，无法知道是哪部分代码。</li><li>代码调优通常需要多次迭代才能获得理想的性能提升。</li><li>要想在最初的编码阶段为性能优化工作做好充分的准备，最佳方式是写出易于理解和修改的整洁代码。</li></ul><h3 id="性能概述"><a href="#性能概述" class="headerlink" title="性能概述"></a>性能概述</h3><p>代码调优是提升程序性能的一种方式。</p><p>性能与代码速度只有松散的关系。在代码速度上下了太大功夫，就没有精力在其他质量特性上下功夫。</p><p>设定单独的资源目标，使得系统最终的性能可以预测。</p><p>模块化设计（可插拔）：基于一个高度模块化、可修改的设计，可以很容易地将效率较低的部件换成效率较高的。</p><p>“调优” 指的是小规模修改，它影响单个类，影响单个子程序，或者更常见的影响几行代码。“调优” 并不是指大规模设计改动或其他更高层次的性能改进手段。</p><h3 id="代码调优简介"><a href="#代码调优简介" class="headerlink" title="代码调优简介"></a>代码调优简介</h3><p>帕累托法则也称 80/20 法则、关键少数法则或八二法则。一个程序 20% 的子程序消耗了 80% 的执行时间。</p><p><strong>别因强求最优而使好事难成。</strong></p><p>代码行数与速度并不相关。</p><p>一叶障目的情况：</p><ul><li>几乎不可能在程序完全跑起来之前确定性能瓶颈</li><li>即使在极少数情况下开发人员正确识别出了瓶颈，他们也会过犹不及地对待这个瓶颈，以至于顾此失彼</li><li>在初始开发过程中专注于优化，又碍于完成其他的程序目标。（过早优化的主要缺点在于视角有限。）</li></ul><p><strong>正确的程序重要于其它。</strong>（跑得慢不是最大的问题，不正确才是最大的问题。）</p><p>现代编译器的优化可能比你预期的更强大。</p><h3 id="各式各样的臃肿和蜜糖"><a href="#各式各样的臃肿和蜜糖" class="headerlink" title="各式各样的臃肿和蜜糖"></a>各式各样的臃肿和蜜糖</h3><p>I/O，网络与磁盘都是性能较低的。</p><p>解释型语言往往存在严重的性能惩罚，因其必须在创建和执行及其密码之前处理每条编程语言指令。</p><p>性能问题的最后一个来源是代码中的错误。错误包括启用调试代码（例如将跟踪信息记录到文件中）、忘记释放内存、不正确地设计数据库表、轮询不存在的设备直至超时等。</p><p>为常用的表定义索引不是优化，而是一个好的编程实践。</p><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>性能的度多方面都是反直觉的。性能需要度量，而不是依靠直觉。</p><p>性能度量需要精确。不能感性地提出性能优化。</p><h2 id="代码调优技术"><a href="#代码调优技术" class="headerlink" title="代码调优技术"></a>代码调优技术</h2><ul><li>优化结果在不同编程语言、编译器和环境中存在显著差异。不对每次特定的优化进行度量，这无法确定优化对程序到底是提升还是损害。</li><li>第一次优化通常并不是最好的。即使找到了好的，也要继续寻找更好的。</li><li>代码调优有点像核能，是一个争议性的、情绪化的主体。有的人认为这对可靠性和可维护性非常不利，所以根本不会去做。另一些人则认为，只要有适当的保障措施，它还是有益的。</li></ul><p>代码调优指的是小幅改变，而不是对设计的大幅改变。（大的改变只能叫重构了）</p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><ul><li>知道答案后就停止测试：短路求值</li><li>按频率调整测试顺序：最常见的情况放在前面。（不要盲目遵循任何优化建议的重要性，特定的编译器实现对结果有显著影响。）</li><li>相似逻辑结构之间的性能比较</li><li>采用查询表替代复杂的表达式</li><li>使用惰性求值</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环合并或融合是指对操作相同元素集合的两个循环进行合并。两个循环变成一个，自然减少了循环的开销。</p><p>高效的循环，一个关键是循环内部的工作最小化。如果能在循环外部求值一个语句或语句的一部分，在循环内部只使用结果，就应该将这些计算放在循环外部。</p><p><strong>最忙的循环放在最外层。</strong></p><p>降低强度意味着用更便宜的操作取代昂贵的操作。</p><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><p>尽量减少数组访问。重复使用数组中一个元素的循环就是很好的优化对象。</p><p>使用辅助索引是指添加相关数据，以更高效的方式实现对某种数据类型的访问。</p><p>如果数据类型中的数据项过于庞大很难移动，那么对索引进行排序和搜索要比直接操作数据更快。</p><p>缓存是指将一些值按照某种方式存储起来，使最常用的值比不太常用的数值更容易被检索到。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>可以采用带书恒等式，以开销低的运算来替代开销大的运算。</p><p>一个常见的底层设计决策时从两种方案中选择一个：是动态计算结果，还是计算一次并保存结果，并在需要时查找。</p><p>如果发现某个表达式在代码中重复出现，就将其赋值给一个变量，然后需在需要时引用该变量，而不是在多个位置重新计算该表达式。</p><h3 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h3><p>代码调优最强大的工具之一是好的子程序分解。小的、定义明确的子程序可以节省空间，因其避免了将相同的代码分散于多处。（使得优化范围更小）</p><h3 id="用低级语言重新编码"><a href="#用低级语言重新编码" class="headerlink" title="用低级语言重新编码"></a>用低级语言重新编码</h3><p>遇到性能瓶颈时，应该用低级语言重新编码。</p><h3 id="改得越多，越不会有大的改观"><a href="#改得越多，越不会有大的改观" class="headerlink" title="改得越多，越不会有大的改观"></a>改得越多，越不会有大的改观</h3><p>代码调优无一例外都涉及对以下两个方面的权衡：一方面是复杂性、可读性、简单性和可维护性；另一方面是对提高性能的渴望。（设计系统本身也是权衡）</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/05/19/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%9B%9B%EF%BC%9A%E8%AF%AD%E5%8F%A5/" rel="prev" title="《代码大全》笔记 —— 模块四：语句"><i class="fa fa-chevron-left"></i> 《代码大全》笔记 —— 模块四：语句</a></div><div class="post-nav-item"><a href="/2024/06/03/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E5%85%AD%EF%BC%9A%E7%B3%BB%E7%BB%9F%E5%8C%96%E8%80%83%E8%99%91/" rel="next" title="《代码大全》笔记 —— 模块六：系统化考虑">《代码大全》笔记 —— 模块六：系统化考虑 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">feiybox</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">256k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">5:20</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"feiybox","repo":"blog-comment","client_id":"bac26585ffb434df6c23","client_secret":"bfdc72e6a069abd8afd62b3ad0abf5e6c662db78","admin_user":"feiybox","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"2fd509059de0ecf898d5179ff8465334"}</script><script src="/js/third-party/comments/gitalk.js"></script></body></html>