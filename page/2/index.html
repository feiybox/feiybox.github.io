<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/f.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/f.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/f.png"><link rel="mask-icon" href="/images/f.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"feiybox.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="小浊微清的博客"><meta property="og:type" content="website"><meta property="og:title" content="feiybox"><meta property="og:url" content="https://feiybox.com/page/2/index.html"><meta property="og:site_name" content="feiybox"><meta property="og:description" content="小浊微清的博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="feiybox"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://feiybox.com/page/2/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>feiybox</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?f51cc75dfef0ebc64f14af202ba27866"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">feiybox</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">DO MORE DO BETTER</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-projects"><a href="/projects/" rel="section"><i class="fa fa-sitemap fa-fw"></i>项目</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="feiybox" src="/images/head.png"><p class="site-author-name" itemprop="name">feiybox</p><div class="site-description" itemprop="description">小浊微清的博客</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/12/31/2020%EF%BC%9A%E9%97%B4%E6%AD%87%E6%80%A7%E8%B8%8C%E8%BA%87%E6%BB%A1%E5%BF%97%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%80%A7%E6%B7%B7%E5%90%83%E7%AD%89%E6%AD%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/12/31/2020%EF%BC%9A%E9%97%B4%E6%AD%87%E6%80%A7%E8%B8%8C%E8%BA%87%E6%BB%A1%E5%BF%97%EF%BC%8C%E6%8C%81%E7%BB%AD%E6%80%A7%E6%B7%B7%E5%90%83%E7%AD%89%E6%AD%BB/" class="post-title-link" itemprop="url">2020：间歇性踌躇满志，持续性混吃等死</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-31 22:17 / 修改时间：22:36" itemprop="dateCreated datePublished" datetime="2020-12-31T22:17:00+08:00">2020-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>年初的时候，我给了今年的目标：</p><blockquote><ul><li>书13 增加认知，科学方面，减少文学</li><li>偏向底层（计算机系统，数据库）</li><li>leetcode刷题24（保持思维活跃）</li><li>课程12（mooc对其他方向及事物了解）</li></ul></blockquote><p>回头来看这一年完成了多少。</p><p><img src="/2020/12/31/2020：间歇性踌躇满志，持续性混吃等死/2020.png" alt></p><p>首先读书上，方向变了，不再读文学方向的书了，开始朝着科学的方向开始学习，不再看小说类的书。这一年离读书的目标还有点遥远，只读完成了两本书。第一本是《数据库系统概念》，写了<a href="https://feiybox.com/2020/11/25/【笔记】数据库系统概念/">笔记</a>，这本书基本快跨度一年的周期，但目前还未对该方向形成更加系统的总结，还没有形成深刻刻入到我骨肉的东西。</p><p>在leetcode上，这一年做了18道题，整体上符合预期，达到了活跃思维的目的了。</p><p>课程上，这一年基本没有在这个方向上发力，或者说这一年也太懒了。这个方向目的也是为了看书的弥补和总结。最终都是为了形成自己的思维。</p><p>这一年，写了7篇博客，博客主页：<a href="https://feiybox.com">https://feiybox.com</a>。这一年相比较上一年，产出降低了，当然在思考和总结方面也有更多的收获，开始思考不仅仅做技术的事情，开始考虑一些做业务的事情，学会怎么做一个事情。</p><p>这一年，我遇到了相知人，和小伍在一起了（手动撒花）。</p><p><img src="/2020/12/31/2020：间歇性踌躇满志，持续性混吃等死/you_and_me.png" alt></p><p>这一年，我依然在某个方向上的沉淀不够，需要多沉淀和总结，对自己看过的，遇到的，以及做过的，不管是业务还是技术，多总结思考。</p><p>这一年也开始思考，我想成为一个生命样的人，我想成为一个有趣的人，有一个有趣的灵魂。有丰富的见闻，有独立的主见，也有同理心。</p><p>这一年，经历了疫情，我还活着。这一年，我来北京三周年了，我还活着。这一年，就这么过了，没有煽情，有点平淡，也有惊喜。</p><p>总结来说：</p><blockquote><p>我还活着。</p><p>间断性踌躇满志，持续性混吃等死。</p><p>and 有你真好（手动撒花）。</p></blockquote><p><img src="/2020/12/31/2020：间歇性踌躇满志，持续性混吃等死/2021.jpeg" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/12/27/%E7%A4%BE%E5%8C%BA%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/12/27/%E7%A4%BE%E5%8C%BA%E4%BA%A7%E5%93%81%E6%80%9D%E8%80%83/" class="post-title-link" itemprop="url">社区产品思考</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-27 23:33 / 修改时间：23:35" itemprop="dateCreated datePublished" datetime="2020-12-27T23:33:00+08:00">2020-12-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/pro-exp/" itemprop="url" rel="index"><span itemprop="name">pro-exp</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>任何一个产品，都需要想着几个问题：</p><ul><li>产品的使命和价值观</li><li>用户可以在我们产品得到什么，即我们可以为用户提供什么样的服务</li><li>建立用户信任</li></ul><p>社区也是这样，需要考虑我们的使命和价值观，也需要考虑我们可以为用户提供什么样的服务，同时也需要让用户建立对产品的长期信任。</p><h3 id="什么是社区？"><a href="#什么是社区？" class="headerlink" title="什么是社区？"></a>什么是社区？</h3><p>以某种介质为交流载体，可沉淀社交关系的产品形态，就是广义的社区。社区也是一种社交，只不过是弱社交的一种产品形态。</p><blockquote><ul><li>弱社交：用户间没有太强的社交关系，用户井入这样的社区更多是获取内容。这样的社区更多以内容取胜，因此应该着重关注内容产生情况（发贴量），以及原创内容的情况。</li><li>强社交：用户间由于存在较强的社交关系，用户进入这样社区更不是获取其社交关系网动态。因此这样的社区应该更关注用户间的互动数据（互踩，互留评论），这反应用户间社交关系亲密度。</li><li>社区产品：用户目的就是为了消费这些内容，来满足自身的需求。与内容建立联系是主线，而与人建立联系是副线（即使想去建立联系但也可能很难实现）</li><li>社交产品：注重的是用户属性，所有内容都是为了用户属性，并不是为了消费这些内容，只是借由这些更好地去了解特定的人，与特定的人建立联系。与人建立联系是主线，内容是副线。</li></ul></blockquote><p>从上述可以看出，社区的两大要素是人与内容，最优形态也是和社交产品一样形成社交网络（比如关注网络等）。社区的基石是文化、角色、内容，社区的定位决定了社区的文化，而社区的文化影响社区角色的行为以及它们所产生和消费的内容，而内容作为文化的载体吸引着认同社区文化的用户进入社区。</p><h3 id="为什么要做社区？"><a href="#为什么要做社区？" class="headerlink" title="为什么要做社区？"></a>为什么要做社区？</h3><p>人都拥有社交、尊重和自我实现的需求。</p><h3 id="什么样的社区是好的社区？"><a href="#什么样的社区是好的社区？" class="headerlink" title="什么样的社区是好的社区？"></a>什么样的社区是好的社区？</h3><p>有归属感的社区就是好的社区。用户可以在社区上构建出自己的圈子，形成自己的交际圈子。归属感会带来用户忠诚度和粘性，是一个优秀社区的核心竞争力。</p><p>归属感可以拆分成以下几件事情：</p><ol><li>社区的使命愿景价值观</li><li>安全和可信赖的社区环境</li><li>社会资本在用户之间产生。用户之间相互作用，会沉淀社交关系，才会产生社会资本。产生的社会资本越来越多，对社区的归属感就越强。</li><li>有属于自己社区的故事。互联网有很多梗、热词、草根火起来，一般都是出自某个社区，然后在全网流传，这就是属于自己社区的故事。（爆款的本质就是社区的一个故事在全网范围的传播，可能是运营包装策划的，也可能是网友自发传播。）</li></ol><h3 id="怎么做好的社区？"><a href="#怎么做好的社区？" class="headerlink" title="怎么做好的社区？"></a>怎么做好的社区？</h3><p>文化：</p><ul><li>让团队来建立强有力的社区明文化</li><li>让用户来养成社区的暗文化</li></ul><p>角色：</p><ul><li>为生产者提供工具，为消费者提供内容（为用户提供<strong>服务</strong>，细节）</li><li>注重KOL，更注重KOC</li><li>打造角色等级体系的上升通道</li></ul><p>内容：</p><ul><li>注重没有时效性的内容</li><li>做好内容分类，明确内容主题</li><li>内容生产（内容搬运，官方生产，活动引导）</li><li>内容筛选与内容价值合理排序</li><li>以合适的方式进行分发</li></ul><blockquote><p><strong>社区可能突围的创新方向有两个</strong>：</p><ol><li>极低成本获取特定兴趣用户的能力</li><li>全新的信息载体格式</li></ol></blockquote><h3 id="做社区中有什么常规的操作？"><a href="#做社区中有什么常规的操作？" class="headerlink" title="做社区中有什么常规的操作？"></a>做社区中有什么常规的操作？</h3><p>构建圈子、话题、活动等方式引导用户发内容、推广大v内容活动等。构建用户画像，构建内容特征，为用户群体提供个性化内容。</p><h3 id="变现"><a href="#变现" class="headerlink" title="变现"></a>变现</h3><p>注重一点，任何产品留下用户，都是因为用户对该产品的信任，因此变现方式需要能对得起用户的信任。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/12/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/12/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">字符串匹配算法</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-12-07 00:31" itemprop="dateCreated datePublished" datetime="2020-12-07T00:31:00+08:00">2020-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-19 15:50" itemprop="dateModified" datetime="2020-12-19T15:50:25+08:00">2020-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>字符串匹配：本身是指在一个字符串中找到另一个字符串，可以暴力的方式按照字符来进行匹配。优化匹配的效率的方向是：减少不成功的匹配次数，比如KMP、BM等优化策略都是如此，通过某种方式，或者某种规则来加速匹配过程。</p><h3 id="BF算法（暴力算法）"><a href="#BF算法（暴力算法）" class="headerlink" title="BF算法（暴力算法）"></a>BF算法（暴力算法）</h3><p>普通模式的匹配算法：两个循环嵌套进行匹配，直到匹配成功。</p><p>Golang语法下可以截取字符串进行比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Golang语法字符串截取优化</span><br><span class="line">func MatchUseGo(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line">	for i := 0; i &lt;= len(strArr)-len(targetArr); i++ &#123;</span><br><span class="line">		if target == string(strArr[i:i+len(targetArr)]) &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// BF算法：暴力算法</span><br><span class="line">func MatchBF(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line">	for i := 0; i &lt;= len(strArr)-len(targetArr); i++ &#123;</span><br><span class="line">		match := true</span><br><span class="line">		if target == string(strArr[i:len(targetArr)]) &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">		for j := 0; j &lt; len(targetArr); j++ &#123;</span><br><span class="line">			if strArr[i+j] != targetArr[j] &#123;</span><br><span class="line">				match = false</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if match &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RK算法（基于BF算法的改进）"><a href="#RK算法（基于BF算法的改进）" class="headerlink" title="RK算法（基于BF算法的改进）"></a>RK算法（基于BF算法的改进）</h3><p>核心思想是哈希，即在详细比较之前，先使用hash进行比较，如果不匹配则右移。如果匹配，由于hash值可能存在碰撞的情况，因此需要进行详细判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// RK算法：使用hash匹配匹配进行优化</span><br><span class="line">func MatchRK(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line">	for i := 0; i &lt;= len(strArr)-len(targetArr); i++ &#123;</span><br><span class="line">		// 使用字符串的hash进行匹配，如果一致再进行详细匹配</span><br><span class="line">		if md5.Sum([]byte(string(strArr[i:i+len(targetArr)]))) != md5.Sum([]byte(target)) &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		match := true</span><br><span class="line">		for j := 0; j &lt; len(targetArr); j++ &#123;</span><br><span class="line">			if strArr[i+j] != targetArr[j] &#123;</span><br><span class="line">				match = false</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if match &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>关键在于部分匹配表（RMT表）：字符串起始位置到当前位置的字符串，“前缀”和“后缀”的最长的共有元素长度。</p><p><code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>。</p><p>部分匹配表代表：模式串中某个位置匹配失败的时候，可以直接转到某个位置开始重新开始匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// KMP算法：部分匹配表，在匹配失败时，可以跳过部分字符匹配</span><br><span class="line">func MatchKMP(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line"></span><br><span class="line">	// 构建部分匹配表（RMT表）</span><br><span class="line">	targetRMT := make([]int, len(targetArr))</span><br><span class="line">	k := -1</span><br><span class="line">	targetRMT[0] = -1</span><br><span class="line">	for i := 0; i &lt; len(targetRMT) - 1; &#123;</span><br><span class="line">		if k == -1 || targetArr[i] == targetArr[k] &#123;</span><br><span class="line">			i++</span><br><span class="line">			k++</span><br><span class="line">			targetRMT[i] = k</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			k = targetRMT[k]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 匹配</span><br><span class="line">	i, j := 0, 0</span><br><span class="line">	for ; i &lt; len(strArr) &amp;&amp; j &lt; len(targetArr); &#123;</span><br><span class="line">		if j == -1 || strArr[i] == targetArr[j] &#123;</span><br><span class="line">			i++</span><br><span class="line">			j++</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			j = targetRMT[j] // 当前位置的字符匹配失败，直接转移到模式串匹配表对应位置</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if j &gt;= len(targetArr) &#123;</span><br><span class="line">		return i - len(targetArr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h3><p>从后往前对模式串进行扫描与主串进行匹配的，使用两个启发策略。</p><p><strong>坏字符算法</strong>：坏字符：字符串中的某个字符跟模式串的某个字符不匹配时，这个失配字符为坏<br>字符。</p><ol><li>模式串中有对应的坏字符时，让模式串最靠右的对应字符与坏字符相对。</li><li>模式串中不存在坏字符，那么直接右移整个模式串长度这么大步数。</li></ol><p>坏字符表的定义为：对于输入字符集合中的字符C，如果C不在模式串中，则<code>C对应的值=模式串最末元素的索引值-字符C在模式串中最右出现的位置</code>，字符不在模式串中时对应的值为-1。</p><p><strong>好后缀算法</strong>：</p><ol><li>模式串中有子串和好后嘴完全匹配，则将最靠右的那个子串移动到好后缀的位置继续进行匹配。</li><li>如果不存在和好后缀完全匹配的子串，则好后缀中找到具有如下特征的最长子串，使得<code>P[m-s...m] = P[0...s]</code>。</li><li>如果完全不存在和好后缀匹配的子串，则右移整个模式串。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">func MatchBM(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	strLen := len(strArr)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line">	targetLen := len(targetArr)</span><br><span class="line"></span><br><span class="line">	// 构建坏字符</span><br><span class="line">	badArr := make([]int, 256)</span><br><span class="line">	for i := 0; i &lt; 256; i++ &#123;</span><br><span class="line">		badArr[i] = targetLen</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; targetLen; i++ &#123;</span><br><span class="line">		badArr[targetArr[i]] = targetLen - i - 1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 构建好后缀</span><br><span class="line">	suff := make([]int, targetLen)</span><br><span class="line">	suff[targetLen-1] = targetLen</span><br><span class="line">	for i := targetLen - 2; i &gt;= 0; i-- &#123;</span><br><span class="line">		q := i</span><br><span class="line">		for q &gt;= 0 &amp;&amp; targetArr[q] == targetArr[targetLen-1-i+q] &#123;</span><br><span class="line">			q = q - 1</span><br><span class="line">		&#125;</span><br><span class="line">		suff[i] = i - q</span><br><span class="line">	&#125;</span><br><span class="line">	goods := make([]int, targetLen)</span><br><span class="line">	for i := 0; i &lt; targetLen; i++ &#123;</span><br><span class="line">		goods[i] = targetLen</span><br><span class="line">	&#125;</span><br><span class="line">	for i := targetLen - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">		j := 0</span><br><span class="line">		if suff[i] == i+1 &#123;</span><br><span class="line">			for ; j &lt; targetLen-1-i; j++ &#123;</span><br><span class="line">				if goods[j] == targetLen &#123;</span><br><span class="line">					goods[j] = targetLen - 1 - i</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; targetLen-1; i++ &#123;</span><br><span class="line">		goods[targetLen-1-suff[i]] = targetLen - 1 - i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 查找</span><br><span class="line">	for i := 0; i &lt;= strLen-targetLen; &#123;</span><br><span class="line">		j := targetLen - 1</span><br><span class="line">		for ; j &gt;= 0 &amp;&amp; targetArr[j] == strArr[i+j]; j-- &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		if j &lt; 0 &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		max := badArr[int(strArr[i+j])] - targetLen + 1 + j</span><br><span class="line">		if goods[j] &gt; max &#123;</span><br><span class="line">			max = goods[j]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i = i + max</span><br><span class="line">	&#125;</span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><p>从前往后扫描模式串的，其思路更像是对于“坏字符”策略的升华，<strong>关注的是主串中参与匹配的最末字符的下一位</strong>，将其与当前跳表判断下一步移动距离。</p><p><strong>启发策略</strong>：</p><ul><li>当遇到不匹配的字符时，如果关注的字符没有在模式串中出现则直接跳过即<code>移动位数=子串长度+1</code>。</li><li>当遇到不匹配的字符时，如果关注的字符在模式串中也存在时，其<code>移动位数=模式串长度-该字符最右出现的位置（以0开始）</code>或者<strong><code>移动位数=模式串中该子串最右出现的位置到尾部的距离+1</code></strong>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func MatchSunday(str string, target string) int &#123;</span><br><span class="line">	strArr := []rune(str)</span><br><span class="line">	targetArr := []rune(target)</span><br><span class="line">	strLen := len(strArr)</span><br><span class="line">	targetLen := len(targetArr)</span><br><span class="line"></span><br><span class="line">	// 构建跳表</span><br><span class="line">	jump := make([]int, 255)</span><br><span class="line">	for i := 0; i &lt; 255; i++ &#123;</span><br><span class="line">		jump[i] = targetLen + 1</span><br><span class="line">	&#125;</span><br><span class="line">	for i, c := range targetArr &#123;</span><br><span class="line">		jump[c] = targetLen-i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt;= strLen-targetLen; &#123;</span><br><span class="line">		flag := true</span><br><span class="line">		for j := 0; j &lt; targetLen; j++ &#123;</span><br><span class="line">			if targetArr[j] != strArr[i+j] &#123;</span><br><span class="line">				flag = false</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if flag &#123;</span><br><span class="line">			return i</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 使用当前匹配对应长度的下一个字符计算移动距离</span><br><span class="line">		i = i + jump[strArr[i+targetLen]]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/11/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/11/25/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">【笔记】数据库系统概念</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-11-25 23:31" itemprop="dateCreated datePublished" datetime="2020-11-25T23:31:00+08:00">2020-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-19 16:19" itemprop="dateModified" datetime="2020-12-19T16:19:28+08:00">2020-12-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2020/11/25/【笔记】数据库系统概念/数据库系统概念.png" alt="数据库系统概念"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>数据库管理系统（DBMS）由一个互相关联的数据的集合（数据库）和一组用以访问这些数据的程序组成。</p><p>数据库系统的一个主要目的是为用户提供数据的抽象视图，系统隐藏数据存储和维护的细节。</p><p>数据库结构的基础是数据模型：一个用于描述数据、数据之间的联系、数据语义和数据约束的概念工具的集合。</p><p>关系数据模型是最广泛使用的将数据存储到数据库中的模型。其他的数据模型有面向对象模型、对象-关系模型和半结构化数据模型。</p><p>数据操纵语言（DML）是使得用户可以访问和操纵数据的语言。数据定义语言（DDL）是说明数据库模式和数据的其他特征的语言。</p><p>数据库设计主要包括数据库模式的设计。实体-联系（E-R）数据模型是广泛用于数据库设计的数据模型，提供一种方便的图形化的方式来观察数据、联系和约束。</p><p>数据库设计流程：</p><ul><li>制定出用户需求的规格文档</li><li>在概念设计阶段开发出来的模式提供企业的详细概述：描述数据以及它们之间的联系，而不是指定无力的存储细节</li><li>逻辑设计阶段：设计者将高层的概念模式映射到要使用的数据库系统的设计数据模式上</li><li>物理设计阶段：指定数据库中的物理特性，这些特性包括文件组织的形式以及内部的存储结构</li></ul><p>数据库系统由几个子系统构成：1、存储管理器子系统在数据库中存储的低层数据与应用程序和向系统提交的查询之间提供借口。2、查询处理器子系统编译和执行DDL和DML语句。</p><p>事务是数据库应用中完成单一逻辑功能的操作结合。<strong>每个事务是一个既具有原子性又具有一致性的单元。原子性和持久性的保证是数据库系统自身的职责。</strong>事务管理负责保证不管是否有故障发生，数据库都要处于一致的（正确的）状态。事务管理器还保证并发事务的执行互不冲突。</p><p>数据库系统的体系结构受支持其运行的计算机系统的影响很大。数据库系统可以是集中式的。或是客户-服务器方式的，即一个服务器及其为多个客户机执行工作。数据库系统还可以设计成具有能充分利用并行计算系统结构的能力。分布式数据库跨越多个地理上分布的互相分离的计算机。</p><p>典型地，数据库应用可被分为运行在客户机上的前端和运行在后端的部分。在两层的系统结构中，前端直接和后端运行的数据库进行通信。在三层结构上，后端又被分为应用服务器和数据库服务器。</p><p>知识发现技术试图自动地从数据中发现统计规律和模式。数据挖掘领域将人工智能和统计分析研究人员创造的知识发现技术，与使得知识发现技术能够在极大地数据库上高效实现的技术结合起来。数据挖掘指半自动地分析大型数据库并从中找出有用的模式的过程。</p><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系模型介绍"><a href="#关系模型介绍" class="headerlink" title="关系模型介绍"></a>关系模型介绍</h3><p><strong>数据模型是描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。</strong>数据库模式是指数据库的逻辑设计，数据库实例是指给定时刻数据库中数据的一个快照。</p><p>关系数据模型建立在表的集合的基础上。数据库系统的用户可以对这些表进行查询，可以插入新元组、删除元组以及更新（修改）元组。表达这些操作的语言又几种。</p><p>关系的模式是指它的逻辑设计。而关系的实例是指它的特定时刻的内容。数据库的模式和实例的定义的类似的。关系的模式包括它的属性，还可能包括属性类型和关系上的约束，比如主码和外码约束。</p><p>关系的超码是一个或多个属性的集合，这些属性上的取值保证可以唯一识别出关系中的元组。候选码是一个最小的超码，也就是说，它是一组构成超码的属性集，但这组属性的任意子集都不是超码。关系的一个候选码被选作主码。</p><p>在参照关系中的外码是这样的一个属性集合：对于参照关系中的每个元组来说，它在外码属性上的取值肯定等于被参照关系中某个元组在主码上的取值。</p><p>模式图是数据库中模式的图形化表示，它显示了数据库中的关系，关系的属性、主码和外码。</p><p>关系查询语言定义了一组运算集，这些运算可以作用于表上，并输出表作用结构。这些运算可以组合成表达式，表达所需的查询。</p><p>关系代数提供了一组运算，它们以一个或多个关系为输入，返回一个关系作为输出。诸如SQL这样的实际查询语言的基于关系代数的，但增加了一些有用的句法特征。</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL是最有影响力的商用市场化的关系查询语言。包括以下几个部分：1、数据定义语言（DDL），提供了定义关系模式、删除关系以及修改关系模式的命令；2、数据操作语言（DML），提供查询语言，以及往数据库中插入元组、从数据库中删除元组修改数据库中元组的命令。</p><p>SQL的数据定义语言用于创建具有特定模式的关系。除了声明关系属性的名称和类型之外，SQL还允许声明完整性的约束，例如主码约束和外码约束。</p><p>SQL提供多种用于查询数据库的语言结构，其中包括select、form和where子句。SQL支持自然连接操作。</p><p>SQL还提供了对属性的关系重命名，以及对查询结果按特定属性进行排序的机制。</p><p>SQL支持关系上的基本集合运算，包括并、交和差运算。</p><p>SQL通过在通用真值true和false外增加增值“unknown”，来处理对包含空值进行排序的机制。</p><p>SQL支持在外层查询的where和from子句中嵌套子查询。它还在一个表达式返回的单个值所允许出现的任何地方支持标量子查询。</p><p>SQL提供了用于更新、插入、删除信息的结构。</p><h3 id="中级SQL"><a href="#中级SQL" class="headerlink" title="中级SQL"></a>中级SQL</h3><p>SQL支持包括内连接、外连接在内的几种连接类型，以及几种形式的连接条件。</p><p>视图关系可以定义为包含查询查询结果的关系。视图可以隐藏不需要的信息，可以把信息从多个关系收集到一个单一的视图中。</p><p>事务是一个查询的更新的序列，它们共同执行某项任务。事务可以被提交或回滚。当一个事务被回滚，该事务执行的所有更新所带来的影响将被撤销。</p><p>完整性约束保证授权用户对数据库所做的改变不会导致数据一致性的破坏。</p><p>参照完整性约束保证出现在一个关系的给定属性集上的值同样出现在另一个关系的特定属性集上。</p><p>域约束指定了在一个属性上可能取值的集合。这种约束也可以禁止在特定属性上使用空值。</p><p>断言是描述性表达式，它指定了我们要求总是为真的谓词。</p><p>SQL数据定义语言提供对定义诸如date和time那样的固有域类型以及用户定义域类型的支持。</p><p>通过SQL授权机制，可以按照在数据库中不同数据值上数据库用户所允许的访问类型对他们进行区分。</p><p>获得了某种形式授权的用户可能允许将此授权传递给其他用户。但是，对于权限怎样在用户间传递我们必须很小心，以保证这样的权限在将来的某个时候可以被收回。</p><p>角色有助于根据用户在组织机构中扮演的角色，把一组权限分配给用户。</p><h3 id="高级SQL"><a href="#高级SQL" class="headerlink" title="高级SQL"></a>高级SQL</h3><p>SQL查询可以从宿住语言通过嵌入和动态SQL激发。ODBC和JDBC标准给C、Java等语言的应用程序定义接入SQL数据库的应用程序接口。</p><p>函数和过程可以用SQL提供的过程来定义，它允许迭代和条件语句。</p><p>触发器定义了当某个事件发生而且满足相应条件时自动执行的动作。触发器有很多用处，例如实现业务规则、审计日志，甚至执行数据库系统外的操作。</p><p>联机分析处理（OLAP）工具帮助分析人员用不同的方式查看汇总数据。</p><ul><li>OLAP工具工作在以维属性和度量属性为特性的多维数据之上。</li><li>数据立方体由以不同方式汇总的多维度数据构成。预先计算数据立方体有助于提高汇总数据的查询数据。</li><li>交叉表的显示允许用户一次查看多维数据的两个维及其汇总数据。</li><li>下钻、上卷、切片和切块是用户使用OLAP工具时执行的一些操作。</li></ul><h3 id="形式化关系查询语言"><a href="#形式化关系查询语言" class="headerlink" title="形式化关系查询语言"></a>形式化关系查询语言</h3><p>关系代数定义了一套在表上运算且输出结果也是表的代数运算。这些运算可以凝合使用来得到表达所希望查询的表达式。关系代数定义了关系查询语言中使用的基本运算。</p><p>关系代数运算可以分为：</p><p><strong>1、基本运算；</strong></p><p>关系代数基本运算有：选择、投影、并、集合差、笛卡尔积和更名。选择、投影和更名运算是一元运算符。选择：选出满足给定谓词的元组。</p><p>二元运算自然连接使得我们可以将某些选择和笛卡尔积运算合并为一个运算。自然连接运算首先形成它的两个参数的笛卡尔积，然后基于两个关系模式中都出现的属性上相等性进行选择，最后还要去除重复属性。</p><p><strong>2、附加的运算，可以用基本运算的表达；</strong></p><p>包括集合交、自然连接和赋值。</p><p><strong>3、扩展的运算，其中的一些扩展了关系代数的表达能力。</strong></p><p>广义投影：允许在投影列表中使用算术运算和字符串函数等来对投影进行扩展。</p><p>以下三种等价：</p><ul><li>基本关系代数（不包含扩展关系代数运算）</li><li>限制在安全表达式范围内的元组关系演算</li><li>限制在安全表达式范围内的域关系演算</li></ul><p>没有任何一个域关系演算等价于聚集运算，但是它可以扩展支持聚集。</p><p>关系代数式一中简洁的、形式化的语言，不适合于那些偶尔使用数据库系统的用户。因此，商用数据库系统采用有更多“语言修饰”的语言。</p><p>元组关系演算和域关系演算使非过程化语言，代表了关系查询语言所需的基本能力。基本关系代数式一种过程化语言，在能力上等价于被限制在安全表达式范围内的关系演算的这两种形式。</p><p>关系演算的简洁的、形式化的语言，并不适合于那些偶尔使用数据库系统的用户。</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="数据库设计与E-R模型"><a href="#数据库设计与E-R模型" class="headerlink" title="数据库设计与E-R模型"></a>数据库设计与E-R模型</h3><ul><li>数据库设计的最初阶段需要完整地刻画未来数据库用户的数据需求</li><li>设计者选择数据模型，并采用所选数据模型的概念将这些需求转化为数据库的概念模式。在概念设计阶段所产生的模式提供了一个对企业的详细综述。</li><li>完善的该你那模式还指明企业的功能需求。</li><li>从抽象数据模型到数据库的实现的转化在最后两个设计阶段中进行<ul><li>逻辑设计阶段：将高层概念模式映射到将使用的数据库系统的实现数据模式上。</li><li>物理设计简单：指明数据库的物理特征。</li></ul></li></ul><p>在设计一个数据库模式时，需要确保避免两个主要缺陷：冗余、不完整。</p><p>数据库设计主要涉及数据库模式的设计。实体-联系（E-R）数据库模型是一个广泛用于数据库设计的数据模型。提供了一个方便的图形化表示方法以查看数据、联系和约束。</p><p>E-R模型主要用于数据库设计过程。它的发展是为了帮助数据库设计，这是通过允许定义企业模式实现的。这种企业模式代表数据库的全局逻辑结构，可以用E-R图形化表示。</p><p>实体是在现实世界中存在并且区别于其他对象的对象。通过把每个实体同描述该实体的一组属性相关联来表示区别。</p><p>联系是多个实体间的关联。相同类型的联系的集合为联系集，相同类型的实体的集合为实体集。</p><p>每个属性都有一个可取值的集合，称为该属性的域，或者值集。</p><p>术语超码、候选码以及主码同适用于关系模式一样适用于实体和联系集。</p><p>映射的基数表示通过联系集可以和另一实体相关联的实体的个数。</p><p>不具有足够属性构成的主码的实体集称为弱实体集。具有主码的实体集称为强实体集。</p><p>E-R模型的各种性质为数据库设计者提供了大量的选择，使设计人员可以最好地表示被建模的企业。在某些情况下，概念和对象可以用实体、联系或属性来表示。企业总体结构的各方面可以用弱实体集、概化、特化或聚集很好地描述。设计者通常需要在简单的、紧凑的模型与更精确但也更复杂的模型之间进行权衡。</p><p>用E-R图定义的数据库设计可以用关系模式的集合来表示。数据库的每个实体集和联系集都有唯一的关系模式与之对应，其名称即为相应的实体集或联系集的名称。这是从E-R图转换为关系数据库设计的基础。</p><p>特化和概化定义了一个高层实体集和一个或多个低层实体集之间的包含关系。特花是取出高层实体集的一个子集来形成一个低层实体集。概化湿用两个或者多个不相交的（低层）实体集的并集形成一个高层实体集。高层实体集的属性被低层实体集继承。</p><p>聚集是一种抽象，其中联系集（和它们相关的实体集一起）被看作高层实体集，并且可以参与联系。</p><p>UML是一种常见的建模语言。UML类图广泛用于对类建模以及一般的数据建模。</p><h3 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h3><p>冗余存储则存在不一致的风险。</p><p>如果该域的元素被认为是不可分的单元，这个域是原子的。<strong>如果关系模式R的所有属性的域都是原子的，那么称R属于第一范式（1NF）。</strong></p><p>在许多含有复杂结构的实体域中，强制使用第一范式会给应用程序员造成不必要的负担。设计与开发时需要从当前业务考虑。</p><p>一个关系的满足所有现实世界的约束的实例，称为关系的合法实例（满足业务要求的实例）。</p><p>使用F+符号表示F集合的闭包，能够从给定F集合推导出所有函数依赖的集合。F+包含了F的所有函数依赖。</p><p><strong>具有函数依赖集F的关系模式R属于BCNF的条件是，对于F+中所有形如a-&gt;b的函数依赖（其中a与b都包含于R），下面至少一项成立：1、a-&gt;b是平凡的函数依赖（即b包含于a）；2、a是模式R的一个超码。一个数据库设计属于BCNF的条件是，构成该设计的关系模式集中的每种模式都属于BCNF。</strong></p><p><strong>第三范式：对于F+中所有形如a-&gt;b的函数依赖（其中a，b都包含于R）以下至少一项成立：1、a-&gt;b是一个平凡的函数依赖；2、a是R的一个超码；3、b-a中的每个属性A都包含于R的一个候选码中（候选码是最小的超码，且任意子集都不是超码）。</strong></p><p>给定关系模式r(R)，如果r(R)的每一个满足F的实例都满足f，则R上的函数依赖f被r上的函数依赖F逻辑蕴涵。F的闭包是被F逻辑蕴涵的所有函数依赖的集合（F+）。</p><p>函数依赖和多值依赖集为D的关系模式r(R)属于第四范式的条件是，对于D+中所有形如a–&gt;b的多值依赖（其中a和b都包含于R），以下至少一项成立：1、a–&gt;b是一个平凡的多值依赖；2、a是R的一个超码。</p><h3 id="应用设计和开发"><a href="#应用设计和开发" class="headerlink" title="应用设计和开发"></a>应用设计和开发</h3><h2 id="数据存储和查询"><a href="#数据存储和查询" class="headerlink" title="数据存储和查询"></a>数据存储和查询</h2><h3 id="存储和文件结构"><a href="#存储和文件结构" class="headerlink" title="存储和文件结构"></a>存储和文件结构</h3><p>最快的存储介质（如高速缓冲存储器和主存储器）称为基本存储。层次结构中的基本存储介质的下一层介质（如磁盘）称为辅助存储或联机存储。层次结构中最底层的介质（如磁带机和自动光盘机）称为三级存储或脱机存储。</p><p>易失性存储在设备断电后将丢失所有的内容。</p><p>存储介质的可靠性由两个因素决定：1、电源故障或系统崩溃是否导致数据丢失；2、存储设备发生物理故障的可能性有多大。</p><p>通过保留数据的多个拷贝，可以减少物理故障的可能性。对磁盘来说可以使用镜像技术。或者可以使用更复杂的基于独立磁盘冗余阵列（RAID）的方法。通过将数据拆分到多张磁盘上，可以提高大数据量访问的吞吐率；通过引入多张磁盘上的冗余存储，可以显著提高可靠性。</p><p>可以把一个文件从逻辑上组织成映射到磁盘块上的一个记录序列。把数据库映射到文件的一种方法是使用多个文件，每个文件只存储固定长度的记录。另一种方法是构造文件。使之能适应多种长度的记录。分槽的页方法广泛应用于在磁盘块中处理变长记录。</p><p>通过在多张磁盘上进行数据拆分来提高传速率。数据拆分最简单的形式是将每个字节按比特分开，存储到多个磁盘上。这种拆分称为比特级拆分。块级拆分是将块拆分到多张磁盘。</p><p>磁盘系统并行有两个主要目的：1、负载平衡多个小的访问操作（块访问），以提高这种访问操作的吞吐量；2、并行执行大的访问操作，以减少大访问的响应时间。</p><p>大对象常常存储到一个特殊的文件（或文件的集合）中而不是与记录的其他（短）属性存储在一起。然后一个指向该对象的（逻辑）指针存储到包含该大对象的记录中。</p><p><strong>顺序文件是为了高效处理按某个搜索码的顺序排序的记录而设计的。搜索码是任何的一个属性或者属性的集合。</strong></p><p><strong>多表聚簇文件组织是一种在每一块中存储两个或者更多个关系的相关记录的文件结构。</strong></p><p>数据库系统的一个主要目的就是尽量减少磁盘和存储器之间传输的块数目。负责缓冲区空间分配的子系统称为缓冲区管理器。缓冲的是块而非数据。</p><h3 id="索引与散列"><a href="#索引与散列" class="headerlink" title="索引与散列"></a>索引与散列</h3><p>数据库系统首先查找索引，找到相应记录所做的磁盘块，然后取出该磁盘块，得到所需的记录。</p><p>如果包含记录的文件按照某个搜索码指定的顺序排序，那么该搜索码碎影的索引称为聚集索引。</p><p>索引顺序文件是数据库系统中最古老的索引模式之一。为了允许按搜索码顺序快速检索记录，记录按顺序存储，而无序记录链接在一起。为了允许快速的随机访问，使用了索引结构。</p><p>可以使用的索引类型有两种：稠密索引和稀疏索引。稠密索引对每个搜索码值都有索引项，而稀疏索引只对某些搜索码值包含索引项。利用稠密索引通常可以比稀疏索引更快地定位一条记录。但是，稀疏索引所占空间较小，并且插入和删除时所需的维护开销也较小。（折中方案：为每个块建一个索引项的稀疏索引）</p><p>利用多级索引搜索记录与用二分法搜索记录相比需要的I/O操作要少得多。</p><p>如果搜索码的排序序列和关系的排序序列相匹配，则该搜索码上的索引称为聚集索引，其他索引称为非聚集缩影或辅助索引。辅助索引可以提高不以聚集索引的搜索码作为搜索码的查询的性能。但是，辅助索引增加了修改数据库的开销（辅助索引必须是稠密索引，对每个搜索码值都有一个索引项，而且对文件中的每条记录都有一个指针）。</p><p>候选码上的辅助索引看起来和稠密聚集索引没有太大区别，只不过索引中一系列的连续值执行的记录不是连续存放的。</p><p>索引顺序文件组织的主要缺点是随着文件的增大，性能会下降。为了克服这个缺点，可以使用B+树索引。</p><p>B+树索引采用平衡树的形式，即从树根到树叶的所有路径长度相等。B+树的高度与以关系中的记录数N为底的对数成正比，其中每个非叶子结点存储N个指针，N值通常约为50～100。因此，B+树比其他的平衡二叉树（比如AVL树）要矮喝多，故定位记录所需的磁盘访问次数也较少。</p><p>B+树上的查询是直接而且高效的。然而插入和删除要更复杂一些，但是仍然很有效。在B+树中，查询、插入和删除所需的操作数与以关系中的记录数N为底的对数成正比，其中每个非叶子结点存储N个指针。</p><p>可以用B+树去索引包含记录的文件，也可以用它组织文件中的记录。</p><p>B树索引和B+树索引类型。B树的主要优点在于它去除了搜索码值存储中的冗余（当搜索码值唯一的情况下，只允许搜索码值出现一次）。主要缺点在于整体的复杂性以及节点大小给定时减小了扇出（直接连接下级个数，节点大导致扇出小，深度增加）。在实际应用中，系统设计者几乎无一例外的倾向于使用B+树索引。</p><p>R树是B+树的扩展，用于处理在多个维度上的索引。</p><p>覆盖索引存储一些属性（但不是搜索码属性）的值以及指向记录的职责。存储附加的属性值对于辅助索引是非常有用的，仅仅使用索引就能够回答一些查询，甚至不需要找到实际的记录。</p><p>顺序文件组织需要一个索引结构来定位数据。相比之下，基于散列的文件组织允许我们通过计算所需记录搜索码值上的一个函数直接找出一个数据项的地址。由于设计时我们不能精确知道哪些搜索码值将存储在文件中，因此一个好的散列函数应该能均匀且随机地将搜索码值分散到各个桶中。</p><p>静态散列所用散列函数和桶地址集合是固定的。这样的散列函数不容易适应数据库随时间的显著增长。有几种允许修改散列函数的动态散列技术。可扩充散列是其中之一，它可以在数据库增长或缩减时通过分裂或合并桶来应付数据库大小的变化。</p><p>也可以用散列技术创建辅助索引：这样的索引称为散列索引。为使记法简便，假定散列文件组织中用户散列的搜索码上有一个隐式的散列索引。</p><p>可扩充散列可以通过桶的分裂或合并来适应数据库的大小的变化。由于重组每次仅作用于一个桶，因此所带来的性能开销较低，可以接受。可扩充散列的最主要优点是其性能不随文件的增长而降低，其空间开销是最小的。缺点在于查找涉及一个附加的间接层。</p><p>像B+树和散列索引这样的有序索引可以用作涉及单个属性且基于相等条件的选择操作。当一个选择条件中涉及多个属性时，可以取多个索引中检索到的记录标示符的交。</p><p>对于索引属性只有少数几个不同值的情况，位图索引提供了一种非常紧凑的表达方式。位图索引的交操作相当得快，使得它成为一种支持多属性上的查询的理想方式（属性有限变量下）。</p><h3 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h3><p>对于一个查询，系统首先要做的事就是将之翻译成系统内部的表示形式。对于关系数据库系统而言，内部形式通常是基于关系代数的。在产生查询的内部形式的过程中，语法分析器检查用户查询语句的语法，验证出现在查询语句中的关系名是数据库中的关系名等。如果查询语句是用视图表达的，语法分析器把所有对视图名的引用替换成计算该视图的关系代数表达式。</p><p>查询处理步骤：1、语法分析与翻译；2、优化；3、执行。</p><p>加了“如何执行”注释的关系代数运算称为计算原语。用于执行一个查询的原语操作序列称为查询执行计划或者查询计算计划。查询执行引擎接受一个查询执行计划，执行该计划并把结果返回给查询。</p><p>给定一个查询，通常有许多计算它的方法。将用户输入的查询语句转化成等价的、执行效率更高的查询语句，这是优化器的责任。优化器通常努力去尽可能降低查询计划总的资源消耗，而不是尽可能缩低响应时间。</p><p>辅助索引存储的是B+树文件组织中作为码值的属性值。通过这种辅助索引存取一条记录的代价将更大：首先必须搜索辅助索引以找到主索引的搜索码值，然后查找主索引来找到记录。</p><p>对于包含简单选择的查询语句，可以通过线性扫描或者利用索引来处理。通过计算简单选择结果的并和交，可以处理复杂选择操作。</p><p>数据排序：1、SQL查询会指明对结果进行排序；2、当输入的关系已排序时，关系运算中的一些运算（如连接运算）能够得到高效实现。</p><p>可以用外部归并排序算法对大内存的关系进行排序。</p><p>设计自然连接的查询语句可以有多种处理方法，如果处理取决于是否有索引可用以及关系的物理存储形式。</p><ul><li>若连接的结果大小几乎和两个关系的笛卡尔积相当，可以采用嵌套循环连接策略较好。</li><li>若存在索引，则可用索引嵌套循环连接。</li><li>若关系已排序，则归并连接比较可取。在连接计算前对关系排序是有利的（为了能使用归并连接算法）。</li><li>散列连接算法把关系划分成多个部分，使每个部分都能被内存所容纳。划分过程是通过连接属性上的散列函数来进行的，这样相应的划分对可以独立地进行连接。</li></ul><p>嵌套循环连接算法不要求有索引，并且不管连接的条件是什么，该算法均可以使用。块嵌套循环连接是以块的方式而不是以元组的方式处理关系，可以减少不少块读写次数。索引嵌套循环连接，可以在已有索引或者为了计算该连接而专门建立临时索引的情况下使用。归并连接算法（排序-归并-连接算法）可用于计算自然连接和等值连接。混合归并-连接算法把已排序关系与B+树辅助索引叶结点进行归并。散列连接算法可用于实现自然连接和等值连接，基本思想是把这两个关系的元组划分成连接属性值上具有相同散列值的元组集合。</p><p>去除重复、投影、集合操作（并、交、差）、聚集操作都可以用排序和散列实现。</p><p>外连接操作可以通过对连接算法的简单扩展来实现。</p><p>散列与排序在某种意义下是对偶的。因为任何能用散列实现的操作（如去除重复、投影、聚集、连接、外连接）也可用排序来实现，反之亦然；即任何能用排序来实现的操作也能用散列实现。</p><p>可以采用物化方法进行表达式的计算。系统计算每个子表达式的结果并将其存在磁盘上，然后用它进行父表达式的计算。</p><p>流水线方法在子表达式产生输出的同时就在父表达式的计算中使用其输出结果，帮助我们避免了将许多子查询的结果写到磁盘的操作。</p><p>由于去除重复的代价相对较大，因此SQL查询语言要求用户显示指明需要去除重复，若不指明则保留重复。</p><p>每次计算的结果都被物化到一个临时关系中已备后用。这个方法的缺点是需要构造临时关系，这些临时关系必须写到磁盘上（除非很小）。</p><p>减少临时文件数是通过将多个关系操作组合成一个操作的流水线来实现的，其中一个操作结果将传送到下一个操作。</p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>给定一个查询，一般有多种方法可以计算结果。系统负责将用户输入的查询转换成能够更有效执行的等价查询。为处理查询找出一个好的策略的过程称为查询优化。</p><p>复杂查询的执行涉及多次存取磁盘的操作。由于从磁盘中传输数据相对于主存速度和计算机系统的CPU速度要慢，因此进行一定量的处理以选择一个能够从最小化磁盘存取的方法是完全值得的。</p><p>查询执行计划的产生有三步：1、产生逻辑上与给定表达式等价的表达式；2、对所产生的表达式以不同方式作注释，产生不同的查询计划；3、估计每个执行计划的代价，选择估计代价最小的一个。</p><p>有很多等价规则供我们用于将一个表达式转化成等价表达式。我们使用这些规则系统地产生与所给查询等价的所有表达式。（如果两个关系表达式在每一个有效数据库实例中都会产生相同的元组集，则我们称它们是等价的。）</p><p>若一组等价规则中任意一条规则都不能由其他规则联合起来导出，称这组等价规则集为最小等价规则集。</p><p>优化器采用两种关键思想可以极大地减少空间和时间上的开销：</p><ul><li>如果在子表达式e(i)上使用等价规则把表达式E1转化成E‘，则除了e(i)及其转换，E1与E‘有相同的子表达式。而且e(i)及其转换通常也有许多相同的子表达式。可以采用一些表达式表示技术，使两个表达式指向共享的子表达式，这样可以明显减少对空间的需求。</li><li>不必总是用等价规则产生所有可以产生的表达式。如果考虑估计的执行代价，优化器可以避免检查某些表达式。</li></ul><p>每个关系代数表达式都表示某个特定的操作序列。选择查询处理策略的第一步就是找到一个关系代数表达式，使它与所给的表达式等价并且据估计有更小的执行代价。</p><p>基于代价的优化器从给定查询等价的所有查询执行计划空间中进行搜索，并选择估计代价最小的一个。</p><p>数据库系统为执行一个操作所选择的策略依赖于每个关系的大小和列值的分布情况。数据库系统可以为每个关系r存储统计信息，从而能够基于这些可靠信息选择适合的策略。这些统计信息包括：</p><ul><li>关系r中的元组数</li><li>关系r中的一个记录（元组）的大小（按字节计数）</li><li>关系r中的某个特定属性中出现的不同取值的数目</li></ul><p>许多数据库系统使用直方图来存储一个属性在每个区间上的取值个数。直方图通常采用取样来计算。</p><p>这些统计信息使得我们可以估计各种操作的结果集的大小和执行操作的代价。当处理一个查询的过程中有多个索引可用于辅助的时候，关系的统计信息特别有用，这些信息对查询处理策略的选择有很大影响。</p><p>物理等价规则允许将例如连接这样的逻辑操作转换成像散列连接或嵌套循环连接这样的物理操作。通过将这类规则添加到原来的等价规则中，程序可以产生所有可能的执行计划。</p><p>对每个表达式，我们可以用一些等价规则产生多个可选的执行计划，然后从中选择代价最小的执行计划。不少优化技术可以减少需要产生的可选表达式和执行计划的数量。</p><p>我们使用启发式方法来减少需要考虑的执行计划的数量，从而减少优化的代价。用于关系代数查询转换的启发式规则包括“尽早执行选择操作”、“尽早执行投影操作”、和“避免笛卡尔积操作”。</p><p>用一个具有连接的查询（可能使用临时关系）去替代嵌套查询的过程称为去除相关。</p><p>物化视图可以用来加速查询处理。当原关系发生修改时，需要用增量的视图维护来高效地更新物化视图。利用包含一个操作的输入的变化量的代数表达式，能够完成对该操作的变化量的计算。其他与物化视图相关的问题还包括如何借用物化视图进行查询优化和如何选择需要待物化的视图。查询优化器的工作应该包括知道何时可利用物化视图来提高查询处理速度。</p><p>一些优化技术，包括top-K优化、连接极小化、更新优化、多查询优化和参数化查询优化。</p><p>共享式扫描优化的工作方式如下：不是对于需要扫描一个关系的每一个查询，都从磁盘上重复地读取该关系，而是从磁盘上读取一次数据，然后流水线地传递给每一个查询。（一次读取，多次使用）</p><p>如果最优计划受查询中的常数值影响不大，则通过计划缓存重用计划是合理的。然而如果计划受常数的影响，则可以使用参数化查询优化作为替代。</p><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>事务指的是构建单一逻辑工作单元的操作的集合。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务时一个程序执行单位，它访问且可能更新不同的数据项。理解事物这个概念对于理解与实现数据库中的数据更新是很关键的，只有这样才能保证并发执行与各种故障不会导致数据库处于不一致状态。</p><p>事务具有ACID特性：原子性、一致性、隔离性、持久性。</p><ul><li>原子性保证事务的所有影响在数据库中要么全部反映出来，要么根本不反应；一个故障不能让数据库处于事务部分执行后的状态。</li><li>一致性保证若数据库一开始是一致的，则事务（单独）执行后数据库仍处于一致状态。</li><li>隔离性保证并发执行提高了事务吞吐量和系统利用率，也减少了事务等待时间。</li><li>持久性保证一旦一个事务提高后，它对数据库的改变不会丢失，即使系统可能出现故障。</li></ul><p>事务的并发执行提高了事务吞吐量和系统利用率，也减少了事务等待时间。</p><p>计算机中不同存储介质包括异失性存储器、非易失性存储器和稳定性存储器。易失性存储器（例如RAM）中数据当计算机崩溃时丢失。非易失性存储器（如磁盘）中的数据在计算机崩溃时不会丢失，但是可能会由于磁盘崩溃而丢失。稳定性存储器中的数据永远不会丢失。</p><p>为了一个事务能够持久，它的修改应该写入稳定性存储器。为了一个事务是原子的，日志记录需要在对磁盘上的数据库做任何改变之前写入稳定性存储器。</p><p>必须支持在线访问的稳定性存储器与磁盘镜像或者其他形式的提供冗余数据存储的RAID接近。对于离线或归档的情况，稳定性存储器可以由存储在物理安全位置的数据的多个磁带备份所构成。</p><p>撤销已提交事务所造成的影响的唯一方法是执行一个补偿事务。</p><p>多个事务在数据库中并发执行时，数据的一致性可能不再维持。因此系统必须控制各并发事务之间的相互作用。</p><ul><li>由于事务时保持一致性的单元，所以事务的串行执行能保持一致性。</li><li>调度捕获影响事务并发执行的关键操作，如read和write操作，而忽略事务执行的内部细节。</li><li>我们要求事务集的并发执行所产生的任何调度的执行效果等价于由这些事务按某种串行顺序执行的效果。</li><li>保证这个特性的系统称为保证可串行化。</li><li>存在几种不同的概念，从而引出了冲突可串行化与视图可串行化的概念。</li></ul><p>事务并发执行所产生的调度的可串行化可以通过多种并发控制机制中的一种来加以保证。</p><p>给定一个调度，我们可以通过为该调度构造优先图几搜索是否无环来判定它是否冲突可串行化。然而，有更好的并发控制机制可用来保证可串行化。</p><p>调度必须时可恢复的，以确保：若事务a看到事务b的影响，当b中止时，a也要中止。（一个可恢复调度应该满足：对于每个事务T(i)和T(j)，如果T(j)读取了之前由T(i)所写的数据项，则T(i)先于T(j)提交。）</p><p>调度最好是无级联的，这样不会由于一个事务的中止引起其他事务的级联中止。无级联性是通过只允许事务读取已提交数据来保证的。（因单个事务故障导致一系列事务回滚的现象称为级联回滚。（无级联调度=可恢复调度）</p><ul><li><strong>可串行化</strong>：通常保证可串行化调度。</li><li><strong>可重复读</strong>：只允许读取已提交的数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据项。</li><li><strong>已提交读</strong>：只允许读取已提交数据，但不要求可重复读。</li><li><strong>未提交读</strong>：允许读取未提交数据。（脏读）</li></ul><p>所有隔离性级别都不允许<strong>脏写</strong>，即如果一个数据项已经被另一个尚未提交或者中止的事务写入，则不允许对该数据项执行写操作。</p><p>数据库的并发控制管理部件复杂处理并发控制机制。</p><p>快照隔离可以保证读数据的尝试永远无须等待，但带来的问题是提供了太多的隔离。如果事务多次运用之间数据库发生改变，那么即使是同一个事务，在多次不同运行中也可能会使用不同的数据项。</p><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p>当多个事务在数据库中并发执行时，数据的一致性可能不再维持。系统有必要控制各事务之间的相互作用，这是通过称为并发控制机制的多种机制中的一种来实现的。</p><p>为保证可串行性，我们可以使用多种并发控制机制。所以这些机制要么延迟一个操作，要么中止发出该操作的事务。最常用的机制是多种封锁协议、时间戳排序机制、有效性检查技术与多版本机制。</p><p>封锁协议是一组规则，这些规则阐明了事务何时对数据库中的数据项进行加速和解锁。</p><p>两阶段封锁协议仅在一个事务未曾释放任何数据项上的锁时才允许该书屋封锁新数据项。该协议保证可串行化，但不能避免死锁。在没有关于数据项访问方式信息的情况下，两阶段封锁协议对于保证可串行性既是必要的又是充分的。</p><p><strong>两阶段封锁协议</strong>：要求每个事务分两个阶段提出加锁和解锁申请。</p><ul><li>增长阶段：事务可以获得锁，但不能释放锁。</li><li>缩减阶段：事务可以释放锁，但不能获得新锁。</li></ul><p>严格两阶段封锁协议要求事务持有的所有排他锁必须在事务结束时方可释放，其目的是保证结果调度的可恢复性和无级联性，强两阶段封锁协议要求事务持有的所有锁必须在事务结束时方可释放。</p><p>锁转换：提供一种将共享锁升级为排他锁，以及将排他锁降级为共享锁的机制。</p><p>锁管理器可以实现一个过程，从事务接受消息并反馈消息。数据结构：为目前已加锁的每个数据项维护一个链表，每一个请求为链表中一条记录，按请求到达的顺序排序。</p><ul><li>当一个锁请求消息到达时，如果相应的数据项的链表存在，在该链表末尾增加一个记录；否则新建一个仅包含该请求记录的链表。<ul><li>在当前没有加锁的数据项上总是授予第一次加锁请求，但当事务向已被加锁的数据项申请加锁时，只有当该请求与当前持有的锁相容，并且所有先前的请求都已授予锁的条件下，锁管理器才为该请求授予锁，否则该请求只好等待。</li></ul></li><li>当锁管理器收到一个事务的解锁消息时，它将与该事务相对应的数据项列表中的记录删除，然后检查随后的记录，如果有，如前所述，就看该请求能否被授权，如果能，锁管理器授权该请求并处理气候记录，如果还有，类似地一个接一个处理。</li><li>如果一个事务中止，锁管理器删除该事务产生的正在等待加锁的所有请求。一旦数据库系统采取适当动作撤销该事务，该中止事务持有的所有锁将被释放。</li></ul><p>基于图的封锁协议对访问数据项的顺序加以限制，从而不需要使用两阶段封锁还能够保证可串行性，而且又能够保证不会产生死锁。</p><p>许多种封锁协议都不能防止死锁。一种可以防止死锁的方法是使用数据项的一种顺序，并且按与该顺序一致的次序申请加锁。另一种防止死锁的方法是使用抢占的事务回滚。为控制抢占，我们给每个事务赋予一个唯一时间戳，这些时间戳用于决定事务是等待还是回滚。如果一个事务回滚，它在重启时保持原有时间戳。wound-wait机制是一个抢占机制。</p><p>如果没有预防死锁，系统必须用死锁检测与恢复机制来处理它们。为此，系统构造了一个等待图。当且仅当等待图包含环时，系统处于死锁状态。当一个检测算法判断死锁存在，系统必须从死锁种恢复。系统通过回滚一个或多个事务来解除死锁。</p><p>某些情况下把多个数据项聚为一组，将它们作为聚集数据项来处理，其效果可能更好，这就导致了粒度的多个级别。我们允许各种大小的数据项，并定义数据项的层次，其中小数据项嵌套于大数据项之中。这种层次结构可以图形化地表示为树。封锁按从根结点到叶结点的顺序进行；解锁则按从叶结点到根结点的讯息进行。该协议保证可串行性，但不能避免死锁。</p><p>时间戳排序机制通过事先对每对事务之间选择一个顺序来保证可串行性。系统中的每个事务对应一个唯一的固定时间戳。事务的时间戳决定了事务的可串行化顺序。这样，如果事务T(i)的时间戳小于事务T(j)的时间戳，则该机制保证产生的调度等价于事务T(i)出现在事务T(j)之前的一个串行调度。该机制通过回滚违反该次序的事务来保证这一点。</p><p>在大部分事务时只读的情形下，冲突频率很低，这种情况下有效性检查机制是一个适当的并发控制机制。系统中的每个事务对应一个唯一的固定时间戳。串行性次序是由事务的时间戳决定的。在该机制中，事务不会延迟。不过，事务要完成必须通过有效性检查。如果事务未通过有效性检查，则该事务回滚到初始状态。</p><p>有效性检查协议要求每个事务T(i)在其生命周期中按两个或三个阶段执行，这取决于该事务时一个只读事务还是一个更新事务。</p><ul><li>读阶段：系统执行事务T(i)。各数据项值被读取并保存在事务T(i)的局部变量中。所有的write操作都是对局部临时变量进行的，并不对数据库进行真正的更新。</li><li>有效性检查阶段：对事务T(i)进行有效性测试。判断是否可以执行write操作而不违反可串行性。如果事务有效性测试失败，则系统终止这个事务。</li><li>写阶段：若事务T(i)已通过有效性检查，则保存T(i)任何写操作结果的临时局部变量值被复制到数据库中。只读事务忽略这个阶段。</li></ul><p>多版本并发控制机制基于在每个事务写数据项时为该数据项创建一个新版本。读操作发出时，系统选择其中的一个版本进行读取。利用时间戳，并发控制机制保证按确保可串行性的方式选取要读取的版本。读操作总能成功。</p><ul><li>在多版本时间戳排序中，写操作可能引起事务的回滚。</li><li>在多版本的两阶段封锁中，写操作可能导致封锁等待或者死锁。</li></ul><p>快照隔离时一种基于有效性检验的多版本并发控制协议，与多版本两阶段封锁协议不同，它不需要将事务声明为只读或更新的。快照隔离不保证可串行化，但是许多数据库系统仍然支持它。</p><p>仅当要删除元组的事务在该元组上具有排他锁时，delete操作才能够进行。数据库中插入新元组的事务在该元组上被授予排他锁。</p><p>插入操作可能导致幻象现象，这是插入操作与查询操作发生逻辑冲突，尽管两个事务可能没有存取共同的元组。如果封锁仅加在事务访问元组上，这种冲突就检测不到。关系中用于查找元组的数据需要加锁，索引封锁技术要求对某些索引结点加锁来解决这个问题。所加的锁保证所有事务在实际的数据项上发生冲突，而不是在幻象上。索引封锁协议运作如下：</p><ul><li>每个关系至少有一个索引。</li><li>只有首先在关系的一个或多个索引上找到元组后，事务T(i)才能访问关系上的这些元组。为了达到索引封锁协议的目的，全表扫描看作一个索引上所有叶结点的扫描。</li><li>进行查找（不管区间查找还是点查找）的事务T(i)必须在它要访问的所有索引叶结点上获得共享锁。</li><li>在没有更新关系r上的所有索引之前，事务T(i)不能插入、删除或更新关系r中的元组t(i)。该事务必须获得插入、删除或更新所影响的所有索引叶结点上的排他锁。对于插入和删除，受影响的叶结点时那些（插入后）包含或（删除前）包含元组搜索码值的叶结点。对于更新，受影响的叶结点时那些（修改前）包含搜索码旧值的叶结点，以及（修改后）包含搜索码新值的叶结点。</li><li>元组照常获得锁。</li><li>必须遵循两阶段封锁协议规则。</li></ul><p>弱级别的一致性用于一些应用中，在这些应用中，查询结果的一致性不是至关重要的，而使用可串行性会使查询对事务的处理起反作用。二级一致性是这种弱级别的一致性之一，游标稳定性是二级一致性的一个特例，而且已被广泛应用。</p><p>游标稳定性保证：</p><ul><li>正被迭代处理的元组被加上共享锁。</li><li>任何被更改的元组被加上排他锁，直至事务提交。</li></ul><p>跨越用户交互的事务并发控制是一个有挑战性的任务。应用程序通常实现一种基于采用元组中存储的版本号来验证写操作的机制。这种机制提供了弱可串行化水平，而且可以实现在应用层，而无需修改数据库。</p><p>可以为特殊的数据结构开发特色的并发控制技术。通常，特色的技术用到B+树上，以允许较大的并发性。这些技术允许对B+树进行非可串行化访问，但它们保证B+树结构是正确的，并保证对数据库本身的存取是可串行化的。</p><h3 id="恢复系统"><a href="#恢复系统" class="headerlink" title="恢复系统"></a>恢复系统</h3><p>数据库系统的一个重要组成部分就是恢复机制，它负责检测故障以及将数据库恢复至故障发生前的某一状态。恢复机制必须提供高可用性，必须将数据库崩溃后不能使用的时间缩减到最短。</p><p>计算机中的各种存储器类型有易失存储器、非易失存储器和稳定存储器。易失存储器（如RAM）中的数据在计算机发生故障时会丢失。非易失性存储器（如磁盘）中的数据在计算机发生故障时一般不丢失，只是偶尔由于某些故障如磁盘故障才会丢失。稳定存储器中的数据从不丢失。</p><p>必须能联机访问的稳定存储器用镜像磁盘或RAID的其他形式模拟，它提供冗余数据存储。脱机或归档稳定存储器可能是数据的多个磁带备份，并存放在物理安全的地方。</p><p>一旦故障发生，数据库系统的状态可能不再一致，即它不能反映数据库试图保存的显示世界的状态。为保持一致性，我们要求每个事务都必须是原子的。恢复机制的责任就是要保证原子性和持久性。</p><p>在基于日志的机制中，所有的更新都记入日志，并存放在稳定存储器中。当事务的最后一个日志记录，即该事务的commit的日志记录。输出到稳定存储器时，就认为这个事务已提交。</p><p>日志记录包括所有更新过的数据项项的旧值和新值。当系统崩溃后需要对更新进行重做时，就使用新值。如果在正常操作中事务中止，回滚事务所做的更新时需要用到旧值；在事务提交之前发生系统崩溃的情况下，回滚事务所做的更新也需要用到旧值。</p><p>在演出修改机制下，事务执行时所有write操作都要延迟到事务提交时才执行，那时，系统在执行延迟写中会用到日志中与该事务有关的信息。在延迟修改机制中，日志记录不需要包含已更新的数据项的旧值。</p><p>为减少搜索日志和重做事务的开销，我们可以使用检查点技术。（a）在执行检查点操作的过程中不允许执行任何更新，（b）在执行检查点的过程中将所有更新过的缓冲块都输出到磁盘中。检查点执行过程如下：1、将当前位于主存的所有日志记录输出到稳定存储器；2、将所有修改的缓冲块输出到磁盘；3、将一个日志记录<checkpoint l>输出到稳定存储器，其中L是执行检查点时正活跃的事务的列表。</checkpoint></p><p>当前恢复算法基于重复历史的概念，在恢复的重做简单重演（自最后一个已完成的检查点以来）正常操作中所做的所有动作。重复历史的做法将系统状态恢复到系统崩溃之前的最后一个日志记录输出到稳定存储器时的系统状态。然后从这个状态开始执行一个撤销阶段，反向处理未完成事务的日志记录。</p><p>不完全事务的撤销写出特殊的redo-only日志记录和一个abort日志记录。然后就认为该事务已完成，不必再对它进行撤销。</p><p>在事务处理所基于的存储模型中，主存储器中有一个日志缓冲区，一个数据库缓冲区和一个系统缓冲区。系统缓冲区中有系统目标码页面和事务的局部工作区域。</p><p>恢复机制的高效实现需要尽可能减少向数据库和稳定存储器写出的数目。日志记录在开始时可以保存在易失性的日志缓冲区中，但是当下述情况之一发生时必须写到稳定性存储器中：</p><ul><li>在&lt;T(i), commit&gt;日志记录可以输出到稳定存储器之前，在事务T(i)相关的所有日志记录必须已经输出到稳定存储器中。</li><li>在主存中的一个数据库输出到（非易失性存储器中的）数据库之前，与该块中的数据相关的所有日志记录必须已经输出到稳定存储器中。</li></ul><p>当前的恢复技术支持高并发性封锁技术，例如用户B+树并发控制的封锁记录。这些技术允许提前释放通过插入或删除这样的操作获得的低级别的锁，低级别的锁允许别的事务其他的这些操作可以执行。低级别的锁被释放之后，不能进行物理undo，而需要进行逻辑undo，例如，用删除来对一个插入操作undo。事务保持高级别的锁以确保并发的事务不会执行这样的动作，它可能导致一个操作的逻辑undo是不可能的。</p><p>为从造成非易失性存储器中数据丢失的故障中恢复，我们必须周期性地将整个数据库的内容转储到稳定存储器中–例如每天一次。如果发生了导致物理数据库块丢失的故障，我们使用最近一次转储将数据库恢复至前面的某个一致状态。一旦完成该恢复，我们再用日志将数据库系统恢复至最当前的一致状态。</p><p>ARIES恢复机制支持一些提供更大并发性，削减日志开销和最小化恢复时间的特性。它也是基于重复历史的，并允许逻辑undo操作。该机制连续不断地清洗页，从而不需要检查点时清洗所有页。它使用日志顺序号（LSN）来实现各种优化从而减少恢复所花的时间。从系统崩溃中恢复的过程经历三个阶段：1、分析阶段：决定哪些事务要撤销，哪些页在崩溃时时脏的，以及重做阶段应从哪个LSN开始；2、redo阶段：从分析阶段决定的位置开始，执行重做，重复历史，将数据库恢复到发生崩溃前的状态；3、undo阶段：回滚在发生崩溃时那些不完全的事务。</p><p>远程备份系统提供了很高程度的可用性，允许事务处理即使在主站点遭受火灾、洪水或地震的破坏时也能继续。主站点上的数据和日志记录连续不断地备份到远程备份站点。如果主站点发生故障，远程备份站点就执行一定的恢复动作，然后接管事务处理。</p><h2 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h2><h3 id="数据库系统体系结构"><a href="#数据库系统体系结构" class="headerlink" title="数据库系统体系结构"></a>数据库系统体系结构</h3><p>集中式数据库系统完全运行在单台计算机上。随着个人计算机和局域网的发展，数据库前端功能不断移向客户机，而后端功能由服务器系统提供。客户-服务器接口协议推动了客户-服务器数据库系统的发展。</p><p>服务器可以是事务服务器，也可以是数据服务器。尽管在提供数据库服务方面，事务服务器的使用大大超过数据服务器的使用。</p><ul><li>事务服务器有多个进程，可能运行在多个处理器上。所以这些进程要访问公共数据，比如数据库缓冲区，系统将这些数据存放在共享内存中。除了处理查询的进程，还有执行诸如锁和日志管理以及检查点等任务的系统进程。</li><li>数据服务器系统提供给用户的是为加工的数据。这样的系统通过把数据和锁高速缓存在客户端，来努力使客户端和服务器之间的通信最小化。并行数据库系统使用类似的优化。</li></ul><p>并行数据库系统由通过高数互联网连接在一起的多台处理器和多张硬盘构成。加速比衡量通过增加并行性可以得到的对单个事务的处理数据的增长。扩展比衡量通过增加并行性可以的带的处理大量事务的能力。干扰、偏斜和启动代价是得到理想的加速比和扩展比的障碍。</p><p>并行数据库系统结构包括共享内存、共享硬盘、无共享以及层次的体系结构。这些体系结构在可扩展性以及通信速度方面各有千秋。</p><ul><li>共享内存的优点在于处理器之间的通信效率极高，存放在共享内存中的数据可以被任何处理器访问，而不需要由软件来移动。共享内存机器的缺点是这种体系结构的规模不能超过32个或64个处理器。因为总线或互联网络会变成瓶颈（因为它是所有处理器共享的）。</li><li>共享硬盘体系结构有两个优点：1、由于每个处理器都有自己的主存储器，因此存储器总线不再是瓶颈了；2、这种体系结构给出了一个经济的方法来提供一定程度的容错性（如果一个处理器或者它的主存储器发生故障，其他处理器可以代替它的工作，这是因为数据库驻留在磁盘上，而磁盘是所有处理器都可以访问的）。虽然存储器总线不再是瓶颈，但与磁盘子系统互连现在成为了瓶颈。</li><li>无共享提供的主要缺点是通信的代价和非本地磁盘访问的代价，这些代价比共享内存或共享硬盘体系结构中的代价要高，因为数据传送涉及两端的软件交互。</li><li>层次的体系结构综合了共享内存、共享硬盘和无共享体系结构的特点。</li></ul><p>分布式数据库系统是部分独立的一组数据库系统，它们共享一个公共模式（理想情况下），并且协调地处理访问非本地数据库的事务。系统之间通过通信网络来相互通信。</p><p>局域网连接分布在小的地理范围内的结点，比如连接单个建筑或几个相邻建筑。广域网连接分布在大的地理范围内的结点。现在Internet是使用最广泛的广域网。</p><p>存储区域网是一种特殊形式的局域网，是为大型存储设备和多台计算机之间提供快速互连而设计的。</p><h3 id="并行数据库"><a href="#并行数据库" class="headerlink" title="并行数据库"></a>并行数据库</h3><p>在I/O并行中，把关系划分到多张可用的磁盘中，从而使检索速度更快。三种常用的划分技术使轮转法划分，散列划分和范围划分。（一般而言，更倾向于使用散列划分和范围划分，而不是轮转法划分）</p><ul><li>轮转法：适合于希望对每个查询顺序地读取整个关系的应用。</li><li>散列划分：适合于机遇划分属性的点查询。</li><li>范围划分：适合于在划分属性上的点查询和范围查询。</li></ul><p>偏斜式一个主要的问题，特别是当并行度增高时。平衡的划分向量、使用直方图以及虚处理器划分是用于减少偏斜的技术。属性值偏斜指的是某些值出现在许多元组的划分属性中。划分偏斜指的是，即使不存在属性值偏斜，划分也可能会出现负载不均衡。</p><ul><li>通过为每个关系的每个属性创建和存储该属性值的频率表或直方图，可以降低由于构建平衡的范围划分向量而产生的I/O开销。</li><li>使用虚处理器，特别是针对范围划分带来的偏斜，可以使偏斜的影响达到最小。核心思想是：即使由于偏斜使得在一个范围内有比其他范围更多的元组，这些元组也将划分到多个虚处理器的范围上。</li></ul><p>在查询间并行中，并发地运行不同的查询以提高吞吐量。共享磁盘系统中协议保证，当事务对页面设置共享锁或排查锁时，能够得到该页面的正确版本：1、事务对一个页面进行任何读或写访问之前，先用相应的共享或排他模式封锁该页面。一旦事务获得了页面的共享锁或排他锁后，它立刻从共享磁盘中读取该页面的最新版本；2、在事务释放一个页面的排他锁之前，它将该页面刷新到共享磁盘中，然后释放锁。</p><p>查询内并行指的是单个查询在多个处理器和磁盘上并行执行，试图减少运行查询的代价。两类查询内并行：1、操作内并行，通过并行地执行每一个运算来加快一个查询的处理速度；2、操作间并行，通过并行地执行一个查询表达式中的多个不同的运算，来加快一个查询的处理速度。</p><p>采用操作内并行来并行地执行关系运算，例如排序和连接。因为关系运算是面向集合的，所以操作内并行对关系运算是很自然的。</p><p>对于像连接这样的二元运算，有两种基本的并行化的方法（这两种并行技术都可以与任何一种连接技术结合使用）：</p><ul><li>在基于划分的并行中，两个关系分成几个部分，而且r(i)中的元组仅与s(i)中的元组进行连接。基于划分的并行仅适用于自然连接和等值连接。</li><li>在分片和复制中，两个关系都被划分，并且每个划分都被复制。在非对称的分片和复制中，一个关系被复制，而另一个关系被划分。与机遇划分的并行不同，分片和复制以及非对称的分片和复制对于任何连接条件都是用。</li></ul><p>在独立的并行中，互不依赖的多个不同的操作按并行方式执行。</p><p>在流水线并行中，处理器在计算一个操作结果的同时将结果发送给另一个操作，无须等待整个操作的完成。</p><p>两个常用启发式方法来减少需要考虑的并行执行计划的数目：</p><ul><li>仅考虑那些利用所有的处理器，对每个运算都并行化，并且不采用任何流水线的执行计划。</li><li>选择最搞笑的串行执行计划，然后将该执行计划中的运算并行化。</li></ul><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布式数据库系统由站点的集合构成，每个站点维护一个本地数据库系统。各个站点能够处理局部事务：这些事务访问的数据仅位于该单个站点上。此外，站点可以参与到全局事务的执行中：这些全局事务访问多个站点上的数据。全局事务的执行需要在站点之间进行通信。</p><p>分布式数据库可能是同构的，其中所有站点拥有共同的模式和数据库系统代码，或者是异构的，其中模式和系统代码可能不同。</p><p>关于在分布式数据库中存储关系涉及几个问题，包括复制和分片。系统应尽量减小用户需要了解关系如何存储的程度。</p><ul><li>水平分片：通过将r的每个元组分给一个或多个分片来划分关系</li><li>垂直分片：通过对关系r的模式R进行分解来划分关系</li></ul><p>数据透明性：</p><ul><li>分片透明性：用户不要求知道关系是如何分片的</li><li>复制透明性：在用户看来，每个数据对象逻辑上都是唯一的。分布式系统可能为了提高系统性能或者数据可用性而复制对象，用户不必关系什么数据对象被复制了，也不必关系副本存放在何处。</li><li>位置透明性：用户无须知道数据的物理位置。只要用户事务提供数据标示符，分布式数据库系统应能够找到任何数据。</li></ul><p>局部事务是那些只在一个局部数据库中访问和更新数据的事务；全局事务是那些多个局部数据库中访问和更新数据的事务。</p><p>每个站点都有其自身的局部事务管理器，其功能是保证在该站点上执行的那些事务的ACID特性。各个事务管理器相互协作以执行全局事务。</p><ul><li>事务管理器：管理那些访问存储在一个局部站点中的数据的事务（或子事务）的执行。注意每个这样的事务既可以是局部事务也可以是全局事务的一部分。<ul><li>维护一个用于恢复目的的日志</li><li>参与到一个合适的并发控制方案，以协调在该站点上执行的事务的并发执行</li></ul></li><li>事务协调器：协调在该站点上发起的各个事务的执行。<ul><li>启动事务的执行</li><li>将事务分成一些子事务，并将这些子事务分派给合适的站点去执行</li><li>协调事务的中止，这可能导致事务在所有站点上都提交或者所有站点上都中止</li></ul></li></ul><p>分布式系统可能遭受与集中式系统相同类型的故障。但是，分布式环境中还有另外一些需要处理的故障，包括站点故障、链路故障、消息丢失以及网络划分。在分布式故障恢复模式的设计中需要考虑每个这样的问题。</p><p>为了保证原子性，执行事务T的所有站点必须在执行的最终结果上取得一致。T要么在所有站点上提交，要么在所有站点上中止。为了保证这一特性，T的事务协调器必须执行一种提交协议。使用最广泛的提交协议是两阶段提交协议。</p><p>两阶段提交协议可能导致阻塞，在这种情况下，事务的命运必须等到故障站点（协调器）恢复后才能确定。为了减少阻塞的可能性，可以使用三阶段提交协议。</p><p>持久消息为分布式事务处理提供了一种可选模式。该模式将单个事务拆分成在不同数据库执行的多个部分。持久消息（无论是否发生故障。都保证正好只传送一次）被传送到需要采取动作的远程站点。虽然需要持久消息避免阻塞问题，但是应用程序开发者必须编写代码来处理各种类型的故障。</p><p>在集中式系统中使用各种并发控制方案修改后可用于分布式环境。</p><ul><li>就封锁协议而言，须做的唯一改变是锁管理器的实现方式。可以采用一个或多个中央协调器。如果拆用分布式锁管理器，复制数据就必须特殊对待。</li><li>处理已复制数据的协议包括主副本协议、多数协议、有偏协议和法定人数同意协议。它们在开销方面和发生故障时工作的能力方面各有不同的取舍权衡。</li><li>就时间戳和有效性演奏方案而言，所需的唯一修改是开发一种产生全局唯一性时间戳的机制。</li><li>许多数据库系统支持延迟复制，其中更新被传播到执行更新的事务的范围之外的副本。这样的工具必须小心使用，因为他们可能导致不可串行化的执行。</li></ul><p>分布式锁管理器环境中的死锁检测需要多个站点之间的合作，因为甚至在没有局部死锁的情况下也可能有全局死锁。</p><p>为了提高可用性，分布式诗句哭必须检测故障，重构系统以使计算机能够继续进行，并在处理器或链路修复之后能够恢复。由于要在网络划分和站点股掌之间进行区分是很困难的，因此这个任务就变得非常复杂。通过使用版本号，可以对多数协议进行扩展使其即使存在故障的情况下仍允许进行事务处理。虽然该协议代价昂贵，但它无论在何种类型的故障下都能工作。可以使用较小代价的协议来处理站点故障，但是它们艰涩不会发生网络划分。</p><p>一些分布式算法需要使用协调器。为了提供高可用性，系统必须维护一个准备好的在协调器故障时能继续其支者的备份副本。另一种方法是在协调器发生故障后选出新的协调器。确定哪个站点应该作为协调器的算法称为选举算法。</p><p>分布式数据库上的查询可能需要访问多个站点。可以使用集中优化技术来识别需要访问的最佳站点集。查询可以依据关系的分片来自动重写没然后可以在每个分片的副本之间做出选择。可以应用半连接技术减少跨不同站点的关系（或相应的分片或副本）连接中所涉及的数据传输。</p><p>异构分布式数据库允许站点有它们自己的模式和数据库系统代码。多数数据库系统提供了一种环境，在其中新的数据库应用可以访问位于多重易购软硬件环境的各个先前存在数据库中的数据。局部数据库系统可以采用不同的逻辑模型以及数据定义和数据操纵语言，并且可以在它们的并发控制和事务管理机制上存在差别。多数据库系统虚拟了逻辑上的数据库集成，不需要物理上的数据库集成。</p><p>为了响应超大规模Web应用对数据存储的需求，近年来在云上构建了大量数据存储系统。这些数据存储系统允许扩展到地里上分布的数千个结点上，而且具有高可用性。然而，它们并不支持通常的ACID特性，而且在划分时以副本一致性为代价来获得可用性。</p><p>目录系统可视为一何总特殊形式的数据库，其中信息按照一种分层的方式组织，类似于文件系统中文件的组织方式。目录通过标准化目录访问协议（例如LDAP）来访问。目录可以分布到多个站点上来提供各个站点的自治。目录可以包含对其他目录的引用，这有助于建立集成视图，借此查询被发送给单个目录，并且在所有相关的目录上透明地执行。</p><h2 id="数据仓库、数据挖掘和信息检索"><a href="#数据仓库、数据挖掘和信息检索" class="headerlink" title="数据仓库、数据挖掘和信息检索"></a>数据仓库、数据挖掘和信息检索</h2><h3 id="数据仓库与数据挖掘"><a href="#数据仓库与数据挖掘" class="headerlink" title="数据仓库与数据挖掘"></a>数据仓库与数据挖掘</h3><p>数据仓库是从多个数据源种进行数据采集，并以一种共同的、统一的数据库模式进行存储的数据仓储。存放在数据仓库中的数据将用于各种复杂聚集和统计分析。</p><p>决策支持系统分析由事务处理系统收集的在线数据，以帮助人们做出商业决策。由于现在大多数组织结构都进行了广泛的计算机化，因此有非常大量的信息可用于决策支持。决策支持系统有不同的形式，包括OLAP系统和数据挖掘系统。</p><p>数据仓库有助于收集和归档重要的操作数据。数据仓库用于基于历史数据的决策支持和分析，例如趋势预测。对来自输入数据源的数据进行清理通常是数据仓库中的一项重要任务。数据仓库的模式一般是多维的，包括一个或一些非常大的事实表以及几个小得多的维表。</p><p>在很多数据仓库应用程序中，面向列的存储系统能提供良好的性能。</p><p><strong>数据挖掘是一个能半自动地分析大型数据库以找出有用的模式的过程。</strong>数据挖掘的引用有许多，比如基于以往示例的数值预测，购买行为关联的发现，以及人和电影的自动聚类。</p><p>分类处理的事：基于训练用例的属性和训练用例实际所属的类，通过利用测试用例的属性来预测测试用例所属类。分类器类型有很多种：</p><ul><li>决策树分类器。这种分类器通过基于训练用例所构造的一棵树来执行分裂，该树的叶节点具有类别标签。对每个测试用例遍历这棵树以找到一个叶节点，该叶节点所属的类即是预测的类。有几种技术可用于构造决策树，其中大部分是基于贪心的启发式方法。</li><li>贝叶斯分类器放入构造比决策树分类器更简单，并且在属性值缺失或为空的情况下工作得更好。</li><li>支持向量机是另一种广泛应用的分类技术。</li></ul><p>关联规则识别经常同时出现的项，比如同一位孤苦可能购买的一些商品。相互关联找出与期望关联等级的偏离。</p><p>其他类型的数据挖掘包括聚类、文本挖掘和数据可视化。</p><h3 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h3><p>信息检索系统用于存储和查询如文档那样的文本数据。与数据库系统相比，它们使用更将蛋的数据模型，但能够在首先的模型里提供更强大的查询能力。</p><p>查询试图通过指定关键字集合来定位用户感兴趣的文档。用户心里所想的查询往往不能精确的表述，因此，信息检索系统基于潜在的相关性对答案的排名。</p><p>相关性排名利用多种类型的信息。1、术语频率：每个术语对美分文档的重要性；2、逆文档频率；3、流行度排名。</p><p>文档相似性用于检索与一个示例文档相似的文档。余弦度量值用于定义相似度，它基于向量空间模型。</p><p>PageRank和链接中心/权威页排名是基于指向页面的链接对页面威望度赋值的两种方法。PageRank度量可以用随机游走模型来直观地理解。锚文本信息也可以用来计算单个关键字意义上的流行度。信息检索系统需要整合多种因素（包括TF-IDF和PageRank）来获得对页面的全局评分。</p><p>搜索引擎作弊试图使一个页面得到高的（但不是应得的）排名。</p><p>同义词和多义词使信息检索的任务复杂化。基于概念的查询旨在找到含有指定概念的文档，而与指定该概念所使用的确切的词（以及语言）无关。本体利用诸如is-a或者part-of这样的关系将概念联系起来。</p><p>倒排索引用来对关键字查询做出应答。</p><p>查准率和查全率是信息检索系统有效性的两种度量。</p><p>Web搜索引擎使用爬虫搜索Web找到网页，然后分析它们以计算其威望度度量，并为它们建立索引。</p><p>目录结构和分类用来将文档和其他相似的文档归类到一起。</p><h2 id="特种数据库"><a href="#特种数据库" class="headerlink" title="特种数据库"></a>特种数据库</h2><h3 id="基于对象的数据库"><a href="#基于对象的数据库" class="headerlink" title="基于对象的数据库"></a>基于对象的数据库</h3><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><h2 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h2><h3 id="高级应用开发"><a href="#高级应用开发" class="headerlink" title="高级应用开发"></a>高级应用开发</h3><p>调整数据库系统参数和更高级别的数据库设计（如模式、索引和事务）对于实现高性能至关重要。查询可以进行调整以提高集合面向性，而批量加载功能可以大大加快数据导入到数据库中的速度。</p><ul><li>调整的最好方法就是确定瓶颈所在，然后消除瓶颈。数据库系统通常有多种可调参数，如缓冲区大小、内存大小和磁盘数量。可以选择适当的缩影和物化试图集合，以使总体代价达到最小。可以调整事务使锁竞争达到最小。快照隔离和支持早起锁释放的序号编号功能是减少读写和写写竞争的有用工具。</li></ul><p>性能基准程序在对数据库系统进行比较方面扮演了重要的角色，尤其在数据库系统变得越来越与标准兼容时。TPC基准程序集使用广泛，不同的TPC基准程序可以用于不同的工作负载下的数据库系统性能比较。</p><p>应用程序在开发时和部署前需要进行大量大测试。测试用来捕获错误的，以及确保到达性能目标。</p><p>遗产系统是基于老一代技术（如非关系数据库或甚至直接基于文件系统）的系统。当运行关键人物系统时，遗产系统与新一代系统之间的连接通常是很重要的。从遗产系统到新一代系统的移植必须非常小心以避免破坏，这种移植是非常昂贵的。</p><p>由于数据库系统的复杂性和互操作的需要，标准对数据库系统来说很重要。SQL有其正式标准。事实标准（如ODBC和JDBC）和被行业组织所采纳的标准（如CORBA），在客户-服务器数据库系统的发展中发挥了重要作用。</p><h3 id="时空数据和移动性"><a href="#时空数据和移动性" class="headerlink" title="时空数据和移动性"></a>时空数据和移动性</h3><p>存储关于真实世界的时间经历状态的信息的数据库叫做时态数据库。</p><p>时态关系中的事实与当它们有效时的时间相关联，而时间可以用时段的并来表示。时态查询语言简化了时间建模以及与时间相关的查询。</p><p>设计数据主要以矢量数据的形式存储；地理数据包含矢量数据和光栅数据的结合。空间完整性约束对于设计数据库十分重要。光栅数据由二维或更高维的位图或像素图组成。矢量数据由基本集合对象构成，如点、线段、折线、三角形和其他二维多边形，以及圆柱体、球体、立方体和其他三维多面体。</p><p>矢量数据库可以编码成第一范式，或者用非第一范式结构来存储，如列表。专用索引结构对于访问空间数据和处理空间查询尤为重要。</p><p>R树是B树的多维扩展；它和它的变体（如R+树和R*树）在空间数据库中得到了广泛的应用。将空间以某种固定方式进行划分和索引结构（如四叉树）有助于处理空间连接查询。</p><h3 id="高级事务处理"><a href="#高级事务处理" class="headerlink" title="高级事务处理"></a>高级事务处理</h3><h2 id="实例研究"><a href="#实例研究" class="headerlink" title="实例研究"></a>实例研究</h2><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><h3 id="IBM-DB2-Universal-Database"><a href="#IBM-DB2-Universal-Database" class="headerlink" title="IBM DB2 Universal Database"></a>IBM DB2 Universal Database</h3><h3 id="Microsoft-SQL-Server"><a href="#Microsoft-SQL-Server" class="headerlink" title="Microsoft SQL Server"></a>Microsoft SQL Server</h3></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/04/20/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E9%A2%86%E5%AF%BC%E5%8A%9B21%E6%B3%95%E5%88%99/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/04/20/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E9%A2%86%E5%AF%BC%E5%8A%9B21%E6%B3%95%E5%88%99/" class="post-title-link" itemprop="url">【笔记】领导力21法则</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-04-20 01:22" itemprop="dateCreated datePublished" datetime="2020-04-20T01:22:00+08:00">2020-04-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-07-25 22:23" itemprop="dateModified" datetime="2020-07-25T22:23:10+08:00">2020-07-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="盖子法则：领导力决定一个人或一个组织的办事效率"><a href="#盖子法则：领导力决定一个人或一个组织的办事效率" class="headerlink" title="盖子法则：领导力决定一个人或一个组织的办事效率"></a>盖子法则：领导力决定一个人或一个组织的办事效率</h3><p>领导力决定了成就的高度。</p><p>相对外界施加更大的影响，就必须具备更大的影响力。</p><p>要想改变一个组织的发展方向，那就换一个领导人。</p><p>个人和组织的办事效力与领导力成正比。</p><p>领导力主要体现在：人际交往能力；规划能力和战略思维；远见卓识；业绩。</p><h3 id="影响力法则：衡量领导力的真正尺度是影响力"><a href="#影响力法则：衡量领导力的真正尺度是影响力" class="headerlink" title="影响力法则：衡量领导力的真正尺度是影响力"></a>影响力法则：衡量领导力的真正尺度是影响力</h3><p>领导力的本质恰恰就是影响力。</p><p>真正的领导力来自一个人的影响力，而影响力是无法被委任的。</p><p><strong>管理者不是领导者。领导是指影响他人，让他人追随自己，而管理关注的焦点是维持既定系统和流程。管理者把握既定的前进方向，无法改变这个方向。领导者负责带领方向。</strong></p><p>要成为领导者，一个人不仅要走在前面，还要有人愿意跟着他走，愿意服从他的领导，并且愿意采取行动去实现他描绘的愿景。</p><p>不是职位造就了领导者，而是领导者造就了职位。</p><p>衡量领导力的真正尺度只能是影响力，不可能是其他任何因素。</p><p>所有影响力的本质都在于让别人参与其中。</p><h3 id="过程法则：领导力的提升是日积月累的结果，而非一日之功"><a href="#过程法则：领导力的提升是日积月累的结果，而非一日之功" class="headerlink" title="过程法则：领导力的提升是日积月累的结果，而非一日之功"></a>过程法则：领导力的提升是日积月累的结果，而非一日之功</h3><p>领导者都是善于学习的人。自我发展和不断提升自身的技能水平，这正是领导者和其追随者的最本质的区别。</p><p>领导力提升的几个阶段：</p><ol><li>不知道你不知道（不知道领导力的价值与重要性）；</li><li>知道自己需要知道；</li><li>知道自己不知道；</li><li>我知道，我成长，我发现（努力成长）；</li><li>因为我知道（时刻做好准备，等待机会的到来）。</li></ol><h3 id="导航法则：谁都可以掌舵，唯有领导者才能设定航线"><a href="#导航法则：谁都可以掌舵，唯有领导者才能设定航线" class="headerlink" title="导航法则：谁都可以掌舵，唯有领导者才能设定航线"></a>导航法则：谁都可以掌舵，唯有领导者才能设定航线</h3><p>领导者就是看得比别人过，看得比别人远，在别人看到之前看到的人。导航者会依靠过去的经验；导航者在作出承诺前会考察各种情况；导航者会听从他人的意见；导航者会确定自己的结论是信念和事实的结合。</p><p>完成事件的预先计划：</p><ol><li>预先制定行动计划</li><li>列出目标</li><li>设定优先次序</li><li>告知关键人物</li><li>预留时间征得同意</li><li>开始行动</li><li>预测将会出现的问题</li><li>始终明白成功的方向</li><li>每日对计划进行回顾</li></ol><h3 id="增值法则：领导者为他人提升价值"><a href="#增值法则：领导者为他人提升价值" class="headerlink" title="增值法则：领导者为他人提升价值"></a>增值法则：领导者为他人提升价值</h3><p>光想给自己邀功是不行的，因为一个组织的成功来自众人的共同努力。</p><p>领导力的底线不在于我们自己能够走多远，而在于我们能够让别人走多远。</p><p>为他人增加价值的三种基本方针：</p><ol><li>当真正重视他人的时候，我们增加了他人的价值；</li><li>当使自己成为更加令人敬佩的人时，我们增加了他人的价值；</li><li>当知道别人重视什么并且努力做到时，我们增加了他人的价值。</li></ol><p>没有经验的领导者往往在了解他们将要领导的人之前就急于开始工作，而成熟的领导者会去倾听、了解，然后再开展工作。</p><p><strong>优秀领导力的重要因素之一：与其他人没有尚未解决的关系矛盾。</strong></p><h3 id="根基法则：信任是领导力的根基所在"><a href="#根基法则：信任是领导力的根基所在" class="headerlink" title="根基法则：信任是领导力的根基所在"></a>根基法则：信任是领导力的根基所在</h3><p>重要的不是决定，而是领导力。</p><p>在领导方式上，无论你领导他们多久了，你都不能走捷径。</p><p>要赢得信任，领导者必须表现出工作能力、亲和力和性格优势。</p><p>品格是信任的根基，而信任是领导力的根基。这就是根基法则。</p><p>品格彰显潜力。品格彰显尊重。</p><p>领导者如何赢得尊重呢？通过做出英明决策，承认自己的错误，把追随者和组织的利益放在个人利益之前。</p><p>领导人的优秀品质能够赢得追随者的信任。但如果一个领导者破坏了这种信任，那么他就丧失了领导的能力。</p><p>没有一位领导者能够在失去追随者的信任之后仍然保持自己对他们的影响力。信任是领导力的根基。违反了根基法则，作为领导人的影响就会减弱。</p><h3 id="尊重法则：人们通常愿意追随比自己强的领导者"><a href="#尊重法则：人们通常愿意追随比自己强的领导者" class="headerlink" title="尊重法则：人们通常愿意追随比自己强的领导者"></a>尊重法则：人们通常愿意追随比自己强的领导者</h3><p>一个人的领导力越强，就能越快发现别人的领导力潜质，或者发现别人领导力的不足。</p><p>领导者赢得别人的尊敬的最重要的六个方面：1、天生的领导才能；2、尊重他人（如果坚持尊重他人，始终如一地好好领导他们，你就会一直拥有追随者）；3、勇气（作为领导者，除非他愿意偶尔孤军奋战，否则就是名不副实的）；4、成功（即领导者在某个领域的成功）；5、忠诚；6、为他人增加价值。</p><p>领导力的衡量标准之一就是选择追随者的才干。</p><h3 id="直觉法则：领导者善用领导直觉评估每件事情"><a href="#直觉法则：领导者善用领导直觉评估每件事情" class="headerlink" title="直觉法则：领导者善用领导直觉评估每件事情"></a>直觉法则：领导者善用领导直觉评估每件事情</h3><p>每个人自己善长的直觉。</p><p>领导者是当前情况的考察者。领导者是动向的考察者。领导者是自身资源的考察者（想要获取成功的领导者要最大限度地利用每一份资产和资源，从而实现整个组织的利益）。领导者是他人的考察者（读懂别人也许是领导者应该具有的最重要的直觉能力）。领导者是自身的考察者（领导者必须了解的不仅仅是自己的优势和弱势、能力和缺点，还有自己当前的心理状态）。</p><p>思考一下问题：</p><ul><li>谁是负责这个问题的最佳人选？</li><li>我们拥有何种资源能够帮助自己？</li><li>解决这一问题需要多少资金？</li><li>我们如何激励团队成员取得成功？</li></ul><h3 id="吸引力法则：你只能吸引和你相似的人"><a href="#吸引力法则：你只能吸引和你相似的人" class="headerlink" title="吸引力法则：你只能吸引和你相似的人"></a>吸引力法则：你只能吸引和你相似的人</h3><p>你所吸引的人不是由你的愿望决定的，而是由你的为人决定的。</p><p>团队“必然”成为领导者个性的延伸。</p><h3 id="亲和力法则：领导者深知，得人之前必先得其心"><a href="#亲和力法则：领导者深知，得人之前必先得其心" class="headerlink" title="亲和力法则：领导者深知，得人之前必先得其心"></a>亲和力法则：领导者深知，得人之前必先得其心</h3><p>优秀的领导者总是设法与别人建立亲和力，不论他们是整个组织作为交流还是与单独的个人共事。</p><p>与追随者的关系和感情越牢固，他们就越可能会去帮助领导者。</p><p>在人群中建立亲和力的秘诀就是把他们当作不同的个体来看待。</p><p>如何建立亲和力：</p><ol><li>展现真我</li><li>坦率真诚</li><li>了解对象</li><li>身体力行</li><li>身临其境（适应他人，而不是指望别人来适应我）</li><li>关注他们，而不是你自己</li><li>信任他人（向别人传达信息与和别人沟通不同。前者是因为你相信自己会说出一些有价值的话，后者是因为你相信他们有价值）</li></ol><p><strong>主动与别人建立亲善关系，这就是领导者的职责。</strong></p><p>别人不会在乎你知道多少，除非他们知道你多么在乎他们。</p><p>引领自己，要用脑；引领别人，要用心。</p><h3 id="核心圈法则：一个领导者的潜力，由最接近他的人决定"><a href="#核心圈法则：一个领导者的潜力，由最接近他的人决定" class="headerlink" title="核心圈法则：一个领导者的潜力，由最接近他的人决定"></a>核心圈法则：一个领导者的潜力，由最接近他的人决定</h3><p>只有在你发挥出作为领导者的潜力后，你的追随者才有机会发挥他们的潜力。</p><p>考虑人选是否应当进入你的核心圈：</p><ul><li>他们对其他人是否有很大影响</li><li>他们能否给团队带来互补性的才能</li><li>他们在团队里是否担任要职</li><li>他们能否增加我和团队的价值</li><li>他们能否给核心圈的其他成员带来积极性的影响</li></ul><h3 id="授权法则：有安全感的领导者才会授权予人"><a href="#授权法则：有安全感的领导者才会授权予人" class="headerlink" title="授权法则：有安全感的领导者才会授权予人"></a>授权法则：有安全感的领导者才会授权予人</h3><p>最好的主管懂得找到人才来做好计划的工作，而且又能克制自己在过程中不横加干涉。</p><p>成功的领导不是关乎充实自己——而是关乎授权给他人。</p><p>人才是否能发挥潜能，决定于领导者的授权能力。</p><p>授权的障碍：</p><ul><li>渴望工作上的安全感</li><li>抗拒改变</li><li>缺乏自己肯定（凡是最优秀的领导者都非常自信）</li></ul><p>伟大的领导者通过授予权利来获得权力。</p><h3 id="镜像法则：看到别人怎么做，大家也会怎么做"><a href="#镜像法则：看到别人怎么做，大家也会怎么做" class="headerlink" title="镜像法则：看到别人怎么做，大家也会怎么做"></a>镜像法则：看到别人怎么做，大家也会怎么做</h3><p>伟大的领导者好像一直都表现出两种似乎截然不同的特质。他们很有思想但都非常实际。</p><p>领导者通过对愿景的有效示范把镜像变成现实。</p><ol><li>下属总是在观察你的所作所为</li><li>教正确的事总比做正确的事容易（领导者通常只是说教，只有在他们真正实践的时候，才算是授权）</li><li>提升他人之前，应该首先改变自己</li><li>领导者能给下属的最宝贵的东西就是一个好的榜样</li></ol><p><strong>领导就是示范。</strong></p><h3 id="接纳法则：人们先接纳领导者，然后接纳他描绘的愿景"><a href="#接纳法则：人们先接纳领导者，然后接纳他描绘的愿景" class="headerlink" title="接纳法则：人们先接纳领导者，然后接纳他描绘的愿景"></a>接纳法则：人们先接纳领导者，然后接纳他描绘的愿景</h3><p>领导者先找到目标，然后才找到一群追随者。而普通人却是先找到领导者，然后才认同领导者的目标。</p><h3 id="制胜法则：领导者为他的团队找出一条制胜之路"><a href="#制胜法则：领导者为他的团队找出一条制胜之路" class="headerlink" title="制胜法则：领导者为他的团队找出一条制胜之路"></a>制胜法则：领导者为他的团队找出一条制胜之路</h3><p>渴望获胜的领导者都是有不服输的决心。他们完全不能接受失败。</p><p>胜利的要素：</p><ol><li>统一的目标</li><li>多样化的技能</li><li>一位愿为胜利而献身、致力于发挥队员潜能的领导者</li></ol><h3 id="动势法则：动势是领导者最好的朋友"><a href="#动势法则：动势是领导者最好的朋友" class="headerlink" title="动势法则：动势是领导者最好的朋友"></a>动势法则：动势是领导者最好的朋友</h3><p>在一个具有动势的组织内，即使是普通人也能超水平表现自我。</p><p>只有领导者创造出动势（目标、激情、热忱）。</p><p>领导者总是在想方设法找到那条通往成功的道路。</p><p>激励是创造动势的关键因素。</p><h3 id="优先次序法则：领导者明白，忙碌不一定等于有效"><a href="#优先次序法则：领导者明白，忙碌不一定等于有效" class="headerlink" title="优先次序法则：领导者明白，忙碌不一定等于有效"></a>优先次序法则：领导者明白，忙碌不一定等于有效</h3><p>3R法则：必要的分内事情，回报效益高的事情，回报大的事情。</p><p>领导者们应该走出那些他们感到舒适的领域，而去那些可以发挥他们优势的领域。</p><h3 id="舍得法则：领导者必须先“舍”后“得”"><a href="#舍得法则：领导者必须先“舍”后“得”" class="headerlink" title="舍得法则：领导者必须先“舍”后“得”"></a>舍得法则：领导者必须先“舍”后“得”</h3><p>出色领导的精髓就是牺牲。</p><p>牺牲是一种持续的过程，而非一次性付出。</p><p>如果领导者必须有所“舍”，才能有所“得”。那么你想继续留在高位就得有更多的舍弃。</p><h3 id="时机法则：掌握时机与善用策略同样重要"><a href="#时机法则：掌握时机与善用策略同样重要" class="headerlink" title="时机法则：掌握时机与善用策略同样重要"></a>时机法则：掌握时机与善用策略同样重要</h3><p>良好的领导时机需要很多条件：</p><ol><li>认识——领导者必须对局势有清楚的认识</li><li>成熟——领导者的动机不正确，也就不会有良好的时机</li><li>信心——人们往往追随心里有谱的领导者</li><li>果断——优柔果断的领导者培养出优柔果断的下属</li><li>经验——如果领导者毫无经验，那么他们需要从其他有经验的人那里汲取经验</li><li>直觉——时机通常是由一些抽象的东西决定的，比如动势和士气</li><li>准备——如果条件不适合，领导者必须创造条件</li></ol><p>当正确的领导者遇上了正确的时机，就会产生令人振奋的结果。</p><h3 id="爆炸性倍增法则"><a href="#爆炸性倍增法则" class="headerlink" title="爆炸性倍增法则"></a>爆炸性倍增法则</h3><p>培养追随者，得到相加的效果</p><p>培养领导者，得到倍增的效果</p><h3 id="传承法则：一个领导者的长久价值由其继承者决定"><a href="#传承法则：一个领导者的长久价值由其继承者决定" class="headerlink" title="传承法则：一个领导者的长久价值由其继承者决定"></a>传承法则：一个领导者的长久价值由其继承者决定</h3><p>传承乃是领导的一项主要责任。</p><h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>凡事之兴衰成败皆系于领导力。</p><ol><li>人才决定组织的潜力</li><li>关系决定组织的士气</li><li>结构决定组织的规模</li><li>目标决定组织的方向</li><li>领导决定组织的成败</li></ol><hr><p>读《领导力21法则》</p><p>推荐指数：10 / 10</p><p>两年后再读。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/03/14/Golang-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Golang 协程调度原理</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-03-14 23:37" itemprop="dateCreated datePublished" datetime="2020-03-14T23:37:00+08:00">2020-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-11-25 23:54" itemprop="dateModified" datetime="2020-11-25T23:54:19+08:00">2020-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>Golang协程整体架构如图：</p><p><img src="/2020/03/14/Golang-协程调度原理/G_P_M.jpg" alt="G-P-M架构"></p><ul><li>G：协程</li><li>M：操作系统的抽象对象；</li><li>P：逻辑处理器</li></ul><p>执行过程基本是：一个M，绑定一个P后，进入调度执行，不断执行P获取到的G。</p><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><h4 id="G-M-模型"><a href="#G-M-模型" class="headerlink" title="G-M 模型"></a>G-M 模型</h4><p>Golang在开始发布的时候采用了G-M模型</p><p><strong>缺点</strong>：限制了Go并发程序的伸缩性</p><ol><li>单一全局互斥锁（Sched.Lock）和集中状态存储 导致所有goroutine相关操作都需要上锁（比如创建、重新调度）</li><li>goroutine传递问题，M之间传递可运行的G，导致调度延迟增大以及额外的性能损耗</li><li>每个M做内存缓存，导致内存占用过高，数据局部性较差</li><li>由于syscall调用而形成的剧烈的worker thread阻塞和解除阻塞，导致额外的性能损耗</li></ol><h4 id="G-P-M模型"><a href="#G-P-M模型" class="headerlink" title="G-P-M模型"></a>G-P-M模型</h4><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p>在G-M之间加入一个中间层解决，P代表逻辑CPU。</p><p><strong>缺点</strong>：不支持抢占式调度，导致一旦某个G中出现死循环或永久循环的代码逻辑，那么G将永久占用分配给它的P和M，位于同一个P中的其他G将得不到调度，出现“饿死”的情况</p><h4 id="Go1-2实现抢占式调度"><a href="#Go1-2实现抢占式调度" class="headerlink" title="Go1.2实现抢占式调度"></a>Go1.2实现抢占式调度</h4><p>原理是在每个函数或方法的入口，加上一段额外的代码，让runtime有机会检查是否需要执行抢占调度</p><p><strong>缺点</strong>：局部解决了“饿死”问题，对于没有函数调用，纯算法循环计算的G，scheduler依然无法抢占</p><h4 id="NUMA调度模型"><a href="#NUMA调度模型" class="headerlink" title="NUMA调度模型"></a>NUMA调度模型</h4><p>暂未实现</p><h3 id="G-P-M-模型详细分析"><a href="#G-P-M-模型详细分析" class="headerlink" title="G-P-M 模型详细分析"></a>G-P-M 模型详细分析</h3><p>要搞懂<code>G-P-M模型</code>的详细架构，那么要解决接下来的这些问题：</p><ul><li>M的创建时间点？</li><li>P的创建时间点？</li><li>G的创建时间点？</li><li>G的调度方式，如何保证公平？</li></ul><p>我们抱着这些疑问来详细分析。</p><p>首先，Golang程序是怎么启动的呢？启动时做了如下这些事情：</p><ol><li>初始化固定数量的P（默认为cpu核心数）</li><li>创建一个新的G来启动<code>runtime.main</code></li><li>创建全局 M0、全局 G0，启动 M0 进入第一个调度循环</li></ol><blockquote><ul><li>其中：</li><li>M0：代表第一个启动的M</li><li>GO：执行runtime调度，每个M都会绑定一个G0</li></ul></blockquote><p>首先，对于一个Golang的程序，最多可以并发的<strong>线程</strong>数，是初始化的P的个数。在设计上，通过P的数量限制并发的线程数。</p><p>第二点，在Golang中，首先启动的协程是通过<code>runtime.main</code>启动的，然后进行一些初始化和准备，最终调用<code>main.main</code>方法。</p><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>在哪些情况下回创建M呢？</p><ul><li>当P中存在没有绑定的M，且有需要支持的G时，则尝试绑定一个M（创建或者绑定已有）。</li></ul><p>M的启动过程：</p><ol><li>获取空闲的P</li><li>尝试获取空闲的M，如果没有则新建一个（新建M的时候，会创建一个一个G0）</li><li>将M和P绑定</li><li>启动，进入调度循环<ol><li>从本地队列获取一个G，没有则从其他地方获取<br>每处理一些任务之后，就优先从全局队列里获取任务，以保障公平性，防止由于每个P里的G过多，而全局队列里的任务一直得不到执行机会</li><li>执行G</li></ol></li></ol><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>P代表逻辑处理器。P在初始化时，根据CPU的核心数或者环境变量GOMAXPROCS（有最大限制），创建对应个数的P。</p><p>可以通过<code>runtime.GOMAXPROCS()</code>重新设置了最大 CPU 使用数量。</p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>系统中一共有哪些G呢？</p><ol><li><p>gofunc创建创建的</p><p>基本方式为：从当前P中找一个空闲的G，没有则新建一个；放入当前P的队列；唤醒M开始执行。</p></li><li><p>epoll</p><p>从内核中获取到一些事件，拿到了有收到就绪的 FD。再将对应的G唤醒标记为ready，同时将这些G放入全局的等待队列。</p></li><li><p>每个M绑定的G0</p></li></ol><p><strong>G是怎么创建并进入调度流程的呢？</strong></p><p>首先何为调度：调度就是决定何时哪个goroutine将获得资源开始执行、哪个goroutine应该停止执行让出资源、哪个goroutine应该被唤醒恢复执行等。</p><p>G创建与进入调度流程如下：</p><ol><li>从当前P中复用一个G</li><li>如果没有，则新建一个G</li><li>给G的执行环境里的 pc 变量赋值了一个 goexit 的函数地址，也就是说G正常执行完退出时执行的是 goexit 函数（切换到G0下释放G，并放置回P的本地队列中）</li><li>尝试将G添加到当前P的runnext中，作为下一个执行的G</li><li>否则放到Local队列runq中(无锁)</li><li>如果以上操作都失败，则添加到Global队列sched.runq中(有锁操作，因此也会顺便将当P.runq中一半的G转移到sched.runq)</li></ol><p><strong>那么当前协程如何让出CPU？</strong></p><ol><li><p>G正常退出</p><p>G中会指定一个退出函数，当退出时调用该函数（退出函数是，将函数栈切换到了G0，释放G）</p></li><li><p>主动让出</p><p>即临时停止或阻塞，需要让出CPU（如time.sleep、IO阻塞等）（挂起当前G）(gopark进行调度让出CPU资源。切换到G0下，保存当前的G的函数栈等信息，并修改G的状态为等待（表明正在等待唤醒）)。</p></li><li><p>主动抢占</p><p>runtime.main中有一个监控任务，sysmon方法。</p><blockquote><p>超过10ms还在执行的G将会被抢占，只是做一个标记，实际抢占发生在栈扩张的时候（下个函数或方法调用时，判断是否栈不够，不够则扩张）（小函数优化：不进行校验）</p><p>调用函数时，准确的说是在分配函数栈时抢占</p></blockquote></li><li><p>系统调用让出</p><p>G进入系统调用时，会保存上下文，标记为“系统调用状态”，等待被抢占走。系统调用退出时，则通过G0下将G切回来，如果有可执行的P，则执行，没有则放全局队列，等待调度。</p></li></ol><p>上诉4种G让出CPU的方式。下面列出多种<strong>主动让出</strong>的场景：</p><ol><li><p>time.Sleep</p><ul><li>休眠：将计时器加入到timer管理器中，通过goparkunlock实现当前G的休眠</li><li>唤醒：将休眠的G标记为可运行状态，并放入P的待运行队列中</li></ul></li><li><p>Mutex</p><p>通过goparkunlock方法进入休眠，并加入到root.queue队列等待唤醒</p></li><li><p>channel</p><p>当给一个 chan 发送消息的时候，实质触发的方法是 chansend。在该方法里不是先进入休眠状态。</p><ol><li>如果此时有接收者收到这个消息，则直接将通过send方法直接发送给接收者，并唤醒接收者G，当前发送者G继续执行</li><li>如果没有接收者，将数据copy到chan的临时内存中，且内存没有满则继续执行该G</li><li><p>如果没有接收者且chan满了，通过goparkunlock进入休眠。休眠前把当前的G相关信息存到队列（sendq）以便有接收者接收数据的时候唤醒当前G。</p><blockquote><p>唤醒发送者：</p><ul><li>如果发送者被休眠，则取出数据然后唤醒发送者，当前接收者的G拿到数据继续执行</li><li>如果没有休眠的发送者，则看一下是否有已经发送的数据没有被接收，有则直接取数据继续执行（直接从chan的内存取）</li><li>如果既没有休眠的发送者，chan中也没有数据，则通过goparkunlock休眠，放入recvq队列中，等待唤醒</li></ul></blockquote></li></ol></li></ol><p>在<strong>主动抢占</strong>中提到，通过监控任务sysmon来执行监控工作，协助抢占。那么sysmon究竟有哪些作用呢？</p><p>sysmon是一个由runtime启动的M，监控线程，无需P也可以运行，每20us~10ms唤醒一次</p><p><strong>sysmon作用</strong>：</p><ul><li>释放闲置超过5分钟的span物理内存</li><li>如果超过2分钟没有垃圾回收，强制执行</li><li>将长时间未处理的netpoll结果添加到任务队列</li><li>向长时间运行的G任务发出抢占调度</li><li>收回因syscall长时间阻塞的P</li></ul><p>主动抢占发生在函数栈调用时，准确讲为栈扩张的时候。那么栈何时扩张，以及扩张是一个怎么样的流程？</p><p>栈扩张：基本过程就是分配一个2x大小的新栈， 把数据拷贝到新栈，并用新栈替换到旧栈。栈缩容：由垃圾回收器在垃圾回收时主动触发的。基本过程是计算当前使用的空间，小于栈空间的1/4的话， 执行栈的收缩，将栈收缩为现在的1/2，否则直接返回。</p><p>在 runtime 下会启动一个全程运行的监控任务，该任务用于标记抢占执行过长时间的G，以及检测 epoll 里面是否有可执行的G。</p><p>netpoll是Go针对网络IO的一种优化，本质上为了避免网络IO陷入系统调用之中，这样使得即便G发起网络I/O操作也不会导致M被阻塞（仅阻塞G），从而不会导致大量M被创建出来。</p><p>G的几种暂停方式：</p><ol><li>gosched: 暂停当前G，保存状态并将G设置为可运行状态放入Global队列，当前M继续执行。</li><li>gopark: 暂停后，设置为等待状态，放入专门的等待队列</li><li>notesleep: 既不让出M，也不让G与P重新调度，直接让线程休眠直到唤醒（notewakeup）,该方式更快，通常用于gcMark，stopm这类自旋场景</li></ol><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul><li><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/" target="_blank" rel="noopener">也谈goroutine调度器</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&amp;mid=2247487174&amp;idx=1&amp;sn=a716cc5cc48b7cf6078698942a6c6c18&amp;source=41%23wechat_redirect" target="_blank" rel="noopener">从源码角度看 Golang 的调度</a></li><li><a href="https://zhuanlan.zhihu.com/p/42057783" target="_blank" rel="noopener">Head First of Golang Scheduler</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/02/27/%E6%88%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/02/27/%E6%88%91/" class="post-title-link" itemprop="url">我</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-27 23:22 / 修改时间：23:28" itemprop="dateCreated datePublished" datetime="2020-02-27T23:22:00+08:00">2020-02-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2020/02/27/我/happy.jpeg" alt></p><p>我是一个无趣的人吧。</p><p>回想起来，我从开始，是一个内向的人，不爱说话，其实只是没有话题，不知道说些什么，也不喜欢说一些没用的话。后来开始长大了吧，或许有些开始变得唠叨了，当然有时也更加不愿意说更多的话，不愿意发不同的言。</p><p>在大三后，可能突然醒悟了，开始觉得，不管什么事，尽可能地用微笑去面对它，哪怕它让你有一种心碎了一地的感觉，以至于有人说我有点喜形不于色。其实我开始觉得我不应该生气的，不管遇到什么事，都不应该生气，淡然处之，或许是一种没有情调的表现，但些许时候，我明白真正看透因果。</p><p>我受过伤，心里的伤，从没有一次表现出来。有时候觉得我自己很傻，为什么在同一个地方伤了后，却义无反顾地再次一头扎进伤痛里，笑着对别人说没事。别人总当我是一个没事的人。所以我很傻。但是像我这种从不会告诉别人我受伤的人，永远不会被同情的——人根本就不应该博取同情，对我而言，那是自己的一种软弱。</p><p>在踏入这世间时，我才开始有点在乎，我与这世间有点不适应。人从来就不是跟从理想去做的事，而是跟从生活去做的事。这个社会，太过于浮躁，以至于在我在社会上待了半年后，也变得浮躁了。我发现我喜欢的事闲适的生活，</p><p>我理解了阅读的重要性，不管是否是关乎自己的职业、技术等书籍，阅读都能够让我沉静下来，让我的思维在时间里停下来。</p><p>我明白我不可能脱离这个世界的限制，我不可能做到不像着普通年轻人一样，负着高压、负着贷款，夜以继日的努力，并不是为了什么理想，而仅仅是为了活着，为了完成人所被这个社会强加的意愿。</p><p>以前学过，“人固有一死，或重于泰山，或轻于鸿毛“。其实一直觉得，对我而言，人死了，就什么都没有了，我能过的就是这一个人生，并没有任何必须要去完成的义务，只是我们选择了一些我们想要去完成的事。这些应该称为理想。</p><p>我现在是一个什么样的人，我总是在想，我应该成为什么样的人。</p><p>我喜欢文学，却没有才华。喜欢码字，只是因为有情感。我曾说，我写的不是文，只是情，是一种我自己的诉说。我羡慕那种可以写出好文章的人，因为我写不出。</p><p>我喜欢纯音乐，我或许是一种怪人，以前可以听着纯音乐到泪眼。我一直说，每一个偏好纯音乐的人，都是一个有故事的人。</p><p>我喜欢吃美食，但没有吃出花样，不明白怎么才能更加美味。</p><p>我喜欢哲学，并不是哲学上的那种辩论，而仅仅指那种对于哲学的思考，可以启发我的思维上的进化。我理解世间万事，终究所有道理都可以相通的。</p><p>我是一个程序员，有着程序员的大多数的特点。我一直认为我专心写代码的时候很开心，后来才明白，我开心并非因为我在写代码，而是因为做一件事，并沉浸其中很开心。</p><p>我是狮子座的，我看过只觉得有部分分析其实也挺符合我，有人说非常符合我，我可能身处青山不见山吧。</p><p>我是一个比较宅的人，并不是喜欢宅。只是只有自己，不喜欢出去，有一种形单影只的独自悲伤。亟待一个能够带我出去浪的朋友。</p><p>我记忆力不够，所以我从来都是用着笔记本以及手机同时记事的，不管是什么事，或许也是因为自己怕忘了。</p><p>曾经的我喜欢历史，因为觉得历史很有趣，因为觉得历史里，总有一些精髓与要义能够在生活中使用。后来没那么喜欢历史里，因为没有一个历史是讲诉平凡人一生的。历史里，每一个波动，对于平凡人而已，都是悲惨的。</p><p>我不会音律，没有一个擅长的乐器，是我一直挺遗憾的，想学葫芦丝。</p><p>我喜欢打乒乓球，不在乎输赢，只在乎尽兴与运动时的优美。</p><p>我应该是一个不喜笑的人，一个不发火的人。心里住着一个个人的世界吧。</p><p>我好像还有很多特点，我都忘了。</p><p><strong>补上我的2020目标：</strong></p><p><img src="/2020/02/27/我/2020.jpeg" alt="2020"></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2020/02/23/%E8%AF%BB%E3%80%8A%E9%BB%84%E9%B9%A4%E6%A5%BC%E3%80%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/02/23/%E8%AF%BB%E3%80%8A%E9%BB%84%E9%B9%A4%E6%A5%BC%E3%80%8B/" class="post-title-link" itemprop="url">读《黄鹤楼》</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-23 10:26" itemprop="dateCreated datePublished" datetime="2020-02-23T10:26:00+08:00">2020-02-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-02-24 12:22" itemprop="dateModified" datetime="2020-02-24T12:22:45+08:00">2020-02-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>黄鹤楼前《黄鹤楼》，</p><p>倒却鹦鹉捶碎楼。</p><p>不闻崔诗塞上榜，</p><p>古吟今叹鹦鹉洲。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/12/31/%E8%B5%B0%E7%9D%80%EF%BC%8C%E8%B5%B0%E7%9D%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/12/31/%E8%B5%B0%E7%9D%80%EF%BC%8C%E8%B5%B0%E7%9D%80/" class="post-title-link" itemprop="url">走着，走着——19年过了</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-31 21:00 / 修改时间：21:04" itemprop="dateCreated datePublished" datetime="2019-12-31T21:00:00+08:00">2019-12-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>前言，18年好像过去没多久，<a href="https://feiybox.com/2018/12/30/%E4%BE%8B%E8%A1%8C%E6%80%BB%E7%BB%93%E2%80%94%E2%80%942018%E7%89%88/">《例行总结——2018版》</a>。</p><p>2019年，这个是平凡的一年，也是有趣的一年。</p><p>平凡，这一年，还是往常一样。工作，加班，读书……依然还是北漂，生活一层不变的过下去。</p><p>有趣，这一年，也发生了许多事。加入了新公司，博客也迁移到github上，开始习惯了“10105.5”的生活，也开始被父母催促“我一个人”。</p><p>2月13日，我年后再来了北京，也加入了新公司。</p><p>今年，总的算下来，我读了13本书，其中十分推荐《人类简史》等。当然，这一年里，总共更新了20篇博客等。也开始学习课程，内部课程完成22个；也在MOOC上开始学习「唐诗经典」。</p><p><img src="/2019/12/31/走着，走着/2019.png" alt="2019"></p><p>这一年，更宅了，只不过也稍微动一点。夏天骑了辆摩拜从望京到中关村，算是我的巅峰了。</p><p>今年也放弃了一些，放弃了使用网易云音乐，也放弃了看NBA。</p><p><img src="/2019/12/31/走着，走着/yundong.jpg" alt="运动"></p><p>工作就不多说了，应该也算有成长吧。</p><p><img src="/2019/12/31/走着，走着/work.jpg" alt="工作"></p><p>2020年，有点想回成都了。至少要读《数据库系统概念》、《追风筝的人》（英文版）、《经济学原理》（宏观经济学分册）。</p><p>19年，就这样了吧。</p><p>我的关键词：走着，走着。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/12/25/%E5%B9%B3%E5%87%A1%E4%B8%96%E7%95%8C%E9%87%8C%EF%BC%8C%E5%B9%B3%E5%87%A1%E7%9A%84%E6%B4%BB%E7%9D%80/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/12/25/%E5%B9%B3%E5%87%A1%E4%B8%96%E7%95%8C%E9%87%8C%EF%BC%8C%E5%B9%B3%E5%87%A1%E7%9A%84%E6%B4%BB%E7%9D%80/" class="post-title-link" itemprop="url">平凡世界里，平凡的活着</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-25 01:05 / 修改时间：01:50" itemprop="dateCreated datePublished" datetime="2019-12-25T01:05:00+08:00">2019-12-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>一本书，能够引起共鸣，触发感想，引导人继续前进，就是一本好书。</p><p>这本书里，描述极其朴实，生活等场景都历历在目，生动形象。但在人物关系上有点过于巧合，让人觉得有点太凑巧了而显得不够自然。但这些都不妨碍这是一本好书，塑造了一个精神强悍的少平，这可以认为是一个时代里的偶像，平凡里的英雄。</p><p>人生有几个永恒的词：物质、精神、苦难、爱情、出生、死亡。这些词交织在一起就是人生。</p><p>晓霞死时，我哭了。或许不是读着以来第一次哭吧，但是我真心体会到那种悲惨。既可怜死者，更同情生者。一个不平凡的人，终究不能以不平凡的方式存在于平凡的世界，当这种人人所向往的美好，破碎了，还有谁能不感叹呢？</p><p>逝者已矣，但生者还得继续过活下去，读到这时，我害怕，害怕少平终于承受不住，选择逃避；害怕少平突然间看淡了，精神世界里崩溃了。我始终害怕，这个平凡的人，在这个现实里，过不去了。</p><p>或者我对于书中少平的害怕，正是我对自己的胆怯。在现实里，我想着用另一种东西来填补我的精神，我明白我是孤寂的，明白我没有那么大的一颗强大的内心，明白我很平凡，明白我缺少一颗有趣的灵魂。正是缺少，我想要去填补，我害怕哪天，我看开了，油腻了，像老一辈一样，空闲时选择混日子了，胆怯着。</p><p>晓霞始终会“离开”。这是一个令人向往的精神体，是众多期望的非具象的凝聚。若晓霞没有离去，与少平无论以何种结局结束，都是不现实的、不平凡的，这便是现实，平凡的世界。每个人心中都有一个自己所期待着的“晓霞”，正因为是期望着，所以想等待下去，等着能够倾听我灵魂的那个“晓霞”，等着能够带领自己的精神突破的人。</p><p>《平凡的世界》结尾得有点让人突然，没有一个是真的悲剧，没有一个是真的喜剧。语言里那一个句号时结束了，但生活、世界都没有停下，接下来会和前面生活一样，不停歇，有喜有悲、有爱有恨、有生命诞生有死亡降临。这一切都会这样一直持续不断的进行下去，生活会一直慢慢过下去。</p><p>现实里也是一个平凡的世界，我是一个平凡的人，想平平凡凡的活下去。</p><p>平凡的世界里，一切都那么地自然，一切都那么现实。而我们就处在这样一个世界里，“只能永远把艰辛的劳动看作是生命的必要；即使没有收获的指望，也心平气和地继续耕种”，只能继续不寻边界的寻找追求的精神与信仰，继续读书，继续追求精神，继续突破边界。这便是我们的选择，如此平凡又不平凡的活下去。</p><p>《平凡的世界》：推荐分8分</p><p><img src="/2019/12/25/平凡世界里，平凡的活着/雪.jpg" alt></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">feiybox</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动</div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>