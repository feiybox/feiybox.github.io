<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/f.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/f.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/f.png"><link rel="mask-icon" href="/images/f.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"feiybox.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="小浊微清的博客"><meta property="og:type" content="website"><meta property="og:title" content="feiybox"><meta property="og:url" content="https://feiybox.com/page/3/index.html"><meta property="og:site_name" content="feiybox"><meta property="og:description" content="小浊微清的博客"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="feiybox"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://feiybox.com/page/3/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>feiybox</title><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?f51cc75dfef0ebc64f14af202ba27866"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">feiybox</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">DO MORE DO BETTER</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-projects"><a href="/projects/" rel="section"><i class="fa fa-sitemap fa-fw"></i>项目</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">72</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="feiybox" src="/images/head.png"><p class="site-author-name" itemprop="name">feiybox</p><div class="site-description" itemprop="description">小浊微清的博客</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">72</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner index posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/12/09/%E6%B3%A8%E9%87%8D%E5%AE%9E%E6%95%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/12/09/%E6%B3%A8%E9%87%8D%E5%AE%9E%E6%95%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">注重实效的程序员参考指南</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-09 00:22 / 修改时间：09:51" itemprop="dateCreated datePublished" datetime="2019-12-09T00:22:00+08:00">2019-12-09</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>本文为读《程序员修炼之道——从小工到专家》的部分总结与摘要。</p><h4 id="关心你的技艺"><a href="#关心你的技艺" class="headerlink" title="关心你的技艺"></a>关心你的技艺</h4><p>即关心自己的技术，考虑自己如何写更好的代码，考虑如何做一个完美的项目。</p><h4 id="思考！你的工作"><a href="#思考！你的工作" class="headerlink" title="思考！你的工作"></a>思考！你的工作</h4><p>不断地批评和评估自己的工作。</p><h4 id="提供各种选项，不要找蹩脚的借口"><a href="#提供各种选项，不要找蹩脚的借口" class="headerlink" title="提供各种选项，不要找蹩脚的借口"></a>提供各种选项，不要找蹩脚的借口</h4><p>提供各种选项，而不是找借口。不要说事情做不到，应该说能够做什么。解决问题而并非推卸责任。</p><h4 id="不要容忍破窗户"><a href="#不要容忍破窗户" class="headerlink" title="不要容忍破窗户"></a>不要容忍破窗户</h4><p>当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们。<strong>置之不理会加速腐烂的进程。</strong>对自己的设计与代码严格要求，才能延续得更久。</p><p>当然，第一目的是实现目标，更好的设计与决策都是为了更好的支持目标。</p><h4 id="做变化的催化剂"><a href="#做变化的催化剂" class="headerlink" title="做变化的催化剂"></a>做变化的催化剂</h4><p>不能强迫人们做改变，但可以展示改变后的效果，以及帮助参与对未来的创造。</p><h4 id="记住大图景"><a href="#记住大图景" class="headerlink" title="记住大图景"></a>记住大图景</h4><p>时刻需要记住目前的目的是什么，需要做什么，以及变化了什么，不能太沉浸于细节中。</p><p>常常小事的积累会破坏士气和团队，学会让事情变得更美好。</p><p>需要时刻提醒自己，目前做的事情是否偏离最终目的。当自己沉入太多时，则要停下来考虑自己是否偏离了方向。</p><h4 id="使质量成为需求问题"><a href="#使质量成为需求问题" class="headerlink" title="使质量成为需求问题"></a>使质量成为需求问题</h4><p>质量也是一个需求，在需要质量时，则需要增加自测&amp;系统测试时间，在排期时也需要对质量留下保证时间。</p><h4 id="定期为你的知识资产投资"><a href="#定期为你的知识资产投资" class="headerlink" title="定期为你的知识资产投资"></a>定期为你的知识资产投资</h4><p>和第一点「关心你的技艺」相关。让学习成为习惯，并非要求都与工作相关。<strong>保持学习，保持阅读，保持总结与写作。</strong></p><h4 id="批判地分析你读到的和听到的"><a href="#批判地分析你读到的和听到的" class="headerlink" title="批判地分析你读到的和听到的"></a>批判地分析你读到的和听到的</h4><p>不要被供应商、媒体炒作、或教条左右。要依照自己的看法和项目的情况区对信息进行分析。</p><p>重点还是明确清楚自己想要什么（最终目的）。</p><h4 id="说什么和怎么说同样重要"><a href="#说什么和怎么说同样重要" class="headerlink" title="说什么和怎么说同样重要"></a>说什么和怎么说同样重要</h4><p>如果不能有效地向他人传达你的了不起的想法，这些项目就毫无用处。</p><p>规划你想说的东西，写出大纲。同时，了解听众（了解别人需要什么，同时明白自己需要表达什么）。</p><blockquote><ul><li>你想让他们学到什么？</li><li>他们对你讲的什么感兴趣？</li><li>他们有多富有经验？</li><li>他们想要多少细节？</li><li>你想让谁拥有这些信息？</li><li>你如何促使他们听你说话？</li></ul></blockquote><p>了解别人的交流风格。</p><p>学会听别人说话，即使你掌握着全部信息。不能及时回复与处理时，都需要反馈。更多交流方案参照<a href="https://feiybox.com/2019/10/27/%E5%B7%A5%E4%BD%9C%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/">《工作沟通技巧笔记》</a></p><h4 id="不要重复自己"><a href="#不要重复自己" class="headerlink" title="不要重复自己"></a>不要重复自己</h4><p>系统中的每一项知识都必须具有单一、无歧义、权威的表示。</p><ul><li>强加的重复</li><li>无意的重复</li><li>无耐性的重复</li><li>开发者之间的重复</li></ul><p>哪怕是最终破坏DRY原则，也不能暴露给外界。</p><h4 id="让复用变得容易"><a href="#让复用变得容易" class="headerlink" title="让复用变得容易"></a>让复用变得容易</h4><p>如果复用很容易，人们就会去复用，创造一个支持复用的环境。</p><p>复用时需要考虑：复用成本 VS 重做成本</p><h4 id="清除无关事物之间的影响"><a href="#清除无关事物之间的影响" class="headerlink" title="清除无关事物之间的影响"></a>清除无关事物之间的影响</h4><p>设计自足、独立、并具有单一、良好定义的目的的组件。</p><p>解耦，提高模块之间的正交性。</p><ul><li>改动得以局部化</li><li>正交得途径还能够促进复用</li><li>使用正交的组件进行组合，可以提高生产率</li></ul><p>编码中需要注意：</p><blockquote><ul><li>使代码保持解耦。使得不用关心内部原理就可以使用</li><li>避免使用全局数据</li><li>避免编写相似的函数</li></ul></blockquote><h4 id="不存在最终决策"><a href="#不存在最终决策" class="headerlink" title="不存在最终决策"></a>不存在最终决策</h4><p>没有决策是浇铸在石头上的。相反，要把每项决策都视为是写在沙滩上的，并为变化做好计划。</p><p>需要考虑维持交个、部署及供应商集成等领域的灵活性。把第三方产品隐藏在定义良好的抽象接口后面。</p><h4 id="用曳光弹找到目标"><a href="#用曳光弹找到目标" class="headerlink" title="用曳光弹找到目标"></a>用曳光弹找到目标</h4><p>曳光弹能通过实验各种事物并检查它们离目标有多远来让你追踪目标。</p><p>原型制作生成用过就扔的代码。曳光弹虽然简约，但却是完整的，并且构成了最终系统的骨架的一部分。</p><h4 id="为了学习而制作原型"><a href="#为了学习而制作原型" class="headerlink" title="为了学习而制作原型"></a>为了学习而制作原型</h4><p>原型制作是一种学习经验。其价值并在于所产生的代码，而在于所学到的经验教训。</p><p>原型应该遮盖细节，并聚焦于所考虑系统的某些具体方面。</p><h4 id="靠近问题领域编程"><a href="#靠近问题领域编程" class="headerlink" title="靠近问题领域编程"></a>靠近问题领域编程</h4><p>用你的用户的语言进行设计和编码。选择更靠近问题解决方便的语言。</p><h4 id="估算，以避免发生意外"><a href="#估算，以避免发生意外" class="headerlink" title="估算，以避免发生意外"></a>估算，以避免发生意外</h4><p>在着手之前先进行估算，将提前发现潜在的问题。需求分析与方案确定后才能估算时间。</p><p>并且学会理解估算对应的精度，进而明确出精确到哪个度量程度。</p><p>对于一个项目，模型可以是你的组织在开发过程中所用的步骤、以及系统的实现方式的非常粗略的图景。</p><p><strong>每次项目完成后，需要终结每次估算不准的原因。</strong></p><h4 id="通过代码对进度表进行迭代"><a href="#通过代码对进度表进行迭代" class="headerlink" title="通过代码对进度表进行迭代"></a>通过代码对进度表进行迭代</h4><p>用在进行实现时获得的经验提炼项目的时间标度。</p><h4 id="用存文本保存知识"><a href="#用存文本保存知识" class="headerlink" title="用存文本保存知识"></a>用存文本保存知识</h4><p>从简单方便的东西记录知识。</p><h4 id="利用命令shell的力量"><a href="#利用命令shell的力量" class="headerlink" title="利用命令shell的力量"></a>利用命令shell的力量</h4><p>当图形用户界面无能为力时使用shell。</p><h4 id="用好一种编辑器"><a href="#用好一种编辑器" class="headerlink" title="用好一种编辑器"></a>用好一种编辑器</h4><p>编辑器应该是你的手的延伸；确保你的编辑器都是可配置、可扩展和可编程。</p><h4 id="总是使用源码控制"><a href="#总是使用源码控制" class="headerlink" title="总是使用源码控制"></a>总是使用源码控制</h4><p>源码控制是你的工作的时间机器——你能够回到过去。</p><h4 id="要修正问题，而不是发出指责"><a href="#要修正问题，而不是发出指责" class="headerlink" title="要修正问题，而不是发出指责"></a>要修正问题，而不是发出指责</h4><p>bug是你的过错还是别人的过错，并不是真的很有关系——它们仍然是你的问题，它仍然需要修正。</p><h4 id="不要恐慌"><a href="#不要恐慌" class="headerlink" title="不要恐慌"></a>不要恐慌</h4><p>做一次深呼吸，思考什么可能是bug的原因。慌也解决不了问题。</p><h4 id="“Select”-没有问题"><a href="#“Select”-没有问题" class="headerlink" title="“Select” 没有问题"></a>“Select” 没有问题</h4><p>在OS或编译器、甚至是第三方产品或库中很少发现bug。bug很可能在应用中。多相信系统控件。</p><h4 id="不要假定，要证明"><a href="#不要假定，要证明" class="headerlink" title="不要假定，要证明"></a>不要假定，要证明</h4><p>在实际环境中——使用真正的数据和边界条件——证明你的假定。</p><h4 id="学习一种文本操作语言"><a href="#学习一种文本操作语言" class="headerlink" title="学习一种文本操作语言"></a>学习一种文本操作语言</h4><h4 id="编写能编写代码的代码"><a href="#编写能编写代码的代码" class="headerlink" title="编写能编写代码的代码"></a>编写能编写代码的代码</h4><p>代码生成器能提高你的生产率，并有助于避免重复。</p><h4 id="不可能写出完美的软件"><a href="#不可能写出完美的软件" class="headerlink" title="不可能写出完美的软件"></a>不可能写出完美的软件</h4><p>软件不可能是完美的。保护你的代码和用户，使他们免于能够预见的错误。注重实效的程序员针对自己的错误进行防卫性的编码。</p><h4 id="通过合约进行设计"><a href="#通过合约进行设计" class="headerlink" title="通过合约进行设计"></a>通过合约进行设计</h4><p>使用合约建立文档，并检验代码所做的事情正好是它声明要做的。（输入什么，做了什么，输出了什么）。</p><p>参数的改变必须是显示的，并不能隐藏。</p><p>对在开始之前接受的东西要严格，而允诺返回的东西要尽可能少。</p><h4 id="早崩溃"><a href="#早崩溃" class="headerlink" title="早崩溃"></a>早崩溃</h4><p><strong>在错误发生时，第一时间中止。</strong></p><p>函数需要考虑异常输入并给出提示。（底层方法异常输入应该之间中止流程）。</p><p>出错时需要偏向消费者。</p><h4 id="用断言避免不可能发生的事情"><a href="#用断言避免不可能发生的事情" class="headerlink" title="用断言避免不可能发生的事情"></a>用断言避免不可能发生的事情</h4><p>断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码。保留某些异常检测流程。</p><h4 id="将异常用于异常的问题"><a href="#将异常用于异常的问题" class="headerlink" title="将异常用于异常的问题"></a>将异常用于异常的问题</h4><p>异常可能会遭受经典意大利面条式代码的所有可读性和可维护性问题的折磨。将异常保留给异常的事物。</p><h4 id="要有始有终"><a href="#要有始有终" class="headerlink" title="要有始有终"></a>要有始有终</h4><p><strong>分配某资源的例程或对象也应该负责解除其分配。</strong></p><ul><li>以与资源分配次序相反的次序解除资源的分配</li><li>在代码的不同地方分配同意组资源时，总是以相同的次序分配它们。（降低发生死锁的可能性）</li><li>无论时谁分配的资源，都应该负责解除该资源的分配</li></ul><h4 id="使模块之间的耦合减至最少"><a href="#使模块之间的耦合减至最少" class="headerlink" title="使模块之间的耦合减至最少"></a>使模块之间的耦合减至最少</h4><p>通过编写“羞怯的”代码并应用得墨忒耳法则来避免耦合。</p><p>得墨忒耳法则：</p><ul><li>每个单元对于其他的单元只能拥有有限的知识：只是与当前单元紧密联系的单元</li><li>每个单元只能和它的朋友交谈：不能和陌生单元交谈</li><li>只和自己直接朋友交谈</li></ul><p>平衡你的规定应用的各种正面因素和负面因素。</p><h4 id="要配置，不要集成"><a href="#要配置，不要集成" class="headerlink" title="要配置，不要集成"></a>要配置，不要集成</h4><p>要将应用得各种结束选择实现为配置选项，而不是通过集成或工程方法实现。<strong>配置方式，方便修改，统一维护。</strong></p><h4 id="将抽象放进代码，细节放进元数据"><a href="#将抽象放进代码，细节放进元数据" class="headerlink" title="将抽象放进代码，细节放进元数据"></a>将抽象放进代码，细节放进元数据</h4><p>为了一般情况编程，将细节放在被编译的代码库之外。尽可能编写通用的代码。</p><h4 id="分析工作流，以改善并发性"><a href="#分析工作流，以改善并发性" class="headerlink" title="分析工作流，以改善并发性"></a>分析工作流，以改善并发性</h4><p>利用你的用户的工作流的并发性。</p><h4 id="用服务进行设计"><a href="#用服务进行设计" class="headerlink" title="用服务进行设计"></a>用服务进行设计</h4><p>根据服务——独立性、在良好定义、一致的借口之后的并发对象——进行设计。</p><h4 id="总是为并发进行设计"><a href="#总是为并发进行设计" class="headerlink" title="总是为并发进行设计"></a>总是为并发进行设计</h4><p>容许并发，你将会设计出更整洁、具有更少假定的接口。</p><h4 id="使视图与模型分离"><a href="#使视图与模型分离" class="headerlink" title="使视图与模型分离"></a>使视图与模型分离</h4><p>要根据模型和视图设计你的应用，从而低廉的代码获得灵活性。相当于MVC中的view层和model层进行分离。</p><h4 id="用黑板协调工作流"><a href="#用黑板协调工作流" class="headerlink" title="用黑板协调工作流"></a>用黑板协调工作流</h4><p>用类似黑板的画图方式总结和协调工作流。</p><h4 id="不要考巧合编程"><a href="#不要考巧合编程" class="headerlink" title="不要考巧合编程"></a>不要考巧合编程</h4><p>只依靠可靠的事物。注意偶发性的复杂性，不要把幸运的巧合与有目的的计划混为一谈。</p><blockquote><ul><li>总是意识到你在做什么。</li><li>不要盲目地编程。视图构建不完全理解的应用，或是使用不熟悉的技术，就是希望自己被巧合误导。</li><li>按照计划行事，不管计划时在你的头脑中。</li><li>依靠可靠的事物。</li><li>为“假定”或“合约”建立文档。</li><li>不要只是测试你的代码，还需要测试你的假设。</li><li>为你的工作划分优先级。</li><li>不要做历史的奴隶，不要让已有的代码支配将来的代码。不要让已经做完的事情约束下一步要做的事情——准备好进行重构。（以最小的成本与影响进行重构）</li></ul></blockquote><h4 id="估算算法的阶"><a href="#估算算法的阶" class="headerlink" title="估算算法的阶"></a>估算算法的阶</h4><p>在编写代码之前，先大致估算事情需要多长时间。</p><h4 id="测试你的估算"><a href="#测试你的估算" class="headerlink" title="测试你的估算"></a>测试你的估算</h4><p>对算法的数学分析并不会告诉你每一件事情。在代码的目标环境中测定它的速度。</p><h4 id="早重构，常重构"><a href="#早重构，常重构" class="headerlink" title="早重构，常重构"></a>早重构，常重构</h4><p>就和你会在花园里除草、重新布置一样，在需要时对代码进行<strong>重构、重做和重新架构</strong>。要铲除问题的根源，控制演化方向。</p><ul><li>重构与需求应该分开进行（至少分为不同步骤）。不要试图在重构的同时增加功能。</li><li>重构前列出测试case。保证重构后拥有良好的测试。</li><li>采取短小、深思熟虑的步骤。</li></ul><p>如果某个代码与设计现在又损害，但以后损害会更大，也许最好一劳永逸的修正它。不要容忍破窗户。</p><h4 id="为测试而设计"><a href="#为测试而设计" class="headerlink" title="为测试而设计"></a>为测试而设计</h4><p>代码与系统设计时需要考虑测试。</p><p>日志中必须带有必要的信息，方便跟踪问题。日志消息的格式应该是正规、一致。</p><h4 id="测试你的软件，否则用户就得测试"><a href="#测试你的软件，否则用户就得测试" class="headerlink" title="测试你的软件，否则用户就得测试"></a>测试你的软件，否则用户就得测试</h4><p>测试是技术、更是文化；不管所用的语言是什么，我们都可以<strong>让这样的测试文化慢慢渗入项目中。</strong></p><h4 id="不要使用你不理解的向导代码"><a href="#不要使用你不理解的向导代码" class="headerlink" title="不要使用你不理解的向导代码"></a>不要使用你不理解的向导代码</h4><h4 id="不要收集需求——挖掘它们"><a href="#不要收集需求——挖掘它们" class="headerlink" title="不要收集需求——挖掘它们"></a>不要收集需求——挖掘它们</h4><p>挖掘潜层需求，理解需求背后的目的。<strong>需求分析是指了解具体的需要。</strong></p><p>找出用户为何要做特定事情的原因，而不只是它们目前做这个事情的方式。开发解决的最终是商业问题，而不只是满足他们陈述的需求。用文档记录需求背后的原因。</p><h4 id="与用户一同工作，以像用户一样思考"><a href="#与用户一同工作，以像用户一样思考" class="headerlink" title="与用户一同工作，以像用户一样思考"></a>与用户一同工作，以像用户一样思考</h4><p>要了解系统实际上将如何被使用，这是最好的方法。</p><p>开采需求的过程也是开始与用户群建立和谐关系、了解他们对正在构建的系统的期许和希望。</p><h4 id="抽象比细节活得更长久"><a href="#抽象比细节活得更长久" class="headerlink" title="抽象比细节活得更长久"></a>抽象比细节活得更长久</h4><p>“投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去。</p><p>不要做任何表示方法的奴隶；只要是与你的听众交流需求的最好的方法，都可以加以使用。</p><h4 id="使用项目词汇表"><a href="#使用项目词汇表" class="headerlink" title="使用项目词汇表"></a>使用项目词汇表</h4><p>创建并维护项目中使用的专用术语和词汇的单一信息源。文档需要方便阅读与分享。</p><h4 id="不要在盒子外面思考——要找到盒子"><a href="#不要在盒子外面思考——要找到盒子" class="headerlink" title="不要在盒子外面思考——要找到盒子"></a>不要在盒子外面思考——要找到盒子</h4><p>在遇到不可能解决问题时，要确定真正的约束。问问自己：“它必须以这种方式完成吗？它真的必须完成吗？”</p><p>回头考虑自己的最终目的，需求最后的需要，自己是否被限制住了。</p><blockquote><ul><li>有更容易的方法吗？</li><li>你是在设法解决真正的问题，还是被外围的技术问题转移了注意力？</li><li>这件事为什么是一个问题？</li><li>是什么使它如此难以解决？</li><li>它必须以这种方式完成吗？</li><li>它真的必须吗？</li></ul></blockquote><h4 id="等你准备好再开始"><a href="#等你准备好再开始" class="headerlink" title="等你准备好再开始"></a>等你准备好再开始</h4><p>你的一生都在积累经验。不要忽视返回出现的疑虑。</p><p>将特殊点训练成意识、习惯。</p><h4 id="对有些事情“做”胜于“描述”"><a href="#对有些事情“做”胜于“描述”" class="headerlink" title="对有些事情“做”胜于“描述”"></a>对有些事情“做”胜于“描述”</h4><p>不要掉进规范的螺旋——在某个时刻，你需要开始编码。</p><h4 id="不要做形式方法的奴隶"><a href="#不要做形式方法的奴隶" class="headerlink" title="不要做形式方法的奴隶"></a>不要做形式方法的奴隶</h4><p>如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。</p><h4 id="昂贵的工具不一定能制作出更好的设计"><a href="#昂贵的工具不一定能制作出更好的设计" class="headerlink" title="昂贵的工具不一定能制作出更好的设计"></a>昂贵的工具不一定能制作出更好的设计</h4><p>小心供应商的炒作，行业教条、以及价格标签的诱惑。要根据工具的价值判断它们。</p><h4 id="围绕功能组织团队"><a href="#围绕功能组织团队" class="headerlink" title="围绕功能组织团队"></a>围绕功能组织团队</h4><p>不要把设计师和编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。</p><p>质量是一个团队问题。如果团队主动鼓励开发者不要把时间花费在这样的修正上，问题就会进一步恶化。确保每个人都主动地监视环境的变化。</p><p>创建品牌，建立信任机制。对外界而言，看上去沉闷寡言的项目团队是最糟糕的图团队。无章次的会议、混乱的文档、不统一的术语都是要避免的。</p><p>把团队划分为小团队，分别负责最终系统的特定方面的功能。让各团队按照个人的能力，在内部自行进行组织。</p><h4 id="不要使用手工流程"><a href="#不要使用手工流程" class="headerlink" title="不要使用手工流程"></a>不要使用手工流程</h4><p>shell脚本或批文件会一次次地以同一顺序执行同样的指令。</p><p>自动化是每个项目团队的必要组成部分。确保项目的一致性和可重复性。人的重复性可能存在很大问题（不要基于记忆），应该使用文档来规束，代码进行负责自动化。</p><h4 id="早测试，常测试，自动测试"><a href="#早测试，常测试，自动测试" class="headerlink" title="早测试，常测试，自动测试"></a>早测试，常测试，自动测试</h4><p>与待在书架上的测试计划相比，每次构建时运行的测试要有效得多。</p><h4 id="要到通过全部测试，编码才算完成"><a href="#要到通过全部测试，编码才算完成" class="headerlink" title="要到通过全部测试，编码才算完成"></a>要到通过全部测试，编码才算完成</h4><p>单元测试是对某个模块进行演练的代码。</p><p>性能测试、压力测试或负载测试也可能会是项目的一个重要方面。</p><p>回归测试是把当前测试的输出与先前的（或者已知的）值进行对比。</p><blockquote><ul><li>单元测试</li><li>集成测试</li><li>验证和校验</li><li>资源耗尽、错误及恢复</li><li>性能测试</li><li>可用性测试</li><li>对测试自身进行测试</li></ul></blockquote><h4 id="通过”蓄意破坏“测试你的测试"><a href="#通过”蓄意破坏“测试你的测试" class="headerlink" title="通过”蓄意破坏“测试你的测试"></a>通过”蓄意破坏“测试你的测试</h4><p>在单独的软件副本中故意引入bug，以检验测试能够抓住它们。</p><h4 id="测试状态覆盖，而不是代码覆盖"><a href="#测试状态覆盖，而不是代码覆盖" class="headerlink" title="测试状态覆盖，而不是代码覆盖"></a>测试状态覆盖，而不是代码覆盖</h4><p>确定并测试重要的程序状态，只是测试代码行是不够的。</p><h4 id="一个bug只抓一次"><a href="#一个bug只抓一次" class="headerlink" title="一个bug只抓一次"></a>一个bug只抓一次</h4><p>一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。</p><h4 id="英语就是一种编程语言"><a href="#英语就是一种编程语言" class="headerlink" title="英语就是一种编程语言"></a>英语就是一种编程语言</h4><p>像你编写代码一样编写文档：遵循DRY原则、使用元数据、MVC、自动生成，等等。</p><h4 id="把文档建在里面，不要拴在外面"><a href="#把文档建在里面，不要拴在外面" class="headerlink" title="把文档建在里面，不要拴在外面"></a>把文档建在里面，不要拴在外面</h4><p>与代码分离的文档不太可能被修正和更新。</p><p>在必要的地方添加注释，代码即是文档，避免多余的注释。<strong>比无意义的名称更糟糕的是误导人的名称。</strong></p><p><strong>文档需要写下文档创作的时间。</strong></p><h4 id="温和地超出用户的期望"><a href="#温和地超出用户的期望" class="headerlink" title="温和地超出用户的期望"></a>温和地超出用户的期望</h4><p>要理解用户的期望，然后给他们的东西要多那么一点。</p><h4 id="在你的作品上签名"><a href="#在你的作品上签名" class="headerlink" title="在你的作品上签名"></a>在你的作品上签名</h4></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/11/25/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%89%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/11/25/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">笔记整理——计算机操作系统（笔记整理三之三）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-25 00:28 / 修改时间：00:37" itemprop="dateCreated datePublished" datetime="2019-11-25T00:28:00+08:00">2019-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>操作系统的五大功能：处理机管理、存储器管理、设备管理、文件管理、向用户提供方便的用户接口。</p><p>操作系统共有的特征：并发、共享、虚拟、异步。（并发与共享是最基本的特征）。操作系统分为单道批处理、多道批处理；分时、实时系统。</p><p>进程：系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据、堆栈等组成。线程：作为独立运行的调度的基本单位。进程控制块：PCB，进程存在的唯一标志，系统利用PCB进而控制和管理进程（常驻内存）。进程和程序的最根本的区别是，进程是动态的，而程序是静态的。</p><p>进程的特征：并发性（重要特征）、动态性（最基本的特征）、独立性、异步性。进程由独立的地址空间；线程由自己的堆栈和局部变量，但线程之间没有单独的地址空间，<strong>一个线程死掉就等于整个进程死掉</strong>（每个进程最少有一个线程）。进程之间的地址空间独立。</p><p><img src="/2019/11/25/笔记整理——计算机操作系统（笔记整理三之三）/进程状态变化.png" alt="进程状态变化"></p><p>挂起状态 —&gt; 活动就绪、静止就绪、活动阻塞、静止阻塞。终止状态后，除PCB之外其他都被释放。</p><p>临界资源：在一段时间内只允许一个进程访问的资源。每个进程中访问临界资源的那段代码称为临界区。</p><p>关中断：屏蔽中断，系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。</p><p><strong>调度算法</strong>：</p><ul><li>FCFS：先来先服务（不利于短作业）</li><li>SJF：短作业优先（平均周转时间最短的算法）</li><li>PSA：优先级调度算法（优先级数越大，优先度越高）</li><li>HRRN：高响应比优先调度算法。响应比 <strong>Rp = 响应时间 / 要求服务时间 = （等待时间 + 要求服务时间） / 要求服务时间</strong></li><li>RR：轮转调度算法（主要用于分时系统）</li><li>抢占式调度算法：1、基于时钟中断的抢占式优先级调度算法；2、立即抢占。</li><li>EDF：最早截止时间优先算法</li><li>LLF：最低松弛度优先算法。 <strong>松弛度 = 完成截止时间 - 剩余运行时间 - 当前时间</strong></li></ul><p><strong>死锁</strong>的必要条件：1、互斥条件；2、请求和保持条件；3、不可抢占条件；4、循环等待条件。处理死锁的方法：1、预防死锁；2、避免死锁（银行家算法，在资源分配过程中，防止系统进入不安全状态）；3、检测死锁；4、解除死锁。产生死锁的原因主要有：1、系统资源不足；2、进程运行推进的顺序不合适；3、资源分配不当等。</p><p>死锁的预防措施：1、静态资源分配法；2、资源顺序分配法；3、剥夺控制法。</p><p>程序装入：1、编译；2、链接（逻辑地址变物理地址）；3、装入。（绝对装入方式、可重定位装入方式、动态运行时的装入方式）。</p><p>基于顺序搜索的动态分区分配算法：</p><ul><li>首次适应算法（FF）</li><li>循环首次适应算法（NF）</li><li>最佳适应算法（WF）：总是挑选一个最大的空闲区，从中分割一部分存储空间给作业使用。</li></ul><p>基于索引搜索的动态分区分配算法：</p><ul><li>快速适应算法</li><li>伙伴系统</li></ul><p>动态可重定位分区分配。<strong>紧凑</strong>：解决了碎片问题。</p><p>分页 / 分段 / 段页式。页是信息的物理单位，以消减内外零头（系统行为）；段时信息的逻辑单位，满足用户的需要。</p><p>内存分配策略：</p><ul><li>固定分配局部置换（只能从分配给改进程n个页面中选出一页换出）（固定分配全局置换不能组合）</li><li>可变全局置换</li><li>可变分配局部置换（只交换该进程的页面，分配若干物理块）</li></ul><p>物理块分配算法：</p><ul><li>平均分配算法</li><li>按比例分配算法</li><li>考虑优先权的分配算法</li></ul><p>页面调入：预调页策略，请求调页策略。</p><p>请求分页系统中的外存分为：1、用于存放文件的文件区；2、用于存放对换页面的对换区。</p><p>页面置换算法：</p><ul><li>最佳置换算法（无法实现）</li><li>FIFO算法，有Belady现象</li><li>LRU，最近最久未使用。需要较多硬件支持；管理虚拟内存的分配，物理内存的释放。</li><li>LFU，最少使用置换算法</li><li>Clock置换算法</li><li>页面缓冲算法PBA</li></ul><p>抖动：同时在系统中运动的进程太多，从而分配每一个进程物理块太少，导致频繁缺页。</p><ul><li>工作集指某个时间间隔∆里，进程实际所要访问页面的集合。</li><li>块设备接口是块设备管理程序与高层之间的接口。</li><li>设备控制器，控制一个或多个I/O设备，以实现I/O设备和CPU之间的数据交换。</li><li>I/O通道，通道与CPU共享内存</li></ul><p>磁盘调度算法：1、先来先服务（FCFS）；2、最短寻道时间优先（SSTF）；3、扫描算法（SCAN），电梯调度算法；4、循环扫描算法（CSCAN）</p><p>文件组织方式：顺序文件、索引文件、索引顺序文件。文件的逻辑结构：连续结构、多重结构、转置结构、顺序结构；（流式文件属于逻辑结构的文件）。文件的物理存储：顺序结构、链接结构、索引结构。文件的目录结构：一级目录结构、二级目录结构、树形结构、无环图。</p><p>文件存储空间的管理：1、空闲法和空闲链表法；2、位示图法；3、成组链接法。</p><p>数据传输率 = 记录密度 X 线速度。系统对每一块数据的处理时间：1、单缓冲区 Max（C，T）+ M；2、多缓冲区 Max（C，T）。（CPU处理时间C、缓冲区时间T、传送到用户时间M）</p><p>作业调度JCB：后备队列，优先级调度可能产生饥饿。</p><p>内存管理中常用区间和区间中的数据：</p><ul><li>静态区：存放（初始化的）全局变量、静态变量，和（未初始化）全局变量和静态变量。</li><li>栈区：存放局部变量和函数的形参。栈中的内存空间由编译器自动申请和释放。</li><li>堆区：存放动态分配内存函数申请的变量。堆中的内存空间需要程序员手动释放，否则会发生内存泄露。（易产生内存碎片）</li></ul><p>虚拟设备（Spooling技术），将独占设备变为共享设备，实现设备的虚拟分配，提高独占设备的利用率。（只能用软件实现）</p><p>线程共享的内容包括：1、进程代码段；2、进程数据段；3、进程打开的文件描述符；4、信号的处理器；5、进程的当前目录；6、进程用户ID与进程组ID。</p><p>线程独有的内容包括：1、线程ID；2、寄存器组的值；3、线程的堆栈；4、错误返回码；5、线程的信号屏蔽码。</p><p>用于进程间通信（IPC）的四种不同技术：</p><ul><li>消息传递（管道、FIFO、Posix和System v消息队列）</li><li>同步（互斥锁、条件变量、读写锁、文件和积累锁，Posix和System v信号灯）</li><li>共享内存区（匿名共享内存区，有名Posix共享内存区，有名System v共享内存区）</li><li>过程调用（Solaris门、SunRPC）</li></ul><p>实现线程同步：事件、临界区、互斥量、信号量。</p><p>外部中断处理过程，PC值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。</p><p>虚拟存储的实现是基于程序局部性原理，其实质是借助外存将内存较小的物理地址空间转化为较大的逻辑地址空间。</p><p>用户级线程的管理由用户应用程序来完成，内核是不知道用户线程的。</p><p>删除文件，文件的关联目录项和文件控制块需要随着文件一同删除，同时释放文件的关联缓冲区。</p><p>管道是指用于连接一个读进程和一个写进程以实现进程之间通信的一种共享文件。数据格式是字符流。</p><p>虚拟存储器最大实际容量 = min（计算机地址，内存 + 辅存）</p><p>在分段存储管理中，地址转换公式：物理地址 = 界限寄存器值 + 逻辑地址。</p><p>fork子进程，但父子进程二者的地址空间是各自独立的，子进程无法读取父进程的数据。</p><p>文件目录：把所有FCB组织在一起，就构成了文件目录，即文件控制块的有序集合。目录文件：为了实现对文件目录的管理，通常将文件目录以文件的形式保持在外存，这个文件就是目录文件。</p><p>进程上下文实际是进程执行活动全过程的静态描述。进程被抢占需要保存内容：1、所有CPU寄存器的内容，2、页表，3、程序计数器。</p><p>在请求分页管理中，一个首次装入内存的页面可能来自：1、磁盘文件区；2、后备作业区；3、I/O缓冲池。</p><p>逻辑地址到物理地址的映射，是由处理机中设置的专门硬件完成，即地址管理部件。页式的地址是一维的，段式的地址是二维的。</p><p>用户程序引发磁盘I/O请求后，系统处理流程：用户程序 -&gt; 系统调用处理流程 -&gt; 中断处理程序 -&gt; 设备驱动程序。</p><p>减少缺页中断（缺页错误、换页错误）：</p><ul><li>内存页框数，增加作业分得得内存块数</li><li>页面大小。页面划分越大，中断率越低。</li><li>替换算法的优劣影响缺页中断次数。</li><li>程序局部性。程序局部性好可减少中断。</li></ul><p>总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及控制电路。</p><p>总线按功能和规范可分为五大类型：</p><ul><li>数据总线：在CPU与RAM之间来回传送需要处理或是需要储存的数据</li><li>地址总线：用来指定在RAM之中储存的数据地址</li><li>控制总线：将微处理器控制单元的信号，传送到周边设备，一般常见为USB Bus和1394 Bus</li><li>扩展总线：可连接扩展槽和电脑</li><li>局部总线：取代更高速数据传输的扩展总线</li></ul><p>各种虚拟存储都是时间换空间，缓冲是用空间换时间。</p><p>利用通道实现了内存与外设之间数据的快速传输。</p><p>sleep方法会给其它线程运行的集合，而不管其优先级。yield只会给优先级相同的或者比自己高的线程运行的机会。sleep会使线程进入阻塞状态，yield进入就绪。</p><p>进程挂起的原因：1、终端用户的请求；2、父进程的请求；3、符合调节的需要；4、操作系统的需要。</p><p>一般来说，磁盘I/O进程的优先权要高于计算进程。</p><p>上下文切换需要完成：1、内存管理上下文；2、页表切换；3、切换内核态堆栈上下文数据；4、硬件上下文，主要部分为进程和CPU的任务状态寄存器。</p><p>硬件的存取访问时间分为三个部分：寻道时间Ts，旋转延迟时间Tr，传送时间Tt。</p><p>多关键字文件的特点是，在文件进行检索操作时，不仅仅对主关键词进行简单询问，还经常需要对次关键字进行其它类型的询问检索。（常见的有多重文件、倒排文件）</p><p>管态，又叫特权态，系统态或核心态。当CPU处理系统程序的时间，CPU会转为管态，CPU在管态下可以执行指令系统全集（特权指令、非特权指令）。</p><p>主存地址寄存器MAR和程序计数器PC的位数都取决于主存储器的容量，二者位数相等。</p><p>文件操作是唯一依据是文件句柄。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul><li><a href="https://feiybox.com/2019/11/20/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%80%EF%BC%89/">笔记整理——算法（笔记整理三之一）</a></li><li><a href="https://feiybox.com/2019/11/23/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%BA%8C%EF%BC%89/">笔记整理——计算机网络（笔记整理三之二）</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/11/23/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%BA%8C%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/11/23/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">笔记整理——计算机网络（笔记整理三之二）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-23 19:17" itemprop="dateCreated datePublished" datetime="2019-11-23T19:17:00+08:00">2019-11-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-25 00:39" itemprop="dateModified" datetime="2019-11-25T00:39:53+08:00">2019-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>计算机网络的功能：1、数据交换与通信；2、资源共享；3、提高系统的可靠性和可用性；4、分布式网络处理。计算机网络中可以共享的资源包括：硬件、软件、数据、通信信道。</p><p>应用层、运输层、网络层、链路层、物理层</p><p>应用层、表示层、会话层、运输层、网络层、链路层、物理层</p><ul><li>应用层：HTTP、SMTP、FTP、（DNS）协议。网络应用程序及它们的应用层协议存留的地方。</li><li>运输层：在应用程序端点之间传送应用层报文（不同主机应用进程之间的逻辑通信）。TCP、UDP协议。</li><li>网络层：将数据报从一台主机移动到另一台主机。分组，不可靠服务。IP协议、OSPF协议（路由选择协议：转发和路由选择）。</li><li>链路层：数据帧</li><li>物理层：比特流</li></ul><p><strong>TCP/IP协议包括：应用层、传输层、网络层、网络接口层。</strong></p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层负责处理网络应用。（HTTP、FTP、SMTP）</p><p>应用层协议定义了运行在不同端系统上的应用程序如何相互传递报文。报文定义为：报文类型、语法、语义、一个进程何时以如何时序发送报文，对报文的响应规则。</p><p>HTTP使用TCP作为运输层协议，也是无状态协议：HTTP服务器并不保存关于客户的任何信息。并分为持续连接：HTTP默认使用带流水线的持续连接；非持续连接：必须为每一个请求的对象建立和维护一个全新的连接。</p><p>FTP使用两个并行的TCP连接来传输文件，分为控制连接、数据连接（21、20端口）。一个控制连接可以对应多个数据连接，即控制连接贯穿了整个用户回话期间，但是对会话中的每一个文件传输都需要建立一个新的数据连接。</p><p>DNS（域名系统）：1、一个由分层的DNS服务器实现的分布式数据库；2、一个使得主机能够查询分布式数据库的应用层协议。DNS协议运行在UDP之上，使用53端口号。</p><p>DNS域名正向查询：通过域名得到IP的查询；反向查询：通过IP得到域名。迭代查询、递归查询。根DNS服务器、顶级域DNS（TLD）服务器、权威DNS服务器、本地DNS服务器。</p><p>1、HTTP 2.x 相对于 HTTP 1.x 的区别：</p><ul><li>多路复用：允许同时通过单一的HTTP/2连接发起多重请求——响应消息。</li><li>二进制分帧：改进传输性能，实现低延迟和高吞吐量。</li><li>首部压缩</li><li>服务端推送</li></ul><p>2、HTTP 1.1 相对于 HTTP 1.0 的区别：</p><ul><li>缓存处理：可以选择更多缓存控制策略。</li><li>带宽优化和网络连接的使用</li><li>错误的通知管理（新增24个错误状态响应码）</li><li>Host处理</li><li>长连接（keep alive）</li></ul><p>Cookie存在客户端，Session存在服务端。Http下cookie是明文传输的，Https下是密文传递的。子域名可以访问根域名的cookie，反之则不可。对于不同的浏览器，cookie大小由不同的限制。</p><p>HTTP会话的四个过程：1、连接；2、请求；3、应答；4、关闭。</p><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><p>传输层负责端到端连接。进程通过socket的软件接口向网络发送报文和网络接收报文。（TCP、UDP、SPX）</p><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>面向连接服务，可靠数据传输、拥塞控制、流量控制、自动重传请求（ARQ）协议、rdt3.0停等协议（累计确认）。</p><p>建立TCP连接需要三次握手，（三次握手）建立连接 -&gt; 传输报文 -&gt; 拆除连接。断开连接需要四次握手。</p><p><img src="/2019/11/23/笔记整理——计算机网络（笔记整理三之二）/三次握手.png" alt="TCP三次握手"></p><p><img src="/2019/11/23/笔记整理——计算机网络（笔记整理三之二）/四次挥手.png" alt="TCP四次挥手"></p><p>客户端状态变化：CLOSED -&gt; SYN_SENT -&gt; ESTANBLISHED -&gt; FIN_WAIT_1 -&gt; FIN_WAIT_2（半关闭状态，有接收数据能力，但已经无法发送数据） -&gt; TIME_WAIT（等待状态，2MSL等待状态，第四次握手的保险状态） -&gt; CLOSED。</p><p>服务端状态变化：CLOSED -&gt; LISTEN -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; CLOSE_WAIT -&gt; LAST_ACK -&gt; CLOSED。</p><p>回退N步（GBN）、选择重传（SR）。慢启动、拥塞避免、快速恢复（AIMD：加增倍减）。</p><p>带宽 X 时延 = 缓冲区大小。在一般的操作系统中TCP发送缓冲区默认值是4MB左右（有一定的自调节能力）。</p><p>TCP中用16bit来表示窗口大小。滑动窗口提供TCP的可靠性，提供TCP的流控特性。（确认重传机制，重传情况下采用一种“指数退避”的方式）。（RST：表示重置连接、复位连接；RTT：连接的往返时间；RTO：重传超时时间）。1、一个连接中，有且仅有一个测量定时器被使用。也就是说如果TCP连续发出3组数据，只有一组数据会被测量。2、ACK数据报不会被测量，原因是没有ACK的ACK回应可以供结束定时器测量。</p><p>TCP为了提高效率，允许重新传输的时候，只要传输包含重要数据报文就可以，而不用重传需要传输的报文。</p><p>如果发送方收到接受方的窗口大小为0的TCP数据报文，发送端将会停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。</p><p>发送窗口上限值 = Min[接收窗口，拥塞窗口]</p><p>SSL是一种对TCP的强化socket，强化是在应用层实现的。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>无连接、不可靠数据传输，没有拥塞控制机制，不提供时延保证。</p><p>伪头部用于检验和差错检测功能。</p><p>TCP/UDP传输段中，源端口地址和目的端口地址不能相同，相同则是LAND攻击。</p><p>DNS服务器之间传输时使用TCP，而客户端与DNS服务器之间传输时使用UDP。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层负责寻址和最短路径。（IP、IPX、APPLETALK、ICMP）</p><p>路由选择算法：1、全局式路由选择算法；2、分散式路由选择算法。（LS算法：链路状态；DV算法：距离向量）</p><p>自治系统内部的路由选择：路由选择信息协议（RIP协议：基于距离矢量的路由协议，一种DV算法）；开放最短路优先（OSPF：开放最短路径优化协议，一种LS算法）。自治系统间的路由选择：BGP（边界网关协议：一种DV算法）。RIP最多支持的跳数为15，即在源和目的的网间所要经过的最多路由器的数目为15，跳数为16表示不可达。</p><p>ICMP：Internet控制报文协议，用于IP主机、路由器之间的传输控制消息（指网络通不通、主机是否可达、路由是否可用等网络本身的消息）；让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。是TCP/IP协议族的一个子协议，用在网络层。PING使用的是ICMP协议。Traceroute：用于侦测主机到目的主机之间所经由路由情况（windows下是tracert)。</p><p>查询报文：Ping查询、子网掩码查询、时间戳查询；差错报文：产生在数据传送发送错误时。</p><p>IP地址：网络号 + 主机号。IP地址匹配遵循最长前缀匹配原则。IP数据报分片可能发生在信号源/路由器，而重组必须在目的主机。</p><p>一般操作系统默认是没有路由功能的（需要自己配置）。</p><p>ICMP的IP重定向报文：重定向报文只能由路由器发出；重定向报文为主机所用，而不是为路由器所用。</p><p>集线器共享带宽，交换机独占带宽。路由器的每一个接口是一个广播域；交换机的每个接口是一个冲突域，交换机在未配置策略前是所有接口是一个广播域。集线器的所有接口是一个冲突域。</p><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层为介入介质。提供服务：成帧、链路接入、可靠交付、差错检测与纠正（比特级）。（802.2、802.3、ATM（电路交换和分组交换的组合，53个字节，前5个为信头，完成寻址，后48为信息端）、HDLC、FRAME、RELAY、PPP）</p><p>链路接入：媒体访问控制协议（MAC），规定帧在链路上传输规则。</p><p>奇偶校验、二维奇偶校验（前向纠错）、循环冗余检测（CRC）。</p><p>地址解析协议（ARP）：IP地址到MAC地址的转换。（RARP：逆地址解析协议）</p><p>以太网中的最小帧长是根据网络检测冲突的最长时间来确定的。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>二进制传输。</p><p>物理层电路交换在发送数据前要建立一条端到端的路径。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>NAT地址转换实现了对用户透明的网络内部地址分配。</p><p>QoS：服务质量。是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。（正常不需要）但对关键应用和多媒体应用就十分必要。当网络过载或拥塞时，QoS能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。</p><p>数据网络中经历的总时延包括：发送时延、传播时延、排队时延、处理时延。</p><p>负载均衡一般由第四层或第七层实现。</p><p>VPN是互联网内用软件建立的安全隧道。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul><li><a href="https://feiybox.com/2019/11/20/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%80%EF%BC%89/">笔记整理——算法（笔记整理三之一）</a></li><li><a href="https://feiybox.com/2019/11/25/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%89%EF%BC%89/">笔记整理——计算机操作系统（笔记整理三之三）</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/11/20/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%80%EF%BC%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/11/20/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">笔记整理——算法（笔记整理三之一）</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-20 00:32" itemprop="dateCreated datePublished" datetime="2019-11-20T00:32:00+08:00">2019-11-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-25 00:39" itemprop="dateModified" datetime="2019-11-25T00:39:53+08:00">2019-11-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h3><h3 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h3><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>辗转法，不断用变量的新值代替旧值的过程。</p><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><ul><li><strong>划分</strong>。把规模为N的原问题划分为K个规模较小的子问题，并尽量使K个字问题的规模大致相等。</li><li><strong>求解子问题</strong>。子问题的解法通常与原问题是相同的，可以用递归的方式求解，当子问题较小时，可以直接求解（或更快方式求解）。</li><li><strong>合并</strong>。把各个子问题的解合并起来。分治算法有效性很大程度上依赖于合并的实现。</li></ul><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>每一次获得局部最优解，若下一个数据与局部最优解连在一起不再时可行解，就不把该数据添加到局部解中，直到所有数据枚举完，或者不再添加为止。（需要选择度量方式）</p><ul><li><strong>多阶段决策</strong>：指解决问题过程可分为若干阶段，在每一个阶段都做出相应的决策，所有的决策构成序列就是问题的解决方案。</li><li><strong>无后向性</strong>：指每一个阶段面临的问题都是原问题的一个子问题，并且子问题的解决只与当前阶段和以后的决策有关，与以前各阶段的决策无关。</li><li><strong>最优化原理</strong>：指一个问题的最优策略有这样一个性质，即不论以前的决策如何，对于当前的子问题，其余决策一定构成最优策略。</li></ul><h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><p>求解的问题必须满足：</p><ol><li>问题的状态必须满足最优化原理</li><li>问题中的状态必须满足无后向性（下一个状态只与当前状态有关，与当前状态之前的状态无关）</li></ol><ul><li><strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干阶段。在阶段划分时，注意划分后的阶段一定要是有序或者时可排序的，否则问题就无法求解。</li><li><strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处的客观情况用户不同的状态表示出来。当然状态的选择要满足无后效性。</li><li><strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。做法时根据相邻两阶段各状态之间的关系来确定决策。</li><li><strong>寻找边界条件</strong>：给定状态转移方程时一个递推式，需要一个递推的终止条件或边界条件。</li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>若当前位置探测到一条通路则继续向前，若在当前位置探测不到一条通路则回溯至前一位置继续探测尚未探测的方向，直到找到一条通路或探测出无通路存在为止。</p><ul><li>定义一个解空间，它包含问题的解</li><li>利用适于搜索的方法组织解空间</li><li>利用深度优先法搜索解空间</li><li>利用限界函数避免移动到不可能产生解的子空间</li></ul><p>问题的解空间通常时在搜索问题的解的过程中动态产生的。适用于解一些组合数较大的问题。</p><h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><p>一般采用广度优先策略或者最大收益（或者最小损耗）策略，同时利用最优解属性的上下界来控制搜索的分支。</p><p>基本思想是对有约束条件的最优化问题的所有可行解空间进行搜索。</p><p>具体执行时，把全部可行解空间不断分割为越来越小的子集（称为分支），并为每个子集内的解的值计算一个下界或上界，每次分支后，对凡是界限超出已知可行解值的那些子集不再做进一步分支。</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul><li><a href="https://feiybox.com/2019/11/23/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%BA%8C%EF%BC%89/">笔记整理——计算机网络（笔记整理三之二)</a></li><li><a href="https://feiybox.com/2019/11/25/%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%89%E4%B9%8B%E4%B8%89%EF%BC%89/">笔记整理——计算机操作系统（笔记整理三之三）</a></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/10/27/%E5%B7%A5%E4%BD%9C%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/10/27/%E5%B7%A5%E4%BD%9C%E6%B2%9F%E9%80%9A%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">工作沟通技巧笔记</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-27 12:10 / 修改时间：12:14" itemprop="dateCreated datePublished" datetime="2019-10-27T12:10:00+08:00">2019-10-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h3><p>封闭式问题：以动词开头，回答为有限选项。（拿自己的信息出来核对）</p><ul><li>校验自己的信息过滤器/观点等是否正确</li><li>自己为信息的唯一提供者，只能核对自己掌握的信息</li><li>可使目标信息更容易定位</li></ul><p>开放式问题：以谁/为什么/哪一个/什么/哪里/何时/如何开头，回答开放不定方向。（获得别人的信息）</p><ul><li>着眼于对方，将对方视为资源中心</li><li>对方表达信息较多</li><li>为自己提供更多信息，更宽广的视野</li></ul><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>反馈：</p><ul><li>我看见/听见……（观察到的行为及事实）</li><li>我认为……（观点和感受）</li><li>你是怎么想的呢？/你觉得呢？/你能理解么？</li><li>我建议/希望……</li></ul><p>会议：</p><ul><li>形成结论与总结</li><li>形成todo并以邮件方式周知各位参加者</li></ul><p>倾听：</p><ul><li>目光接触</li><li>关注，不做别的事</li><li>回应（点头、嗯、肯定、提问）</li><li>同理心倾听/共情</li><li>不要抢话头</li></ul><p>总结：</p><ul><li>让别人知道你在倾听</li><li>鼓励他们更多表达</li><li>核对理解是否正确，减少误解</li><li>梳理架构与思路</li><li>使对方停止谈话（谈话松散等较多时）</li><li>拉近彼此距离</li></ul><p><strong>事情 -&gt; 结果 -&gt; 反馈， 形成闭环</strong></p><ol><li>接到任务 -&gt; 善于提问</li><li>项目启动 -&gt; 降低过滤器影响</li><li>参加会议 -&gt; 随时反馈</li><li>会议总结 -&gt; 使用合适的工具</li><li>日常沟通 -&gt; 倾听与总结</li><li>打破困境 -&gt; 3A（找对对方的关注点；能量场一致；果敢表达，观点明确）</li><li>闭环反馈 -&gt; 做一个靠谱的人</li></ol><p>对一沟通：</p><ul><li>通过拉上相关同学拉一个较小的群沟通</li></ul><p>对多沟通：</p><ul><li>拉群</li><li>和相关同学逐一私下约时间组织会议</li><li>会议后总结发群（涉及todo等发送邮件）</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/09/08/%E5%8F%91%E5%8F%91%E7%89%A2%E9%AA%9A%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E7%99%BD%E9%B9%BF%E5%8E%9F%E3%80%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/09/08/%E5%8F%91%E5%8F%91%E7%89%A2%E9%AA%9A%E2%80%94%E2%80%94%E8%AF%BB%E3%80%8A%E7%99%BD%E9%B9%BF%E5%8E%9F%E3%80%8B/" class="post-title-link" itemprop="url">发发牢骚——读《白鹿原》</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-08 00:25 / 修改时间：00:26" itemprop="dateCreated datePublished" datetime="2019-09-08T00:25:00+08:00">2019-09-08</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>《白鹿原》被誉为一个民族的秘史。在读完后，能够明显感受到名不虚传。白鹿原讲述了半个世纪里在白鹿原上发生的事情。</p><p>我已经很长一段时间里，不涉及与历史相关的事情了，或许是因为我在看了《明朝那些事儿》后，开始明白，我讨厌那些史书上讲述简短几句，描述平平无奇的一场变动。每本书都有自己所处于的角度，只是我无法适应这种角度罢了。</p><p>读完一本书后，我总是在考虑我从这本书中得到了什么？不停的思考。就这本书中，确实有多处都让我得到了一些。比如终于找到了一本，以平凡人的一生来描述的历史了。终于明白需要更加清醒的认识问题，书中所树立的朱先生的偶像，或许正是多数人所崇拜的，刚正不阿。</p><p>在不断思考我获得从书中获得了什么时，突然发现，我一直考虑掉了，我期望获得什么？我内心究竟期望从书中获得什么？我是抱着怎么一种心态来看这本书的呢？</p><p>其实，我只是感觉这本书有趣，所以看这本书并不应该在意获得了什么？看书就应该当作闲时来的味剂。</p><p>每次看到别人的一辈子如何去过活时，我也开始思考，我的这辈子怎么过活。我终究现在还不明白我究竟要选择怎样的一种生活？从小到大以来，我的选择都是顺从着现实而来的，没有换一个角度，顺从心的角度来选择。我的心里依然迷惘，我该选择如何过活下去？</p><p>我顺其自然的成为了一名程序员，顺其自然的开始写代码，并且顺其自然的喜欢代码。但是我不明白，我选择代码是否正确。正如我有时候在提醒自己，不能太沉入代码了？换一个角度或者提升一个高度可以看到另一个问题，或者可以更加明白问题的本源。</p><p>顺其自然的成为现在的我的状态。其实也有本质原因，没有财富自由，也没有那种为了财富自由的拼命三郎的精神。总之，我还不明白我究竟想做什么。</p><p>已经不会写读后感了，只是我随便发的牢骚。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/07/22/%E4%BB%A5%E4%B8%80%E9%A2%97%E8%89%BA%E6%9C%AF%E7%9A%84%E5%BF%83%E5%81%9A%E4%BA%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/07/22/%E4%BB%A5%E4%B8%80%E9%A2%97%E8%89%BA%E6%9C%AF%E7%9A%84%E5%BF%83%E5%81%9A%E4%BA%8B/" class="post-title-link" itemprop="url">以一颗艺术的心做事</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-22 00:21 / 修改时间：00:22" itemprop="dateCreated datePublished" datetime="2019-07-22T00:21:00+08:00">2019-07-22</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在理发时，突然想到，对于理发师来说，理发究竟是什么？他们是一种什么样的心来理发的呢？是敷衍了事，还是精益求精，还是有一定的心情波动呢？</p><p>其实可以类推，对我来说，写代码是一种生活必要的工作技能。写代码的时候都是严谨并全身心的投入的。以一种设计的方式来实现功能。</p><p>以一颗艺术的心做事。其中有两个要点，第一点是做事，第二点是以艺术的心来做。</p><p>做事，就是实现原本的目的。比如理发，第一目的是将头发以某种方式剪短，如果不管以什么方式来设计或者什么手法来表演，没有讲头发剪短都不能称为理发。不能实现目的的设计或艺术都是没有意义的。因此不管自己拥有多高的设计灵感，没有实现本来目的都没有意义。</p><p>以艺术的心做事。为何以艺术的心做事？如何能将一件事做的很好，那便是有技巧的且仔细的去做。那么和别人来做有什么差别呢？因此需要找到自己做事情的特色，我认为艺术便是一种特色。每个人都有自己的特色，因此在事情上也会体现出自己相对应的特色。比如理发，理发师会表现出自己对于别人头型适用哪种发型做自己建议，以及哪种方式的剪法会看起来优美。正如设计代码一样，如何写出一份自己特色的代码，并且让别人看着赏心悦目。</p><p>艺术的心做事，其实主要在于自己对于“事”本身的理解会有多深了。刚开始只能做到做事的这个程度，随着自己对于做事的深入了解，明白如何更加严谨的做事。再后来，就开始考虑如何设计“事”这个本身，以及按照自己的喜好来做事。总的来讲，需要加深自己对于做事的理解。</p><p>我有时候会偏离自己做事的主题，在不断的考虑如何“做好”这件事，太过于注重设计与优美，而有时候忘了做事的本身。自己在考虑以一颗艺术的心做事时，需要多考虑事这个本身，自己这样做是否事真的围绕着做事这个本身来进行的。或者多问自己几遍——“你真的想做的是什么？真的想做的是这个吗？”。</p><p>以一颗艺术的心做事，首先是做事，其次是以艺术的心来做。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/07/13/%E8%AF%BB%E3%80%8A%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F%E3%80%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/07/13/%E8%AF%BB%E3%80%8A%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F%E3%80%8B/" class="post-title-link" itemprop="url">读《杀死一只知更鸟》</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-13 14:54 / 修改时间：17:46" itemprop="dateCreated datePublished" datetime="2019-07-13T14:54:00+08:00">2019-07-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="知更鸟代表什么"><a href="#知更鸟代表什么" class="headerlink" title="知更鸟代表什么"></a>知更鸟代表什么</h4><p>为什么书名为“杀死一只知更鸟”？知更鸟代表的是什么？</p><blockquote><p>阿蒂克斯有一天对杰姆说：“我宁愿你在后院射易拉罐，不过我知道，你肯定要去打鸟的。你射多少蓝鸟都没关系，但要记住，杀死一只知更鸟就是一桩罪恶。”</p></blockquote><p>为什么杀死一只知更鸟就是一桩罪恶呢？首先这种事需要反过来考虑，为什么要杀死知更鸟，对孩子来说，只是为了好玩。并且知更鸟是一种无害的鸟。因此杀死一只知更鸟就象征着杀死一个无辜的人。</p><p>在书中三十章，经历尤厄尔先生的死后，斯库特同意泰特先生的做法。</p><blockquote><p>“噢，如果是那样做，差不多就像杀死一只知更鸟，不是吗？”</p></blockquote><p>在这儿，虽然拉德利保护杰姆和斯库特而杀了尤厄尔。不管如何理清这件事情，都会打破拉德利的隐居生活。</p><blockquote><p>在我看来，一个对你和全镇做过这么大贡献的人，无视他的隐居习惯，把他硬拉去曝光——对我来说，这就是犯罪。</p></blockquote><h4 id="做孩子的榜样"><a href="#做孩子的榜样" class="headerlink" title="做孩子的榜样"></a>做孩子的榜样</h4><p>从书中而来，领悟最多的就是，如何做孩子的榜样。有人说过，孩子就是父母的影子，会参照父母做的去做。做孩子的榜样，需要有书中所描述的教养、勇气、平等。</p><p>曾看到一张图，一家人在地铁排队给孩子做榜样。教养便是一些潜移默化的事情影响，以及父母对孩子的引导。在现代里，越来越多的父母对孩子只注重成绩，并不在意其他思维、个性等成长。就我来说，从小在个性上就有很大的缺陷，在交流上一直不够好，便一直影响自己。</p><blockquote><p>当你还未开始就已经知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。你很少赢。但有时也会。</p></blockquote><p>对孩子，需要培养他们的勇气，当然需要好好区分出勇气与胆大妄为。</p><p>当两个孩子发生矛盾后，你该如何做？不管怎样，都应该首先听两个孩子的所有诉说，不应该只听某一个孩子的片面之词。也不应该说什么年龄大的孩子就应该迁就着小的孩子。对孩子来说，期望得到的就是公平。他们希望得到的是公平的对待。</p><p>当然，需要向孩子展现出对正义的向往。</p><blockquote><p>当你最终了解他们时，你会发现，大多数人都是好人。</p></blockquote><p>总结来说，做好榜样有太多需要注意了，最重要的还是需要培养一颗有趣且爱着这个世界的心。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/06/03/Redis%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/06/03/Redis%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Redis总结</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-06-03 00:57" itemprop="dateCreated datePublished" datetime="2019-06-03T00:57:00+08:00">2019-06-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-12-07 00:42" itemprop="dateModified" datetime="2020-12-07T00:42:47+08:00">2020-12-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为什么我会学习Redis？</p><p>原因很简单，因为工作上需要使用。因此在不懂其原理以及其特性的情况下使用，会在一些情况下使用错误，以及造成一些错误的影响。理解工具的原理才能更好的使用工具。</p><p>本文主要为读《Redis开发与运营》的总结，以及一些扩展。<strong><em>本文总结较长，建议使用电脑，按照目录择章阅读。</em></strong></p><hr><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>Redis中主要提供5种数据结构</strong>：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）。并且基于字符串的基础上演变出了Bitmaps（位图）、HyperLogLog。随着LBS（基于位置服务）发展，在Redis3.2中加入了GEO（地理信息定位）。</p><p>同时，Redis支持键过期、发布订阅、Lua脚本、简单事物、流水线（Pipeline）功能。</p><p><strong>Redis为什么速度快？</strong>1、Redis中所有的数据都是存储在内存中；2、Redis使用C语言实现；3、Redis使用单线程架构，预防多线程可能产生的竞争问题。</p><p>Redis中每个类型有多种的内部编码，通过<code>object ebcoding</code>命令查询内部编码。Redis中对每个数据结构，在内部根据不同的情况，使用不同的内部编码实现，可以在不同情况下发挥自己各自的优势。</p><h4 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h4><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><p>设置值：<code>set key value [ex seconds] [px millesenconds] [nx|xx]</code>（nx：键必须不存在才能设置成功，xx反之）。<code>setex = set ex</code>，<code>setnx = set nx</code>。批量设置值：<code>mset key value [key value ...]</code>.</p><p>获取值: <code>get key</code>。批量获取值：<code>mget key [key ...]</code>。</p><p>注意：每次批量操作所发送的键数不是无节制的，如果数量过多可能造成Redis阻塞或者网络拥塞。</p><p>自增: <code>incr key</code>。</p><h5 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h5><ol><li>int 8个字符的长整型</li><li>embstr 小于等于39个字节的字符串</li><li>raw 大于39个字节的字符串</li></ol><h4 id="hash（哈希）"><a href="#hash（哈希）" class="headerlink" title="hash（哈希）"></a>hash（哈希）</h4><h5 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h5><p>设置值：<code>hset key field value</code>。批量设置值：<code>hmset key field value [field value...]</code>。</p><p>获取值：<code>hget key field</code>。批量获取值：<code>hmget key field [field ...]</code>。</p><h5 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h5><ul><li>ziplist（压缩列表）</li><li>hashtable（哈希表）</li></ul><p>当field个数较少且没有大value时，内部编码为ziplist；当value大于64字节，转变为hashtable；当field个数超过512，内部编码变为hashtable。</p><h5 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h5><p>扩容是一个很有趣的地方。相对于ConcurrentHashMap的<strong>多线程协同式rehash</strong>，Redis采用<strong>单线程渐进式rehash</strong>。多线程协同rehash可以参照<a href="https://feiybox.com/2018/10/06/ConcurrentHashMap-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Java-version-1-8%EF%BC%89/">《ConcurrentHashMap 源码分析（Java version 1.8）》</a>的扩容部分。</p><p>而单线程渐进式rehash，主要是将拷贝节点数据的过程平摊到后续的操作中，而不是一次性拷贝。其过程是，在写的时候，当发现正在扩容，则负责将目前元素执行的老的哈希桶的元素，迁移到新的hash中，如果发现已经迁移完成则不操作。</p><p>而在读的时候，则先查询老的hash中是否有数据，没有则查找新的hash中。</p><p><strong>单线程渐进式rehash和多线程协同式rehash对比</strong>：</p><ul><li>ConcurrentHashmap的整个扩容操作，消耗时间短，因此对内存的占用也更短；</li><li>写操作中，Redis会更快返回，因此多线程协同会去协助扩充操作；</li><li>读操作中两者基本相似。</li></ul><p>在Redis的本身是单线程执行中，采用了这种设计方式，刚好使用空间兑换了时间的做法，完美避免了阻塞。而ConcurrentHashmap中，实现了多线程下的安全性，并通过多线程协作的方式，减短了在写操作时为了保证线程安全性的阻塞时长。</p><h4 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h4><ol><li>列表中的元素是有序的；</li><li>列表中的元素可以是重复的。</li></ol><h5 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h5><p>设置值：<code>rpush key value [value ...]</code>; <code>lpush key value [value ...]</code>。</p><p>插入元素：<code>linsert key before|after pivot value</code>。顺序找到第一个等于该值的元素，在前面或者后面插入元素。</p><p>获取值：<code>lrange key start end</code>: 获取key对应value内指定范围的元素列表（左右都取闭区间）。</p><p>修改值：<code>lset key index rewValue</code>，修改指定索引下标的元素。</p><p>删除元素：<code>lrem key count value</code>，从列表中找到等于value的元素进行删除。</p><ul><li>count &gt; 0，从左到右，删除最多count个元素；</li><li>count &lt; 0，从右到左，删除最多count绝对值个元素；</li><li>count = 0，删除所有。</li></ul><p><code>lpop key</code>; <code>rpop key</code>.</p><p><code>blpop key [key ...] timeout</code>; <code>brpop key [key ...] timeout</code>。如果存在则直接返回，如果不存在则等待timout时间，timeout为0则代表一直阻塞。</p><h5 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h5><ul><li>ziplist（列表元素个数小于512，同时值都小于64字节）</li><li>linkedlist</li><li>quicklist（Redis 3.2版本提供。简单说是一个以ziplist为节点的linkedlist，结合了两者的优势）</li></ul><h4 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h4><h5 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h5><p>增加值：<code>sadd key element [element ...]</code></p><p>删除值：<code>srem key element [element ...]</code></p><p>随机弹出元素：<code>spop key</code>，需要注意这个并不删除元素。</p><p><strong>集合操作</strong>：</p><ul><li>求交集：<code>sinter key [key ...]</code></li><li>求并集：<code>sunion key [key ...]</code></li><li>求差集：<code>sdiff key [key ...]</code>（相当于并集减交集）</li></ul><p>使用<code>sinterstore destination key [key ...]</code>、<code>sunionstore ...</code>、<code>sdiffstore ...</code>运算交集、并集、差集的结果并保存。（集合间操作在元素比较多的情况下会比较耗时，因此Redis提供计算并存储命令，计算结果保存到destination key中）。</p><h5 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h5><ol><li>intset（整数集合），当集合元素是整数且元素个数小于512时</li><li>hashtable</li></ol><h4 id="zset（有序集合）"><a href="#zset（有序集合）" class="headerlink" title="zset（有序集合）"></a>zset（有序集合）</h4><h5 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h5><p>增加值：<code>zadd key score member [score member ...]</code>，集合通过score排序。</p><p>注意：Redis 3.2中添加了nx（不存在才能设置成功）、xx（与nx相反）、ch（返回此次操作后集合中的元素和分数发生变化的个数）、incr（对score增加，相当于zincry）选项。</p><p>返回指定排名范围的成员：<code>zrange key start end [withscores]</code>，按照分数从低到高返回; <code>zrevrange key start end [withscores]</code>，按照分数从高到低返回。start和end都是闭区间。</p><p>返回指定分数范围的成员：<code>zrangebyscore key min max [withscores] [limit offset count]</code>，按照分数从低到高返回；<code>zrevrangebyscore</code>反之。<code>[limit offset count]</code>可以限制输出的起始位置和个数。</p><p>min和max支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大。</p><p><strong>集合操作</strong>：</p><ul><li>交集：<code>zinstore destination numkeys key [key ...] [wights weight [weight ...]] [aggregate sum|min|max]</code>。<ul><li><code>numkeys</code>：需要做交集计算键的个数；</li><li><code>key [key ...]</code>：需要做交集计算的键；</li><li><code>wights weight [weight ...]</code>：每个键的权重，在做交集计算时，每个键中的每个member会将自己的分数乘以这个权重，每个键的权重默认时1。</li><li><code>aggregate sum|min|max</code>：计算成员交集后，分值按照sum、min、max做汇总，默认值是sum。</li></ul></li><li>并集：<code>zunionstore destination numkeys keu [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code>。</li></ul><h5 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h5><ol><li>ziplist，有序集合元素个数小于128，且每个元素的值都小于64</li><li>skiplist</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="键重命名"><a href="#键重命名" class="headerlink" title="键重命名"></a>键重命名</h5><p><code>rename key newkey</code>、<code>renamenx ...</code></p><p>由于重命名健期间会del命令删除旧的键，如果键对应的值比较大，会存在阻塞Redis的可能。</p><h5 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a>键过期</h5><p><code>expire key seconds</code>: 键在seconds秒后过期；<code>expireat key timestamp</code>: 键在秒级时间戳timestamp后过期。</p><p>对于字符串类型键，执行set命令会去掉过期时间；set时需要重新设置过期时间。</p><p>setex是set + expire的组合，<strong>原子操作</strong>，并且减少了一次网络通讯时间。</p><p>注意：Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能。</p><h5 id="迁移键"><a href="#迁移键" class="headerlink" title="迁移键"></a>迁移键</h5><ul><li>move（基本废弃）</li><li>dump + restore<ul><li>整个迁移过程中不是原子性的，而是通过客户端分步完成的；</li><li>迁移过程中的是开启了两个客户端的连接，所以dump的结果不是在源Redis和目标Redis之间进行传输（通过客户端）。</li></ul></li><li>migrate<ul><li>实际上migrate就是将dump、restore、del三个命令进行组合，简化了操作流程。</li><li>migrate具有原子性</li><li>migrate命令的数据传输直接在源Redis和目标Redis上完成。目标Redis完成Restore后发送OK给源Redis，源Redis会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</li></ul></li></ul><h5 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h5><p>keys支持pattern匹配，进行全量遍历。会阻塞Redis。</p><p>scan采用渐进式遍历来解决keys命令可能带来的阻塞问题，每次执行scan命令的时间复杂度是O(1)，真正要实现keys的功能需要多次scan。</p><p>对于可能产生阻塞问题的hgetall、smembers、zrange等，都用对应的hscan、sscan、zscan命令。</p><p>注意：scan并不能保证遍历出所有的键。（遍历过程中某些键发生变化时，可能会有没遍历出来某个键或者遍历出重复键情况）</p><hr><h3 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h3><h4 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h4><p><code>slowlog-log-slower-than</code>配置（单位微秒）：通过这个配置，如果命令执行时间大于这个预设值，则记录到慢查询日志中。注意，<code>slowlog-log-slower-than=0</code>会对记录所有的命令，而小于0则代表对任何命令都不进行记录。</p><p><code>slowlog-max-len</code>：代表慢查询日志最多存储多少条，这是一个先进先出队列。</p><p>配置建议：</p><ul><li>可以增大<code>slowlog-max-len</code>的配置，并不会占用大量内存。</li><li><code>slowlog-log-slower-than</code>的默认配置是10ms。对于高QPS场景的Redis建议设置成1ms。（实际客户端执行的时间等于命令执行时间以及网络传输等时间，因此大于实际执行时间）</li></ul><h4 id="Redis-Shell"><a href="#Redis-Shell" class="headerlink" title="Redis Shell"></a>Redis Shell</h4><ul><li>redis-cli（及相关参数）</li><li>redis-server</li><li>redis-benchmark（为Redis做基准性能测试）</li></ul><h4 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h4><p>Pipeline（流水线）操作可以减少网络传输，实现通过一次网络传输执行多个Redis命令。目前如mget、mset等批量操作也可以有效减少网络延时（RTT）。</p><p>不得不说其区别，mget、mset是只能在一个批量操作中执行get、set的一类操作，并且其执行是原子性的，而Pipeline没有对执行命令的限制，而执行也不是原子性的。后续会讲到在Redis Cluster中建议都使用Pipeline的操作。</p><p>Pipeline执行时，需要注意其中命令的数量，命令数量过多，会加大客户端等待时间，也会造成一定的网络阻塞。建议将一个大的Pipeline操作拆分成几个小的Pipeline完成。</p><h4 id="事务与Lua"><a href="#事务与Lua" class="headerlink" title="事务与Lua"></a>事务与Lua</h4><p>事务：<code>multi</code>、<code>exec</code>、<code>discard</code>。Redis提供<code>watch</code>命令来确保事务中的key没有被其他客户端修改过。</p><p>Lua脚本优点：</p><ul><li>原子性，Lua脚本在Redis中的执行是原子性的</li><li>开发人员可以自定义命令</li><li>可以将多条命令一次性打包，有效减少网络开销</li></ul><p>注意：在执行中，如果Lua脚本已经执行过写操作，那么script kill将不会生效。（这种情况下只能等待执行结束，或者停掉Redis服务）</p><h4 id="Bitmaps和HyperLogLog"><a href="#Bitmaps和HyperLogLog" class="headerlink" title="Bitmaps和HyperLogLog"></a>Bitmaps和HyperLogLog</h4><p>Bitmaps本质是字符串，但是可以对字符串的位进行操作。</p><p>HyperLogLog是一种基数算法，可以利用<strong>极小的内存空间</strong>完成<strong>独立总数的统计</strong>。Redis官方给出0.81%的失误率。</p><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p><code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>。Redis不会对发布的消息进行持久化，无法实现消极堆积、回溯等。不够专业但足够简单。</p><h4 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h4><p>Redis 3.2中提供了GEO功能，用来实现基于地理位置信息的应用，底层实现是zset。</p><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>客户端与服务端之间的通信协议是基于TCP协议构建的。</li><li>通过RESP（Redis系列化协议）实现客户端与服务端的正常交互。</li></ul><p>通过直连的方式无法限制Redis客户端对象的个数，在极端情况下可能造成连接泄露，而连接池的形式可以有效的保护和控制资源的使用。（直连的方式，适用与少量长期连接的场景；连接池的方式，降低了开销，并且对资源的使用进行了保护和控制）。Redis提供maxclients参数限制客户端连接数，默认值是1000，如果连接数超过，则新的连接将被拒绝。</p><p>Jedis连接池使用时，将连接池大小设置为比默认最大连接数（8个）多一些即可。</p><p>Redis为每个客户端分配了<strong>输入缓存区</strong>，作用是将客户端发送的命令临时保存，通过Redis会从输入缓存区拉取命令并执行，输入缓存区为客户端发送命令到Redis执行命令提供缓冲功能。要求每个客户端缓冲区的大小不能超过1G，超过后客户端将被关闭。</p><p>Redis为每个客户端分配了<strong>输出缓冲区</strong>，作用是保存命令执行的结果返回客户端，为Redis和客户端交互返回结果提供缓冲。输出缓冲区分为3种：普通客户端、发布订阅客户端、slave客户端。</p><p>输出缓冲区由两部分组成：固定缓冲区（16KB）、动态缓冲区。固定缓冲区使用的是字节数组，动态缓冲区使用的是列表。</p><hr><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis支持RDB和AOF两种持久化机制。</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>手动触发对应<code>save</code>和<code>bgsave</code>命令。<code>save</code>会阻塞当前Redis服务，直到RDB过程完成为止，已经废弃。`bgsave是在Redis进程执行fork操作创建子进程，然后由子进程负责RDB过程，并自动结束，阻塞只发生在fork阶段。</p><p><img src="/2019/06/03/Redis总结/bgsave.jpg" alt="bgsave"></p><p>Redis默认采用LZF算法对RDB文件进行压缩处理。</p><h5 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h5><p>优点：</p><ul><li>RDB是一个紧凑的压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等。</li><li>Redis加载RDB恢复数据远远快于AOF的方式</li></ul><p>缺点：</p><ul><li>RDB方式数据没办法做到实时持久化/秒级持久化。</li><li>RDB文件使用特定的二进制格式保存。因版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新格式的问题。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。主要解决了数据持久化的实时性。</p><ul><li>所有的写入命令都会追加aof_buf（缓冲区）中。</li><li>AOF缓冲区根据对应的策略向硬盘中做同步操作。</li><li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li><li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ul><p>AOF采用文本协议格式，并将命令直接追加在aof_buf中。先写入缓冲区aof_buf中，Redis可以提供多种缓冲区同步到硬盘的策略，在性能和安全性方面做出平衡。</p><ul><li>aways：命令写入aof_buf中后调用系统fsync操作同步到AOF文件，fsync完成后线程返回。</li><li>erverysec：fsync同步文件操作由专门线程每秒执行一次</li><li>no：同步操作由操作系统负责，通常同步周期最长30秒</li></ul><p>AOF重写机制用来压缩文件体积。重写过程可以手动触发和自动触发。</p><p>在AOF重写中，会从父进程fork出子进程，子进程执行AOF重写。这段时间主进程继续响应命令，Redis使用“AOF重写缓冲区”保存这部分新数据，防止新AOF文件生成期间丢失这部分数据。</p><p>Redis使用另一条线程每秒执行fsync同步硬盘，当系统硬盘资源繁忙时，会造成Redis主线程阻塞。</p><p><img src="/2019/06/03/Redis总结/everysec刷盘策略.jpg" alt="everysec刷盘策略"></p><p>由上图刷盘策略发现：</p><ul><li>erverysec配置最多可能丢失2秒数据，不是1秒。</li><li>如果系统fsync缓慢，将会导致Redis主线程阻塞影响效率。</li></ul><p>注：单机下部署多个实例时，为了防止出现多个子进程执行重写操作，建议做隔离控制，避免CPU和IO资源竞争。</p><hr><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>复制功能是高可用Redis的基础。</p><p>salveof: 从从节点发起，当前服务丢弃旧有数据集，同步新数据集。</p><p>slave no one：断开复制。</p><p>如果要求低延迟时，建议同机架或同机房部署并关闭<code>repl-disable-tcp-nodelay</code>；如果考虑高容灾性，可以同城跨机房部署并开启<code>repl-disable-tcp-nodelay</code>（在主节点设置）。</p><h4 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h4><p>拓扑可以分为三种：一主一从、一主多从、树状主从结构。</p><p>一主一从：主节点出现宕机时从节点提供故障转移支持。当应用写命令并发量较高且需要持久化时，可以只在从节点上开启AOF。（需要避免主节点脱机重启，重启前需要断开主从关系，避免从节点的数据被清空）。</p><p>一主多从：主要用于读多写少的读写分离场景。</p><p>树状结构：引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>首先，执行slaveof的复制过程：</p><ul><li>保存主节点信息</li><li>主从建立socket连接</li><li>发送ping命令（检测主从之间网络嵌套字是否可用；检测主节点当前是否可接受处理命令。）</li><li>权限验证</li><li>同步数据集（首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作时耗时最长）</li><li>命令持续复制</li></ul><p>从节点（slave）内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接。</p><p>数据同步分为全量复制和部分复制。全量复制一般用于初次复制场景，当数据量较大时，会对主从节点和网络造成很大的开销。部分复制，用于处理在主从复制中因网络闪断等原因造成的数据丢失场景。</p><p>部分复制命令<code>psync</code>需要哪些组件支持呢？</p><ul><li>主从节点各自的复制偏移量<ul><li>主节点（master）在处理完写命令后，会把命令的字节长度做累加记录，统计信息在<code>info replication</code>中的<code>master_repl_offset</code>指标中。</li><li>从节点（slave）每秒上报自身的复制偏移量给主节点。（主节点也会保存从节点的复制偏移量）</li><li>通过比较主从节点的复制偏移量，可以判断主从节点数据是否一致。同时判断当前复制的健康度。</li></ul></li><li>主节点复制积压缓冲区<ul><li>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB。（先进先出的固定长度队列）</li></ul></li><li>主节点运行id<ul><li>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。主要用来唯一识别Redis节点。</li><li>主节点重启变更了整体数据集（如替换RDB/AOF文件）从节点再基于偏移量复制数据将是不完全的，因此当运行ID变化后从节点将做全量复制。（需要注意Redis关闭再启动后，运行ID会变，因此会全量复制。）</li></ul></li></ul><p><code>psync {runId} {offset}</code>：runId指从节点所复制主节点运行id，默认值为<code>?</code>；offset指从节点已复制的数据偏移量，默认值为-1。主节点根据psync参数和自身数据情况决定响应结果。</p><ul><li><code>+FULLRESYNC {runId} {offset}</code>：从节点进行全量复制</li><li><code>+CONTINUE</code>：部分复制</li><li><code>+ERR</code>：主节点版本低于Redis 2.8。无法识别psync命令，从节点将发送旧版sync命令触发全量复制流程。</li></ul><h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p><img src="/2019/06/03/Redis总结/全量复制.jpg" alt="全量复制"></p><p>在传输RDB文件这步上非常耗时，可以通过日志算出RDB文件从创建到传输完成消耗的总时间。如果总时间超过<code>repl-timeout</code>所配制的时间（默认60秒），从节点将放弃接受RDB文件并清理已经下载的临时文件，导致全量复制失败。</p><p><strong>无盘复制</strong>：为了降低主节点磁盘开销，Redis支持无盘复制，生成的RDB文件不保存到磁盘而直接通过网络发送给从节点。适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。</p><p>在RDB文件创建到传输完成这段时间内的写命令，主节点将这些命令数据存在复制缓冲区。如果这段时间过长，对于高写入的场景容易造成主节点复制客户端缓冲区溢出。（默认为60秒缓冲区消耗持续大于64MB或者直接超过256MB）。运维人员需要根据主节点数据量和写命令并发量调整<code>client-output-buffer-limit slave</code>配置，避免全量复制期间客户端缓冲区溢出。</p><p>对于读写分离场景，Redis复制提供<code>slave-server-stale-data</code>参数（默认开启），复制期间，冲节点依然可以响应所有命令。</p><p>总结，全量复制整体时间分为几个部分。</p><ul><li>主节点bgsave时间</li><li>RDB文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载RDB时间</li><li>可能的AOF重写时间</li></ul><h5 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h5><p><img src="/2019/06/03/Redis总结/部分复制.jpg" alt="部分复制"></p><p>当主从节点间网络出现中断，如果超过<code>repl-timeout</code>时间。主节点会认为从节点故障并中断复制连接。</p><p>部分复制中，主节点内部存在复制积压缓冲区，可以保存最近一段时间的写命令数据，默认最大缓存1MB。</p><h5 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h5><p>主从节点都有心跳检测机制，各自模拟成对方的客户端进行通信。</p><p>主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。</p><p>从节点在主线程中每隔1秒发送<code>replconf ack {offset}}</code>命令，上报自身的复制偏移量。其主要作用有：1）实时监测主从节点网络状态；2）上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据；3）实现保证从节点的数量和延长性功能。</p><p>为了降低主从延迟，一般把Redis主从节点部署在相同的机房/同城机房，避免网络延迟和网络分区造成的心跳中断等情况。</p><p>Redis主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成的。</p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><p>读写分离：将读流量分摊到从节点上，只对主节点执行写操作。其中可能会遇到一些问题：1）复制数据延迟；2）读到过期数据；3）从节点故障。</p><p>注意：避免复制风暴。复制风暴指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制。</p><hr><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p><code>mem_fragmentation_ratio</code>表示内存碎片，当大于1时，代表有内存碎片。如果这个值特别大，说明碎片率相当严重。当小于1，一般出现在操作系统把Redis内存交换（Swap）到硬盘导致，这种情况需要格外注意，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死。</p><h4 id="消耗"><a href="#消耗" class="headerlink" title="消耗"></a>消耗</h4><p>Redis进程内消耗主要包括：自身内存 + 对象内存 + 缓冲内存 + 内存碎片。一个空的Redis进程消耗内存可以忽略不计。</p><p>对象内存，存储用户所有的数据。在使用Redis时很容易忽略键对内存消耗的影响，应当避免使用过长的键。</p><p>缓冲内存主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。</p><p>客户端缓冲区指所有接入到Redis服务器TCP连接的输入输出缓冲。其中分为多种客户端。1）普通客户端：指除了复制和订阅的客户端之外的所有连接，Redis默认没有对普通客户端的输出缓冲区做限制，一般普通客户端的内存消耗可以忽略不计；2）从客户端：主节点为每个从节点单独建立一条连接用于复制命令，建议主节点挂载从节点不要多于2个，主节点不要部署在较差的网络环境下；3）订阅客户端。</p><p>复制积压缓冲区在整个主节点只有一个，所有从节点共享此缓冲区。可以设置较大的缓冲区空间，这个部分投入可以有效避免全量复制。</p><p>内存碎片：在 1）频繁做更新操作和2）大量过期键删除，键对象过期删除后，释放的空间无法得到充分的利用的情况下，容易出现高内存碎片问题。其中解决方式有数据对齐和安全重启。</p><p>子进程内存消耗：子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗。</p><ul><li>Redis产生的子进程并不需要消耗1倍的父进程内存，实际消耗根据期间写入命令量决定，但是依然要预留一些内存防止溢出；</li><li>需要设置<code>sysctl vm.overcommit_memory=1</code>允许内核可以分配所有的物理内存，防止Redis进程执行fork时因系统剩余内存不足而失败；</li><li>排查系统是否支持并是否开启THP。</li></ul><h4 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h4><p><code>maxmemory</code>最大可用内存。主要用于缓存场景（超过后使用LRU释放空间），防止内存超过服务器物理内存。Redis支持动态修改maxmemory值，可以动态伸缩Redis内存。（Redis默认无限使用服务器内存，为了防止极端情况，建议所有的Redis进程都配置该值）</p><p>Redis内存回收机制分为两种：删除过期对象，达到maxmemory溢出策略。</p><p>Redis中过期数据删除策略分为两种：惰性删除，从节点不会主动删除超时数据，主节点每次处理读取命令时，都会检查键是否超时；定时删除：Redis主节点进行定时任务采样一定数据量的键，当发现采样的键过期，则删除（默认每秒10次）。在Redis 3.2中增加了，从节点读取数据之前检查键的过期时间来决定是否返回数据。</p><p><img src="/2019/06/03/Redis总结/定时任务删除过期键逻辑.jpg" alt="定时任务删除过期键逻辑"></p><p>为什么在慢模式下执行超时后，需要改为快模式执行呢？在快模式下，超时时间为1毫秒，且2秒内只能运行一次。其中减少了超时时间，并且降低了执行频率。目的是为了保证对主线程不造成性能的影响。</p><p>内存溢出控制策略：</p><ul><li><code>noeviction</code>：默认策略，不会删除任何数据，达到上限时返回OOM</li><li><code>volatitl-lru</code>：达到上限时根据LRU删除设置了超时属性的键</li><li><code>allkeys-lru</code>：根据LRU算法删除键（不考虑是否设置了超时属性）</li><li><code>allkeys-random</code>：随机删除所有键，直到腾出足够空间为止</li><li><code>valatile-random</code>：随机删除有超时属性的键</li><li><code>valatile-ttl</code>：根据键值对象ttl属性，删除最近将要过期数据。</li></ul><p>可以通过设置成<code>allkeys-lru</code>策略把Redis变为纯缓存服务器使用。</p><p>每次Redis执行命令时，如果设置了<code>maxmemory</code>参数，都会尝试进行内存回收操作（不一定执行），如果使用内存大于上限值，则会根据一定当前策略进行回收。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>redisObject对象结构如下：</p><p><img src="/2019/06/03/Redis总结/redisObject内部结构.jpg" alt="redisObject内部结构"></p><blockquote><p>缩减key和value的长度，value可以通过压缩降低内存占用。（当频繁压缩解压时，需要考虑压缩和解压的开销成本）</p></blockquote><p>共享对象池是指Redis内部维护<code>[0-9999]</code>的整数对象池。当设置了<code>maxmemory</code>并启用了LRU相关淘汰策略，Redis禁止使用共享对象池。</p><p>对于ziplist编码的值对象，即使内部数据为整数也无法使用对象池，因此ziplist使用压缩且内存连续的结构。对象共享判断成本过高。</p><p>Redis自己实现了字符串结构，内部简单动态字符串（SDS）。</p><blockquote><p>尽量减少字符串频繁修改操作，如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</p></blockquote><blockquote><p>使用二级存储也能帮我们节省内存。</p></blockquote><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>编码就是具体使用那种底层数据结构来实现。通过不同的编码实现效率和空间的平衡。</p><p>编码类型转换在Redis写入数据时自动完成，这个转换过程时不可逆的，转换规则只能从小内存编码向大内存编码转换。</p><p>可以使用<code>config set</code>命令设置编码相关参数来满足使用压缩编码的条件。对于已经采用非压缩编码类型的数据，如<code>hashtable`</code>linkedlist`等，设置参数后即使数据慢煮编码条件，Redis也不会做转换，需要重启Redis重新加载数据才能完成转换。</p><p>ziplist主要目的是为了节约内存，采用线性连续的内存结构。</p><p><img src="/2019/06/03/Redis总结/ziplist内部结构.jpg" alt="ziplist内部结构"></p><p>ziplist其数据结构特点如下：</p><ul><li>一块连续内存数组</li><li>可以模拟双向列表结构，以O(1)实际复杂度入队出队</li><li>新增、删除操作涉及内存重新分配或释放，加大操作的复杂性</li><li>读写超过涉及复杂的指针移动，最坏时间复杂度为O(n^2)</li><li>适合存储小对象和长度有限的数据</li></ul><blockquote><p>针对性能要求较高的场景使用ziplist，建议长度不要超过1000，每个元素大小控制在512字节以内。</p></blockquote><p>intset：存储有序、不重复的整数集。intset编码结构包括<code>encoding`</code>length<code></code>contents`。其中类型是根据长度划分，当保存的整数类型超过当前类型，会自动触发升级并且升级后不再回退。</p><blockquote><p>使用intset编码的集合时，尽量保持整数范围一致，防止个别大整数导致集合元素类型升级，产生内存浪费。</p></blockquote><h5 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h5><blockquote><p>Redis内存不足时，首先考虑的问题不是加机器做水平扩展，应该先尝试做内存优化，当遇到瓶颈时在去考虑水平扩展。</p></blockquote><hr><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><p>Redis Sentinel（哨兵）是一种Redis高可用实现方案。其中包括若干个Sentinel节点和Redis数据节点。每个Sentinel节点会对数据节点和其余Sentinel节点进行监控。</p><p>当发现节点不可达时，进行标记。如果该节点是主节点，该Sentinel节点将和其他Sentinel节点进行协商，如果大多数节点认为主节点不可达，会选举出一个Sentinel节点来完成自动故障转移。</p><p>Sentinel节点本质是一个特殊的Redis节点。Redis Sentinel中的数据节点和普通的数据节点在配置上没有区别，只增加了一些Sentinel节点对它们进行监控。</p><blockquote><p>生产环境中建议Redis Sentinel的所有节点应该分布在不同物理机上。<br>Sentinel节点数和数据节点的数量没有关系。只至少需要3个Sentinel节点来保障系统的健壮性。</p></blockquote><p>配置中<code>&lt;quorum&gt;</code>用于故障发现和判定，至少有<code>quorum</code>个Sentinel节点认为主节点不可达，则认为该节点客观不可达。一般建议设置为Sentinel节点的一半加1。</p><p><code>down-after-milliseconds</code>配置代表用于判断超过时间并有有效回复则判定节点不可达。其对于Sentinel节点、主节点、从节点的失败判定同时有效。</p><p><code>parallel-syncs</code>用来限制在一次故障转移后，每次向新的主节点发起复制操作的从节点个数。</p><p><code>failover-timeout</code>的作用较多。1）当对一个主节点故障转移时，下次转移起始时间是<code>failover-timeout</code>的两倍；2）在晋升选出的从节点为主节点时，如果在选出的从节点上执行<code>slaveof no one</code>一直失败，如果超过这个时间，则故障转移失败；3）Sentinel节点执行info命令来确实选出的从节点晋升主节点，这个阶段超时则故障转移失败；4）在命令其余从节点复制新的主节点时，如果超过这个时间（不包含复制时间）则故障转移失败。<strong>注意：即使从节点复制主节点阶段超过这个时间，Sentinel节点也会最终配置从节点去同步最新的主节点</strong>。</p><p>一套Sentinel可以监控多个主节点，一般根据是否是同一个业务的多个主节点集合来判断是否监控多个主节点。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ul><li>每隔10秒，每隔Sentinel节点向主节点和从节点发送info命令获取最新的拓扑结构</li><li>每隔2秒，每隔Sentinel节点向Redis数据节点<code>__sentinel__:hello</code>频道上发送该Sentinel节点对主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，用于了解其他Sentinel节点以及它们对主节点的判断。（发现新的Sentinel节点，交换主节点的状态）</li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送ping命令做一次心跳检测，确认这些节点当前是否可达。</li></ul><h5 id="下线"><a href="#下线" class="headerlink" title="下线"></a>下线</h5><p><strong>主观下线</strong>：在每个Sentinel节点每隔1秒对其他所有节点发送ping命令做心跳检测，如果这些节点在<code>down-after-milliseconds</code>没有进行有效回复，则该Sentinel节点对该节点做失败判定。</p><p><strong>客观下线</strong>：当判断主观下线时，该Sentinel节点通过<code>sentinel is-master-down-by-addr</code>命令向其他Sentinel节点询问对主节点的判断，当超过<code>&lt;quorum&gt;</code>时，则认为主节点确实有问题，这时做出客观下线的决定。</p><h5 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h5><p>Redis在进行客观下线后，Sentinel节点通过选举选出领导者，领导者进行故障转移工作。其中使用Raft算法实现领导者选举。</p><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p><img src="/2019/06/03/Redis总结/选出最好的节点.jpg" alt="选出最好的节点"></p><ul><li>从列表中选出一个节点作为新的主节点</li><li>Sentinel领导者节点对选出的节点执行<code>slaveof no one</code>命令</li><li>Sentinel领导者节点向其他从节点发送命令，让它们成为新主节点的从节点</li><li>原来的主节点更新为从节点，当恢复后命令它复制主节点</li></ul><h4 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h4><p>部署各个节点的机器时间尽量要同步，否则日志的时序性会混乱。（NTP服务）</p><p>Sentinel节点依然会对这些下线节点进行定期监控。</p><p>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化。</p><hr><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>Redis分布式方案一般有两种：客户端分区方案，代理方案。官方提供Redis Cluster。</p><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>分布式数据库需要解决将数据集划分到多个节点上，每个节点负责整体数据的一个子集。常见分区规则有哈希分区、顺序分区。</p><ul><li>节点取余<ul><li>当节点扩容或收缩节点，数据节点映射关系需要重新计算，导致数据的重新迁移。</li></ul></li><li>一致性哈希：为系统中的每个节点分配一个token（0～2^32），这些token组成哈希环。数据读写操作时，根据key计算hash，然后顺时针找到第一个大于等于该哈希值的token节点。<ul><li>加减节点会造成哈希环中部分数据无法命中，需要手动处理或忽略，常用于缓存场景</li><li>少量节点时，节点的变化将大范围影响哈希环中数据映射，不适合少量数据节点方案</li><li>需要增加一倍或者减半才能保证数据和负载的均衡</li></ul></li><li>虚拟槽：使用分散度良好的哈希函数把所有数据映射到固定范围的整数集合中，整数定义为槽，这个范围远大于节点数，Redis Cluster中的范围是0～16383。每个节点负责一定数量的槽。</li></ul><p>Redis Cluster采用虚拟槽分区。</p><ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度；</li><li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；</li><li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ul><p>限制：</p><ul><li>key批量操作支持有限</li><li>key事务操作支持有限</li><li>key作为数据分区的最小粒度，因此不能将一个大的键值对象映射到不同的节点</li><li>不支持多数据空间</li><li>复制结构只能支持一层</li></ul><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><p>Redis集群采用Gossip协议进行通信，原理是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整信息。</p><p>常见的Gossip消息分为下面几种：</p><ul><li>meet：通知新节点加入</li><li>ping：集群内每个节点每秒向多个其他节点发送ping消息，监测节点是否在线并交换彼此状态信息</li><li>pong：接受meet和ping消息时，回复给发送方确认消息正常通信，其中封装了自身的状态数据（节点也可以向集群内广播自身pong消息来通知整个集群对自身状态更新）</li><li>fail：当节点判定集群内另一个节点下线时，向集群内广播一个fail消息，其他节点接受不了fail消息后，将对应的节点更新为下线状态</li></ul><p>Redis集群内节点通信采用固定频率（定时任务每秒执行10次）。每个节点维护定时任务默认每秒执行10次，每秒会随机选取5个节点找出最久没有通信的节点发送ping消息。（每100毫秒都会扫描本地节点列表，如果发现节点最久一次接受pong消息的时间大于<code>cluster_node_timeout/2</code>，则立即发送ping消息。<code>cluster_node_timeout</code>参数默认15秒。</p><h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><p>集群伸缩，即扩容和缩容，原理是槽和数据在节点之间的移动。</p><p><img src="/2019/06/03/Redis总结/槽和数据迁移流程.jpg" alt="槽和数据迁移流程"></p><p>在数据迁移过程中，集群可以正常提供读写服务。</p><p>在集群下添加从节点，使用<code>cluster replicate {masterNodeId}</code>，slaveof命令在集群模式不在支持。执行添加从节点命令后，从节点会对主节点发起全量复制，并且更新本地节点的集群相关状态。</p><p><img src="/2019/06/03/Redis总结/节点安全下线.jpg" alt="节点安全下线"></p><p>注意：对于主从节点都下线的情况，建议先下线从节点再下线主节点，避免不必要的全量复制。</p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>Redis Cluster没有采用代理方式，而是采用客户端直连的方式。</p><p><img src="/2019/06/03/Redis总结/MOVED重定向执行流程.jpg" alt="MOVED重定向执行流程"></p><p>Redis 接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。</p><p>使用redis-cli命令时，加入-c参数支持自动重定向。其本质是client收到了MOVED信息后再次发起请求。</p><p><strong>Smart客户端</strong>通过在内部维护<code>slot-&gt;node</code>的映射关系，本地就可实现键到节点的查找，从而保证IO效率最大化，而MOVED重定向复制协助Smart客户端更新<code>slot-&gt;node</code>映射。</p><p><strong>ASK重定向</strong>说明集群正在进行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能临时性的重定向，客户端不会更新slot缓存。</p><p>注意：当在集群环境下使用mget、mset等批量操作时，slot迁移数据期间由于键列表无法保证在同一节点，会导致大量错误。</p><p>集群环境下对于使用批量操作的场景，建议优先使用Pipeline方式，在客户端实现对ASK重定向的正确处理，既可以通过批量操作进行IO优化，又可以兼顾slot迁移场景。</p><h4 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h4><p><strong>主观下线</strong>：</p><p><img src="/2019/06/03/Redis总结/主观下线.jpg" alt="主观下线"></p><p>与Redis Sentinel的主观下线不同的时，Redis Cluster中主观下线是直接通过节点通信来判断的，而Sentinel中是通过Sentinel监控节点通信判断的。</p><p><strong>客观下线</strong>：集群中的故障节点的下线报告通过Gossip消息在节点中传播。当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。（必须半数以上是为了应对网络分区的原因造成的集群分割情况，被分割的小集群无法完成主观下线到客观下线这个关键过程，从而防止小集群完成故障转移继续对外提供服务。）</p><p>注：如果在<code>cluster-node-time * 2</code>的时间内该下线报告没有得到更新则过期删除。（不建议将<code>cluster-node-time</code>设置得太小。</p><p><img src="/2019/06/03/Redis总结/客观下线.jpg" alt="客观下线"></p><p>部署时需要注意网络分区的情况导致分割。主从结构需要根据自身机房/机架拓扑结构，降低主从被分区的可能性。</p><h5 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h5><ul><li>资格检查。判断从节点是否有资格替换故障的主节点。</li><li>准备选举时间。采用延迟触发。通过对多个从节点使用不同的延迟选举时间来支持不同节点的优先级。</li><li>发起选举。每个主节点自身维护了一个配置纪元（<code>clusterNode.configEpoch</code>)标示当前主节点的版本，所有主节点的配置纪元都不相等，从节点会复制主节点的配置纪元。整个集群维护一个全局的纪元，记录集群中的纪元的最大版。更新纪元后，然后在集群中广播选举消息。<ul><li>纪元标示每个主节点的不同版本和当前集群最大版本</li><li>集群出现新的主节点，通过纪元来记录</li><li>更大配置纪元代表了更新了集群状态。如果出现slots等关键信息不一致时，以纪元最大的为准。</li></ul></li><li>选举投票。只有持有槽的主节点才会处理故障选举消息。当某个从节点获得<code>N/2+1</code>个节点的选票，则选举成功。当在<code>cluster-node-timeout * 2</code>内没有选举成功，则进行下一轮选举。</li><li>替换主节点。</li></ul><h4 id="附"><a href="#附" class="headerlink" title="附"></a>附</h4><p>注意开发和运维中场景问题：超大规模集群带宽消耗、pub/sub广播问题、集群节点倾斜问题、手动故障转移、在线迁移数据等。</p><hr><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><ul><li><strong>LRU/LFU/FIFO算法剔除</strong>：当缓存使用量超过预设的最大值，则进行剔除。一致性差，维护成本低。</li><li><strong>超时剔除</strong>：一致性较差，维护成本较低。</li><li><strong>主动更新</strong>：一致性强，维护成本高。</li></ul><p>建议在低一致性的业务配置最大内存和淘汰策略的方式使用。高一致性的业务中使用超时剔除和主动更新。</p><h4 id="穿透优化"><a href="#穿透优化" class="headerlink" title="穿透优化"></a>穿透优化</h4><ul><li>缓存空对象。优点：保护了后端数据；缺点：占Redsi内存，且更容易出现不一致情况。</li><li>布隆过滤器拦截。利用位数组很简洁地表示一个集合，并判断一个元素是否属于这个集合。使用布隆过滤器，存在第一类出错（Falsepositive），但是不会存在第二类错误（Falsenegative），因此，拥有100%的召回率。</li></ul><h4 id="无底洞优化"><a href="#无底洞优化" class="headerlink" title="无底洞优化"></a>无底洞优化</h4><ul><li>客户端一次批量操作会涉及多次网络操作，意味着批量操作随着节点增多，耗时会不断增大。</li><li>网络连接数变多，对节点的性能也有一定影响。</li></ul><p>主要对批量操作的优化方式是：并行IO，使用hash_tag。</p><h4 id="雪崩优化"><a href="#雪崩优化" class="headerlink" title="雪崩优化"></a>雪崩优化</h4><ul><li>保证缓存层服务高可用性</li><li>依赖隔离组件为后端限流并降级</li><li>提前演练</li></ul><h4 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h4><p>当某个热点key，在缓存失效瞬间，有大量线程来重建缓存，会造成后端负载过大，甚至崩溃。</p><p>解决办法：</p><ul><li>互斥锁。思路简单，保证一致性。代码复杂度高，存在死锁风险，存在线程池阻塞风险。</li><li>永不过期。优点是基本杜绝了热点key问题。不保证一致性，逻辑过期时间增加代码维护成本和内存成本。</li></ul><hr><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><h4 id="Twemproxy"><a href="#Twemproxy" class="headerlink" title="Twemproxy"></a>Twemproxy</h4><p>Twemproxy是Twitter开源的代理分片机制，Twemproxy作为代理，可接受来自多个程序的访问，按照路由规则，转发给后台的各个Redis服务器，再原路返回，并且它还可以减少与后端缓存的连接数。使用Keepalived来实现高可用。</p><h4 id="Predixy"><a href="#Predixy" class="headerlink" title="Predixy"></a>Predixy</h4><p><a href="https://github.com/joyieldInc/predixy/blob/master/README_CN.md" target="_blank" rel="noopener">相关文档</a></p><h4 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h4><p><a href="https://github.com/CodisLabs/codis/" target="_blank" rel="noopener">相关文档</a></p><hr><h3 id="附-1"><a href="#附-1" class="headerlink" title="附"></a>附</h3><ul><li><a href="https://yq.aliyun.com/articles/531067" target="_blank" rel="noopener">阿里云Redis开发规范</a></li></ul><hr></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2019/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AC%A7%E6%B4%B2%E5%AF%B9%E7%8E%B0%E4%BB%A3%E6%96%87%E6%98%8E%E5%BD%B1%E5%93%8D%E8%BF%99%E4%B9%88%E6%B7%B1-%E8%AF%BB%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/head.png"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="小浊微清的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2019/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AC%A7%E6%B4%B2%E5%AF%B9%E7%8E%B0%E4%BB%A3%E6%96%87%E6%98%8E%E5%BD%B1%E5%93%8D%E8%BF%99%E4%B9%88%E6%B7%B1-%E8%AF%BB%E6%9E%81%E7%AE%80%E6%AC%A7%E6%B4%B2%E5%8F%B2/" class="post-title-link" itemprop="url">为什么欧洲对现代文明影响这么深--读极简欧洲史</a></h2><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-24 23:07" itemprop="dateCreated datePublished" datetime="2019-04-24T23:07:31+08:00">2019-04-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-05-11 20:51" itemprop="dateModified" datetime="2019-05-11T20:51:29+08:00">2019-05-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/read/" itemprop="url" rel="index"><span itemprop="name">read</span></a></span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2019/04/24/为什么欧洲对现代文明影响这么深-读极简欧洲史/极简欧洲史.png" alt="极简欧洲史"></p><p>为什么欧洲发展了理论科学，而我们的先辈却只有文学和实用科学？</p><p>为什么我们现在所奉行的制度基本都源于欧洲，相比较而言，优势是什么？</p><p>首先，必须说，我是一个对于欧洲哲学十分喜欢的人，在欧洲所发展起来的哲学正是目前社会科学的开端。我喜欢其中对于一些幸福、人性的探讨。</p><p>第一处惊讶之处在于——古典时期到中世纪的欧洲，“并非所有东西都属于国王所有”，是欧洲政府思维的基石。因此，国王、政府的权利都是有限的，国王以及政府都不能完全地为所欲为。</p><p>第二处惊讶是，欧洲脱离宗教的控制是缓慢的，并且存在一段宗教控制的时候，在宗教控制时期，并没有出现对于文化、学识等的打量打压，反而古代的知识等都靠宗教留存下来。</p><p>不得不承认，在欧洲在发展中，除了中间一段时间的统一，一直都存在于多元化的发展中，各个国家都在不停的竞争，文化、经济上的竞争。而在中国古时候，主要人力思维，都主要奉献在了四书五经，达到一种极高的思维认同，这种认同的遗留依然存在于现在。在我看来，正是这种原因，因此欧洲和中国的发展思路是不同的。</p><p>而经过全球化后，国家之间的关系相比较原来，更加紧密，因此对于原来的对于中国的以自己为中心的发展方式现实出来了明显的缺点。并且对于欧洲所证明的那套政治、经济发展可行性。因此世界都在学习这种成功的经验。</p><p>我一直在想，我们相比较来说，优势是什么？</p><p>相比较西方的文化等，我们的优势是什么？我一直没想通，这个待提醒。</p><p>注：本文并非妄自菲薄，只是单纯的思考。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><nav class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">feiybox</span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/pace.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>