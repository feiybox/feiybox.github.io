<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/f.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/f.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/f.png"><link rel="mask-icon" href="/images/f.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><script class="next-config" data-name="main" type="application/json">{"hostname":"feiybox.com","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="软件构建的设计 软件的首要技术使命是管理复杂性。以简单性作为目标的设计方案对此最有帮助。 简单性可通过两种方式来实现：一是尽量减少任何人在大脑在任何时候必须处理的本质上复杂性的数量；二是防止偶然的复杂性无谓地扩散。 设计是一种启发式过程。固守于某种单一的方法会抑制创新能力，进而损及程序。 优秀的设计都是迭代而来的。尝试的设计可能性越多，最终的设计方案越好。 信息隐藏是一个非常有价值的概念。通过询问"><meta property="og:type" content="article"><meta property="og:title" content="《代码大全》笔记 —— 模块二：高质量的代码"><meta property="og:url" content="https://feiybox.com/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%8C%EF%BC%9A%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/index.html"><meta property="og:site_name" content="feiybox"><meta property="og:description" content="软件构建的设计 软件的首要技术使命是管理复杂性。以简单性作为目标的设计方案对此最有帮助。 简单性可通过两种方式来实现：一是尽量减少任何人在大脑在任何时候必须处理的本质上复杂性的数量；二是防止偶然的复杂性无谓地扩散。 设计是一种启发式过程。固守于某种单一的方法会抑制创新能力，进而损及程序。 优秀的设计都是迭代而来的。尝试的设计可能性越多，最终的设计方案越好。 信息隐藏是一个非常有价值的概念。通过询问"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-05-18T08:09:00.000Z"><meta property="article:modified_time" content="2024-05-18T09:06:12.213Z"><meta property="article:author" content="feiybox"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://feiybox.com/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%8C%EF%BC%9A%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://feiybox.com/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%8C%EF%BC%9A%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/","path":"2024/05/18/《代码大全》笔记-——-模块二：高质量的代码/","title":"《代码大全》笔记 —— 模块二：高质量的代码"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>《代码大全》笔记 —— 模块二：高质量的代码 | feiybox</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">feiybox</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">DO MORE DO BETTER</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-projects"><a href="/projects/" rel="section"><i class="fa fa-sitemap fa-fw"></i>项目</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">软件构建的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%8C%91%E6%88%98"><span class="nav-number">1.1.</span> <span class="nav-text">设计挑战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">关键设计概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%9E%84%E5%BB%BA%E5%9F%BA%E5%9D%97%EF%BC%9A%E5%90%AF%E5%8F%91%E5%BC%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">设计构建基块：启发式方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.4.</span> <span class="nav-text">设计实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">可以工作的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88ADT%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">类的基础：抽象数据类型（ADT）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%89%AF%E5%A5%BD%E7%9A%84%E7%B1%BB%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.2.</span> <span class="nav-text">良好的类接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">设计和实现的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E7%90%86%E7%94%B1"><span class="nav-number">2.4.</span> <span class="nav-text">创建类的理由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E5%AE%9A%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text">语言特定问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E8%B6%8A%E7%B1%BB%EF%BC%9A%E5%8C%85"><span class="nav-number">2.6.</span> <span class="nav-text">超越类：包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">高质量子程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A3%E5%BD%93%E7%90%86%E7%94%B1"><span class="nav-number">3.1.</span> <span class="nav-text">创建子程序的正当理由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%BA%A7%E5%88%AB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.2.</span> <span class="nav-text">子程序级别的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A5%BD%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0"><span class="nav-number">3.3.</span> <span class="nav-text">好的子程序名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%BA%94%E8%AF%A5%E6%9C%89%E5%A4%9A%E9%95%BF"><span class="nav-number">3.4.</span> <span class="nav-text">一个子程序应该有多长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">如何使用子程序参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.6.</span> <span class="nav-text">函数使用中的特别注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%86%85%E8%81%94%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.7.</span> <span class="nav-text">宏子程序和内联子程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">防御式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%BF%E5%85%B6%E5%85%8D%E5%8F%97%E6%97%A0%E6%95%88%E8%BE%93%E5%85%A5%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">4.1.</span> <span class="nav-text">保护程序，使其免受无效输入的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-number">4.2.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF"><span class="nav-number">4.3.</span> <span class="nav-text">错误处理技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">4.4.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%BD%BF%E4%B9%8B%E5%8C%85%E5%AE%B9%E7%94%B1%E9%94%99%E8%AF%AF%E9%80%A0%E6%88%90%E7%9A%84%E6%8D%9F%E5%AE%B3"><span class="nav-number">4.5.</span> <span class="nav-text">隔离程序，使之包容由错误造成的损害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%BE%85%E5%8A%A9%E4%BB%A3%E7%A0%81"><span class="nav-number">4.6.</span> <span class="nav-text">调试辅助代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BF%9D%E7%95%99%E5%A4%9A%E5%B0%91%E9%98%B2%E5%BE%A1%E5%BC%8F%E4%BB%A3%E7%A0%81"><span class="nav-number">4.7.</span> <span class="nav-text">确定在生产代码中保留多少防御式代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%87%87%E5%8F%96%E9%98%B2%E5%BE%A1%E7%9A%84%E5%A7%BF%E6%80%81"><span class="nav-number">4.8.</span> <span class="nav-text">对防御式编程采取防御的姿态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">伪代码编程过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%9E%84%E5%BB%BA%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.</span> <span class="nav-text">类和子程序构建步骤总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E4%B8%93%E5%AE%B6%E7%9A%84%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.</span> <span class="nav-text">面向专家的伪代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PPP-%E6%9E%84%E5%BB%BA%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.3.</span> <span class="nav-text">使用 PPP 构建子程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPP-%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">5.4.</span> <span class="nav-text">PPP 的替代方案</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">feiybox</p><div class="site-description" itemprop="description">青纸's Blog</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">101</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">标签</span></a></div></nav></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://feiybox.com/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%BA%8C%EF%BC%9A%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="feiybox"><meta itemprop="description" content="青纸's Blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="feiybox"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">《代码大全》笔记 —— 模块二：高质量的代码</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-05-18 16:09:00" itemprop="dateCreated datePublished" datetime="2024-05-18T16:09:00+08:00">2024-05-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>6.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="软件构建的设计"><a href="#软件构建的设计" class="headerlink" title="软件构建的设计"></a>软件构建的设计</h2><ul><li>软件的首要技术使命是管理复杂性。以简单性作为目标的设计方案对此最有帮助。</li><li>简单性可通过两种方式来实现：一是尽量减少任何人在大脑在任何时候必须处理的本质上复杂性的数量；二是防止偶然的复杂性无谓地扩散。</li><li>设计是一种启发式过程。固守于某种单一的方法会抑制创新能力，进而损及程序。</li><li>优秀的设计都是迭代而来的。尝试的设计可能性越多，最终的设计方案越好。</li><li>信息隐藏是一个非常有价值的概念。通过询问 “我应该隐藏什么？” 来解决许多非常困难的设计问题。</li></ul><h3 id="设计挑战"><a href="#设计挑战" class="headerlink" title="设计挑战"></a>设计挑战</h3><p>“软件设计” 是指构思、发明或设计将计算机软件规范编程可工作的软件的一种方案。“设计” 是将需求与编码和调试联系起来的活动。好的顶层设计提供了可以安全地包含多个低层设计的结构。好的设计对小的项目有用，对大型的项目，更是不可或缺的刚需。</p><p>设计工作的一个关键部分是权衡相互竞争的设计特性，并从中取得平衡。</p><h3 id="关键设计概念"><a href="#关键设计概念" class="headerlink" title="关键设计概念"></a>关键设计概念</h3><p>好的设计取决于对少数几个关键概念的理解。</p><p>软件架构层面，问题的复杂性通过将系统系统划分为子系统来降低。</p><p>保持子程序简短，有助于减轻心智负担。从问题领域的角度来写程序，而不是从低层次的设计细节的角度来写，并在最高的抽象层次上工作，可以减少大脑的负担。</p><p><strong>高成本、低效率的设计有三个来源：</strong></p><ul><li>用复杂方案解决简单问题</li><li>用简单的、不争气的方案解决复杂问题</li><li>用不合适的、复杂的方案解决复杂问题</li></ul><p><strong>复杂性的管理要双管齐下：</strong></p><ul><li>尽量减少任何人的大脑在任何时候都必须处理的本质上的复杂性的数量</li><li>防止偶然的复杂性无谓的扩散</li></ul><p>一条好的常规原则是，系统层次的图应该是无环图，程序不应包含任何循环关系。</p><h3 id="设计构建基块：启发式方法"><a href="#设计构建基块：启发式方法" class="headerlink" title="设计构建基块：启发式方法"></a>设计构建基块：启发式方法</h3><p>“按部就班” 的面向对象方法，侧重于确定现实世界对象和合成对象。</p><p>抽象是指在使用一个概念时，安全忽略其部分细节的能力，也就是在不同的层次处理不同细节的能力。</p><p>封装是抽象的延续。抽象的意思是 “你允许从高的细节层次观察对象”。封装的意思是 “除此之外，你不可以从其他任何细节层次观察对象”。</p><p><strong>信息隐藏是结构化设计和面向对象设计的基础之一</strong>。（暴露有限的部分，其它皆隐藏）</p><ul><li>隐藏复杂性，这样大脑不必处理，除非特别关注它。</li><li>隐藏变化源，当变化发生时，其影响被限制在局部。</li></ul><p>适应变化是优秀程序设计最具有挑战性的一个方面。目标是隔离不稳定性的区域，这样变化的影响就会被限制在一个子程序、类和包中。</p><p><strong>状态变量：</strong></p><ul><li>不要用布尔变量作为状态变量。改为使用枚举类型。</li><li>使用访问器子程序而不是直接检查变量。</li></ul><p>松散耦合的意义在于，有效的模块提供了一个额外的抽象层次，写好保证能用。</p><p><strong>为测试而设计</strong>：这个很重要，以前常忽略。</p><p>考虑使用蛮力：不要轻易使用不易理解的算法，或者解法。</p><p>画图时另一个强大的启发式工具。一图胜千言。</p><p>有些问题可以尝试先累积经验、再解决。</p><h3 id="设计实践"><a href="#设计实践" class="headerlink" title="设计实践"></a>设计实践</h3><p>分而治之：增量改进时管理复杂性的一个强有力的工具。</p><p>自上而下和自下而上策略设计方法的关键区别在于，一个是分解策略，另一个是合成策略。</p><p>团队的经验、系统的预期寿命、期望的可靠水平以及项目和团队的规模都应考虑在内。</p><p>设计文档需要精简。细节程度与队伍人员经验关切起来。</p><h2 id="可以工作的类"><a href="#可以工作的类" class="headerlink" title="可以工作的类"></a>可以工作的类</h2><ul><li>类的接口应提供一致的抽象。许多问题都是由于违反原则而引起的。</li><li>类的接口应隐藏一些信息，包括系统接口、设计决策或实现细节。</li><li>“包含” （has a）往往比 “继承” （is a）更可取，除非必须建模 is a 关系。</li><li>继承是有用的工具，但它会增加复杂性，这违背了软件的首要技术使命，即 “管理复杂性”。</li><li>类是管理复杂性的首选工具。只有在设计类时给予足够的关注，才能实现这一目标。</li></ul><h3 id="类的基础：抽象数据类型（ADT）"><a href="#类的基础：抽象数据类型（ADT）" class="headerlink" title="类的基础：抽象数据类型（ADT）"></a>类的基础：抽象数据类型（ADT）</h3><p>抽象数据类型（Abstract Data Type, ADT）是数据和对这些数据进行的操作的一个集合。</p><h3 id="良好的类接口"><a href="#良好的类接口" class="headerlink" title="良好的类接口"></a>良好的类接口</h3><p>尽可能使接口可编程而不是表达语义：每个接口都是由一个可编程的部分和一个语义部分构成。</p><p>把抽象和内聚放在一起考虑：抽象和内聚的概念密切相关，呈现良好的抽象的类接口通常有很强的内聚性。</p><p>最小化类和成员的可访问性：最小化可访问性是旨在鼓励封装的若干规则之一。</p><p>避免将私有实现细节放在类的接口中：如果是真正的封装，程序员根本看不到实现细节。</p><p>不要对类的用户做出预设：类的设计和实现应遵守类接口所隐含的契约。除了接口文档所提供的内容，不要对接口的使用方式做出其他预设。</p><p>不要因为子程序只使用了公共子程序就把它放到公共接口中：考虑其合理性，而不是实现的需要性考虑。</p><p>面向接口实现与封装，需要看到接口文档就会明白该怎么使用。</p><p>警惕过于紧密的耦合，几个常规的指导原则：</p><ul><li>最小化减少类和成员的可访问性。</li><li>避免使用 <code>friend</code> 类，因其紧密耦合。</li><li>将基类中的数据变成 <code>private</code> 而不是 <code>protected</code>, 使派生类和基类的耦合不那么紧密。</li><li>避免的类的公共接口中公开成员数据。</li><li>警惕在语义上破坏封装。</li><li>遵守 “得墨忒耳法则”。</li></ul><h3 id="设计和实现的问题"><a href="#设计和实现的问题" class="headerlink" title="设计和实现的问题"></a>设计和实现的问题</h3><p>除非万不得已，否则不要通过私有继承实现 has a 关系。</p><p>警告数据成员超过 7 个的类：7+-2 被认为是一个人在执行其他任务时能记住的离散项目的数量。如果一个类包含的数据乘员超过 7 个，就要考虑该类是否应分解成多个小类。</p><p>要么设计继承并提供文档说明，要么禁止继承。继承需要谨慎，太多的继承会难以理解。</p><p>确保只继承想要继承的东西：派生类可以继承成员子程序接口、实现或同时继承两者。</p><p>继承而来的子程序有三种基本形式：</p><ul><li>抽象且可覆盖的子程序是指派生类只继承子程序的接口，但不继承其实现。</li><li>可覆盖的子程序是指派生类继承子程序的接口及其默认实现，并且可以覆盖该默认实现。</li><li>不可覆盖的子程序是指派生类继承子程序的接口及其默认实现，但不允许覆盖该默认实现。</li></ul><p>不要 “覆盖” 不可覆盖的成员函数。不要在派生类中重用不可覆盖的基类子程序名称。</p><p>避免过深的继承树。建议将继承层级限制在最多 6 层。大多数人都很难在大脑中同时处理超过两到三层的继承关系。</p><p><strong>何时使用 “继承”（is a）以及何时使用 “包含”（has a）</strong>：</p><ul><li>如果多个类有共同的数据，但没有共同的行为，就创建一个共同的对象供这些类包含。</li><li>如果多个类有共同的行为，但没有共同的数据，就从定义了共同子程序的一个共同基类中派生出这些类。</li><li>如果多个类有共同的数据和行为，就从定义了共同数据和子程序的一个共同基类中继承。</li><li>如果希望由基类控制你的接口，就选择继承；如果想控制自己的接口就选择包含。</li></ul><p>禁止隐式生成不需要的成员函数和操作符。需要的时候才生成，不需要则不要生成此代码。</p><p>通常情况下，要尽量减少一个类与其他类的协作程度。要尽量减少以下数值：</p><ul><li>实例化的对象种类。</li><li>在实例的对象上进行的各种直接子程序调用的数量。</li><li>在其他实例化的对象所返回的对象上的子程序调用。</li></ul><p>尽可能在所有构造函数中初始化所有成员数据。初始化需要逻辑收敛。</p><p>除非论证可行，否则使用深拷贝。凡不清楚逻辑时即用深拷贝。在深拷贝和浅拷贝的问题上，一个好的办法是除非证明浅拷贝更佳，否则索性无脑使用深拷贝。</p><h3 id="创建类的理由"><a href="#创建类的理由" class="headerlink" title="创建类的理由"></a>创建类的理由</h3><ul><li>避免创建万能类</li><li>消除无关紧要的类</li><li>避免以动词命名的类</li></ul><h3 id="语言特定问题"><a href="#语言特定问题" class="headerlink" title="语言特定问题"></a>语言特定问题</h3><h3 id="超越类：包"><a href="#超越类：包" class="headerlink" title="超越类：包"></a>超越类：包</h3><h2 id="高质量子程序"><a href="#高质量子程序" class="headerlink" title="高质量子程序"></a>高质量子程序</h2><ul><li>创建子程序最重要的原因是为了提高程序的智能可管理性，还可以出于许多其他的原因创建子程序。节省空间往往只是次要原因，而提高可读性、可靠性和可修改行是更重要的原因。</li><li>有时把一个十分简单的的操作改写为一个单独的子程序也能受益匪浅。</li><li>可以将子程序的内聚性分为各种类型，但通过努力可以让大多数子程序实现功能内聚性，这是最理想的内聚性。</li><li>一个子程序的名称代表了其质量。如果名称不好，但却能准确地描述该子程序，那么很有可能是因为这个程序本身设计得不够好。如果名称不好，而且不够准确，它没有告诉人们程序到底做了什么事情。无论怎样，一个糟糕的子程序名称往往意味着程序需要更改。</li><li>只有当子程序的主要目的的是返回其名称所描述的特定返回值时，才应该使用函数。</li><li>细心谨慎的程序员会小心使用宏子程序，并且不到万不得不会使用。</li></ul><p>子程序时单一目的而可被调用的单个方法或过程。</p><h3 id="创建子程序的正当理由"><a href="#创建子程序的正当理由" class="headerlink" title="创建子程序的正当理由"></a>创建子程序的正当理由</h3><p>降低复杂性。一个子程序需要从另一个子程序中单独剥离出来的一个征兆时代码中一个内部循环或条件判断中有深层嵌套。</p><p>避免重复代码。</p><p>提高性能。只把代码放在一个位置可以更容易地剖析问题并发现低效率的代码。</p><h3 id="子程序级别的设计"><a href="#子程序级别的设计" class="headerlink" title="子程序级别的设计"></a>子程序级别的设计</h3><p>功能内聚性：功能内聚性是最强的、最好的内聚类型，发生在一个子程序执行一个且只执行一个操作的时候。</p><p>顺序内聚性：当子程序包含必须按照特定顺序执行的操作时，即依照顺序逐步进行数据共享，并且所有步骤都完成后才能构成一个完整的功能，这种情况下，就存在着顺序内聚性。</p><p>通信内聚性：当一个子程序中有多项操作都使用了相同的数据但彼此没有任何其他关联时，就会存在通信内聚性。</p><p>瞬时内聚性：有时，因此在同一时间会完成多项操作而把这些操作合并为一个子程序，这时就会产生瞬时内聚性。</p><h3 id="好的子程序名称"><a href="#好的子程序名称" class="headerlink" title="好的子程序名称"></a>好的子程序名称</h3><p>创建子程序有效名称的一些指导原则：</p><ul><li>描述子程序所做的一切事情：在子程序的名称中应该描述其所有的输出和副作用。</li><li>避免使用无意义、模糊或空泛的动词。</li><li>不要只用数字来区分子程序名称。</li><li>根据需要为子程序名称选取合适的长度：研究表明，变量名的最佳平均长度为 9 到 15 个字符。</li><li>命名函数时，请使用对其返回值的描述。</li><li>命名过程时，请使用强势动词后接一个对象宾语。“动词 + 对象” 这样的动宾结构。</li><li>准备使用反义词。命名时使用一套反义词命名规范有助于实现名称的一致性表达，从而提高名称的可读性。</li><li>为常用操作建立命名规范。使用一套命名规范来明确指示这些区别往往时最简单和最可靠的。</li></ul><h3 id="一个子程序应该有多长"><a href="#一个子程序应该有多长" class="headerlink" title="一个子程序应该有多长"></a>一个子程序应该有多长</h3><p>理论上，子程序的最理想的长度通常被描述为一屏显示或打印出一到两页的代码，这大概是 50 到 150 行的代码。</p><p>并不需要对子程序强制实行一个长度限制，而是应该结合子程序的内聚性、嵌套深度、变量数量和决策点的数量、解释子程序所需的注释数量以及其他一些与复杂性相关的考量因素来综合判断子程序的长度。</p><h3 id="如何使用子程序参数"><a href="#如何使用子程序参数" class="headerlink" title="如何使用子程序参数"></a>如何使用子程序参数</h3><p>如果有几个子程序使用了相似的一组参数，请将这些相似的参数按一致的顺序排列。子程序参数的顺序有助于人们产生记忆效应，而不一致的顺序会使参数难以记忆。</p><p>请使用所有参数。如果给一个子程序传递了一个参数，就应该使用它。如果不使用它，则应该从子程序接口中把该参数删除掉。</p><p>将状态或错误变量放在最后。按照惯例，状态变量和指示错误发生的变量应当排在参数列表的最后面。</p><p>不要把子程序参数作为工作变量使用。</p><p>将输入值赋给一个工作变量可以强调该值的来源。消除参数列表中的变量被意外修改的可能性。</p><p>将子程序的参数限制在 7 个作用。</p><p>考虑为参数的输入、修改和输出使用命名规范。在一个函数参数中既有入参也有出参，可以用特殊命名办法区分。</p><p>使用有具化名称的参数。在某些编程语言（Python）中，可以显示地将形参与实参关联起来。</p><h3 id="函数使用中的特别注意事项"><a href="#函数使用中的特别注意事项" class="headerlink" title="函数使用中的特别注意事项"></a>函数使用中的特别注意事项</h3><p>如果子程序的主要目的是返回由函数名指示的返回值，那么就应该使用函数。否则，请使用过程。</p><p>不要返回指向局部数据的引用或指针。一旦子程序执行结束，局部数据就会超过作用域，指向局部数据的引用或指针随之失效。</p><h3 id="宏子程序和内联子程序"><a href="#宏子程序和内联子程序" class="headerlink" title="宏子程序和内联子程序"></a>宏子程序和内联子程序</h3><p>把宏表达式放置在圆括号之内。</p><p>使用宏来代替函数调用，这种做法通常被认为是有风险的，而且还会使代码变得难以理解，这并不是一种好的编程实践，所以只限于在特定环境需要且万不得已时才用。</p><p>少使用内联子程序。内联子程序违反了封装原则。</p><h2 id="防御式编程"><a href="#防御式编程" class="headerlink" title="防御式编程"></a>防御式编程</h2><ul><li>生产代码应该以更复杂的方式处理错误，而不只是 “垃圾进，垃圾出”。</li><li>防御式编程技术使错误更容易发现，更容易修复，并能减少对生产代码的损害。</li><li>断言有助于尽早发现错误，尤其是在大型系统、高可靠性系统和快速发现的代码中。</li><li>关于如何处理错误输入的决策是一项关键的错误处理决策，也是一项关键的高层级设计决策。</li><li>异常提供了一种与代码正常工作流维度不同的错误处理手段。如果谨慎使用，它可以成为程序员知识工具箱的一个宝贵的补充，同时它应该与其它错误处理技术进行权衡比较后使用。</li><li>适用于生产系统的约束不一定适用于开发版本。可以利用这一优势，在开发版本中添加有助于快速排查错误的代码。</li></ul><p><strong>防御式编程的主要思想是：即使向子程序传入错误数据，它也不会受到破坏，哪怕这些错误数据是由其它子程序产生的。</strong></p><h3 id="保护程序，使其免受无效输入的影响"><a href="#保护程序，使其免受无效输入的影响" class="headerlink" title="保护程序，使其免受无效输入的影响"></a>保护程序，使其免受无效输入的影响</h3><ul><li>检查来源于外部的所有数据的值：当从文件、用户、网络或其它外部接口获取数据时，请检查数据以确保它们在允许的范围内。</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言在大型复杂程序和可靠性要求很高的程序中特别有用。</p><p>断言可以用于检查以下类型的假设：</p><ul><li>入参或出参的值在预期范围内。</li><li>子程序开始或结束执行时，文件或流处于打开或关闭状态。</li><li>子程序开始或结束执行时，文件或流处于开始或者结束的位置。</li><li>文件或流以只读、只写或读写的方式打开。</li><li>只读属性的入参值没有被子程序修改。</li><li>指针不为空。</li><li>传入子程序的数组或其它容器至少可以容纳 X 个数据元素。</li><li>表已经使用真实的值进行了初始化。</li><li>子程序开始或结束执行时，容器是空的或满的。</li><li>一个经过高度优化的复杂子程序的运算结果与一个较慢但条理清晰的子程序的结果是一致的。</li></ul><p>使用断言的指导原则：</p><ul><li>用错误处理代码来处理预期会发生的情况；用断言来处理永远不应该发生的情况：断言检查的是永远不应该发生的情况；而错误处理代码检查的是可能不会经常发生的非正常情况。</li><li>避免将要执行的代码放在断言中</li><li>使用断言来声明和验证前置条件和后置条件：前置条件和后置条件是 “契约式设计” 这种程序设计和开发方法的一部分。</li><li>对健壮性要求很高的代码，应先使用断言再处理错误</li></ul><h3 id="错误处理技术"><a href="#错误处理技术" class="headerlink" title="错误处理技术"></a>错误处理技术</h3><p>正确性意味着永远不会返回不准确的结果；不返回结果显然胜于返回不准确的结果。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>使用异常来通知程序其它部分不应忽略的错误：异常机制和优越之处在于它能以一种无法被忽略的方式通知有错误发生。</p><p>异常的应用情形与断言相似，都是用来处理那些不仅罕见甚至永远不应该发生的情况。（Java 里 Error 和 Exception 是有区别的）</p><p>避免使用空的 catch 块：有时可能想要有意敷衍一个不知该如何处理异常。至少需要打印日志进行记录。</p><p>一定要知道所用的库代码都会抛出哪些异常。</p><h3 id="隔离程序，使之包容由错误造成的损害"><a href="#隔离程序，使之包容由错误造成的损害" class="headerlink" title="隔离程序，使之包容由错误造成的损害"></a>隔离程序，使之包容由错误造成的损害</h3><p>隔离是一种容损策略。</p><p>以防御式编程为目的而进行隔离的一种方法是，指定某些接口作为 “安全” 区域的边界。</p><p>隔栏外部的子程序应使用错误处理技术，因为对数据进行任何假定都是不安全的。而隔栏内部的子程序里应该使用断言，因为传递给它们的数据应该在通过隔栏之前就已经被清理过。（隔栏内部增加断言保证子系统的防御）</p><h3 id="调试辅助代码"><a href="#调试辅助代码" class="headerlink" title="调试辅助代码"></a>调试辅助代码</h3><p>辅助工具需要隔离到开发版本，不能带到生产版本上。</p><p>进攻式编程：</p><ul><li>确保断言语句可以使程序终止运行。不要让程序员养成遇到已知问题只知道按回车键绕过的习惯。要让问题痛苦到必须进行修复。</li><li>完全填充分配到的所有内存，以便可以检测内存分配方面的错误。</li><li>完全填充分配到的所有文件或流，以便可以排查任何文件格式错误。</li><li>确保每个 case 语中的 default 分支或 else 分支都能产生严重错误，比如说让程序终止运行，或者至少让这些错误不会被忽视。</li><li>在删除对象之前使其填满垃圾数据。</li><li>让程序把错误日志文件通过电子邮件发送给你，让你可以看到已发布软件中发生的各种错误。</li></ul><p>避免调试代码和程序代码纠缠不清。</p><p>增加检查点。（checkpoint）</p><h3 id="确定在生产代码中保留多少防御式代码"><a href="#确定在生产代码中保留多少防御式代码" class="headerlink" title="确定在生产代码中保留多少防御式代码"></a>确定在生产代码中保留多少防御式代码</h3><p>防御式编程中存在这么一种矛盾的观念，在开发阶段希望错误是显而易见的，宁愿看到它心生厌恶，也不愿冒险忽视它。但在生产阶段，你却想让错误尽可能不显山不露水，让程序能优雅地恢复或失败。</p><p>保留用于检查重要错误的代码：确定程序的哪些部分能够承受未检测出错误而造成的后果，哪些部分不能。</p><p>删除用于检查微不足道错误的代码：如果一个错误带来的影响确实微不足道，可以考虑删除用于检查它的代码。</p><p>保留有助于程序优雅崩溃的代码。</p><p>尽可能快速找出问题。</p><h3 id="对防御式编程采取防御的姿态"><a href="#对防御式编程采取防御的姿态" class="headerlink" title="对防御式编程采取防御的姿态"></a>对防御式编程采取防御的姿态</h3><p>要考虑好需要在什么地方进行防御，然后因地制宜地调整防御式编程的优先级。（限制防御的地方、数量）</p><h2 id="伪代码编程过程"><a href="#伪代码编程过程" class="headerlink" title="伪代码编程过程"></a>伪代码编程过程</h2><ul><li>类和子程序的构建通常是一个迭代过程。构建子程序过程中所获得的认知常常会反过来影响类的设计。</li><li>编写好的伪代码需要使用容易理解的自然语言，要避免使用特定编程语言才有的特性，同时要在意图层级上编写伪代码，说明设计应该做什么，而不是具体怎么做。</li><li>伪代码编程过程（PPP）是进行详细设计的一种有用的工具，它也使编码工作变得更容易。伪代码可以直接转换为注释，从而确保了注释的准确性和实用性。</li><li>不要只停留在自己想到的第一个设计方案上。可以反复使用伪代码迭代出若干个方案，选出其中最好的再开始着手编程。</li><li>每一步完成后都检查自己的工作，并鼓励其他人帮忙检查。这样就能够在投入精力最少的时候，用最低的成本发现错误。</li></ul><h3 id="类和子程序构建步骤总结"><a href="#类和子程序构建步骤总结" class="headerlink" title="类和子程序构建步骤总结"></a>类和子程序构建步骤总结</h3><h3 id="面向专家的伪代码"><a href="#面向专家的伪代码" class="headerlink" title="面向专家的伪代码"></a>面向专家的伪代码</h3><h3 id="使用-PPP-构建子程序"><a href="#使用-PPP-构建子程序" class="headerlink" title="使用 PPP 构建子程序"></a>使用 PPP 构建子程序</h3><p>当出现代码错误时，需要先思考自己代码问题。</p><p>大量警告往往意味着代码质量低，应尝试理解显示的每一个警告。检测到任何错误都必须消除。</p><h3 id="PPP-的替代方案"><a href="#PPP-的替代方案" class="headerlink" title="PPP 的替代方案"></a>PPP 的替代方案</h3><p>测试优先开发：测试优先（或测试先行）是一种流行的开发风格，它是指在写任何代码之前，先写好测试用例。</p><p>重构是指通过一系列保留了语义的转换来改进代码。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%B8%80%EF%BC%9A%E5%A5%A0%E5%AE%9A%E5%9F%BA%E7%A1%80/" rel="prev" title="《代码大全》笔记 —— 模块一：奠定基础"><i class="fa fa-chevron-left"></i> 《代码大全》笔记 —— 模块一：奠定基础</a></div><div class="post-nav-item"><a href="/2024/05/18/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E3%80%8B%E7%AC%94%E8%AE%B0-%E2%80%94%E2%80%94-%E6%A8%A1%E5%9D%97%E4%B8%89%EF%BC%9A%E5%8F%98%E9%87%8F/" rel="next" title="《代码大全》笔记 —— 模块三：变量">《代码大全》笔记 —— 模块三：变量 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">feiybox</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">265k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">5:32</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"feiybox","repo":"blog-comment","client_id":"bac26585ffb434df6c23","client_secret":"bfdc72e6a069abd8afd62b3ad0abf5e6c662db78","admin_user":"feiybox","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"27f9de649104a8b464da3ad67ccd300e"}</script><script src="/js/third-party/comments/gitalk.js"></script></body></html>